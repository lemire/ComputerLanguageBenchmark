<?xml version="1.0"?><st-source><!-- Name: ShootoutHideSource: falsePackageName: ComputerLanguageShootoutParcel: #('Shootout')SaveSource: trueDate: 8:52:23 am April 10, 2007 --><time-stamp>From VisualWorksÂ® NonCommercial, 7.4.1 of May 30, 2006 on April 10, 2007 at 8:52:23 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Shootout</name><environment>Smalltalk</environment><private>false</private><imports>			private OS.Stdin			private OS.Stdout			private OS.Stderr			private Smalltalk.*			</imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></name-space><class><name>RandomNumber</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>PiDigitSpigot</name><environment>Shootout</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>z x inverse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>NBodySystem</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>Tests</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>Consumer</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore msg </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>ProducerConsumer</name><environment>Shootout</environment><super>Shootout.Consumer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>consumer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>DNASequenceDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>Transformation</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>q r s t k </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>Body</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y z vx vy vz mass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>Chameleon</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>meetings color semaphore waitingForPair </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>PermGenerator</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timesRotated perm atEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>BitArray</name><environment>Shootout</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>MeetingPlace</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutex first total max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>RepeatStream</name><environment>Shootout</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repeatPtr repeatLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>RandomStream</name><environment>Shootout</environment><super>Shootout.RepeatStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random percentages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>RandomStream2</name><environment>Shootout</environment><super>Shootout.RepeatStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random percentages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><class><name>TreeNode</name><environment>Shootout</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right item </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputerLanguageShootout</category><attributes><package>ComputerLanguageShootout</package></attributes></class><shared-variable><name>Multiplier</name><environment>Shootout.RandomNumber</environment><private>false</private><constant>false</constant><category>computer language shootout</category><initializer>3877</initializer><attributes><package>ComputerLanguageShootout</package></attributes></shared-variable><shared-variable><name>Increment</name><environment>Shootout.RandomNumber</environment><private>false</private><constant>false</constant><category>computer language shootout</category><initializer>29573</initializer><attributes><package>ComputerLanguageShootout</package></attributes></shared-variable><shared-variable><name>Modulus</name><environment>Shootout.RandomNumber</environment><private>false</private><constant>false</constant><category>computer language shootout</category><initializer>139968</initializer><attributes><package>ComputerLanguageShootout</package></attributes></shared-variable><shared-variable><name>FModulus</name><environment>Shootout.RandomNumber</environment><private>false</private><constant>false</constant><category>computer language shootout</category><initializer>139968.0d</initializer><attributes><package>ComputerLanguageShootout</package></attributes></shared-variable><methods><class-id>Shootout.RandomNumber</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="next">next	seed := (seed * Multiplier + Increment) \\ Modulus.	^(seed * scale) asDouble / FModulus</body></methods><methods><class-id>Shootout.RandomNumber</class-id> <category>private</category><body package="ComputerLanguageShootout" selector="to:">to: anInteger   seed := 42.   scale := anInteger</body></methods><methods><class-id>Shootout.RandomNumber class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="to:">to: anInteger   ^self basicNew to: anInteger</body></methods><methods><class-id>Shootout.PiDigitSpigot</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize">initialize   z := Transformation unity.   x := Transformation new.   inverse := Transformation new.</body></methods><methods><class-id>Shootout.PiDigitSpigot</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="next">next   | y |   ^(self isSafe: (y := self digit))      ifTrue: [z := self produce: y. y]      ifFalse: [z := self consume: x next. self next]</body></methods><methods><class-id>Shootout.PiDigitSpigot</class-id> <category>private</category><body package="ComputerLanguageShootout" selector="consume:">consume: aTransformation   ^z * aTransformation</body><body package="ComputerLanguageShootout" selector="contentsSpecies">contentsSpecies	^ByteArray</body><body package="ComputerLanguageShootout" selector="digit">digit   ^(z extract: 3) floor</body><body package="ComputerLanguageShootout" selector="isSafe:">isSafe: aDigit   ^aDigit = (z extract: 4) floor</body><body package="ComputerLanguageShootout" selector="produce:">produce: anInteger   inverse q: 10 r: -10 * anInteger s: 0 t: 1.   ^inverse * z</body></methods><methods><class-id>Shootout.PiDigitSpigot class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="new">new   ^self basicNew initialize</body></methods><methods><class-id>Shootout.NBodySystem</class-id> <category>nbody</category><body package="ComputerLanguageShootout" selector="after:">after: dt   1 to: bodies size do: [:i|      i+1 to: bodies size do: [:j|                                     (bodies at: i) and: (bodies at: j) velocityAfter: dt].   ].      bodies do: [:each| each positionAfter: dt]</body><body package="ComputerLanguageShootout" selector="energy">energy   | e |   e := 0.0d.   1 to: bodies size do: [:i|             e := e + (bodies at: i) kineticEnergy.      i+1 to: bodies size do: [:j|          e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].   ].   ^e</body></methods><methods><class-id>Shootout.NBodySystem</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize">initialize   bodies := OrderedCollection new      add: Body sun; add: Body jupiter; add: Body saturn;      add: Body uranus; add: Body neptune; yourself.   bodies first offsetMomentum:      (bodies inject: (Array with: 0.0d with: 0.0d with: 0.0d)         into: [:m :each | each addMomentumTo: m])</body></methods><methods><class-id>Shootout.Tests class</class-id> <category>auxilliaries</category><body package="ComputerLanguageShootout" selector="nsieve:using:">nsieve: n using: arrayClass 	| count isPrime |	count := 0.	isPrime := arrayClass new: n withAll: true.	2 to: n do:		[:i | 		(isPrime at: i) ifTrue: 			[i + i to: n by: i do:				[:k | isPrime at: k put: false].			count := count + 1]].	^count</body><body package="ComputerLanguageShootout" selector="readFasta:from:">readFasta: anId from: input 	| idString newline buffer char |	idString := '&gt;' , anId.	newline := Character cr.	"find start of particular fasta sequence"		[(char := input peek) == nil	 or: [char = $&gt; 			ifTrue: 				[((input upTo: newline) indexOfSubCollection: idString startingAt: 1) = 1]			ifFalse: 				[input skipThrough: newline.				 false]]] 		whileFalse.	"line-by-line read - it would be a lot faster to block read"	buffer := ReadWriteStream on: (String new: 1028).	[(char := input peek) == nil or: [char = $&gt;]] whileFalse: 		[char = $; 			ifTrue: [input upTo: newline]			ifFalse: [buffer nextPutAll: (input upTo: newline)]].	^buffer contents</body><body package="ComputerLanguageShootout" selector="reverseComplement2From:named:to:">reverseComplement2From: input named: sequenceName to: output 	| complement idString cr description char |	complement := String new: 128.	'ACGTUMRWSYKVHDBN'		with: 'TGCAAKYWSRMBDHVN'		do: [:a :b|			complement at: a asInteger put: b.			complement at: a asLowercase asInteger put: b asLowercase].	idString := '&gt;' , sequenceName.	cr := Character cr.	"find start of particular fasta sequence"	[char := input peek.	 char == nil ifTrue: [^self].	char = $&gt; 		ifTrue: 			[((description := input upTo: cr) indexOfSubCollection: idString startingAt: 1) = 1]		ifFalse: 			[input skipThrough: cr.			false]] 		whileFalse.	output nextPutAll: description; cr.	[(char := input peek) = $&gt; or: [char == nil]] whileFalse:		[char = $; 			ifTrue: [input skipUpTo: cr]			ifFalse: 				[[(char := input next) = cr] whileFalse:					[output nextPut: (complement at: char asInteger)].				 output cr]]</body><body package="ComputerLanguageShootout" selector="reverseComplementFrom:named:to:">reverseComplementFrom: input named: sequenceName to: output 	| complement idString cr description char |	complement := String new: 128.	'ACGTUMRWSYKVHDBN'		with: 'TGCAAKYWSRMBDHVN'		do: [:a :b|			complement at: a asInteger put: b.			complement at: a asLowercase asInteger put: b asLowercase].	idString := '&gt;' , sequenceName.	cr := Character cr.	"find start of particular fasta sequence"	[char := input peek.	 char == nil ifTrue: [^self].	char = $&gt; 		ifTrue: 			[((description := input upTo: cr) indexOfSubCollection: idString startingAt: 1) = 1]		ifFalse: 			[input skipThrough: cr.			false]] 		whileFalse.	output nextPutAll: description; cr.	[(char := input peek) = $&gt; or: [char == nil]] whileFalse:		[char = $; 			ifTrue: [input skipUpTo: cr]			ifFalse: 				[[(char := input next) = cr] whileFalse:					[output nextPut: (complement at: char asInteger)].				 output cr]]</body><body package="ComputerLanguageShootout" selector="writeFasta:from:to:lineLength:">writeFasta: aString from: inStream to: outStream lineLength: lineLength	| i |	outStream nextPut: $&gt;; nextPutAll: aString; cr.	i := 0.	[inStream atEnd] whileFalse:		[i == lineLength ifTrue: [outStream cr. i := 0].		outStream nextPut: inStream next.		i := i + 1].	outStream cr</body><body package="ComputerLanguageShootout" selector="writeReverseComplementFasta:sequence:to:">writeReverseComplementFasta: aString sequence: aSequence to: output 	| lineLength n iub |	lineLength := 60.	n := aSequence size.	iub := String new: 128.	'ACGTUMRWSYKVHDBN'		with: 'TGCAAKYWSRMBDHVN'		do: [:a :b|			iub at: a asInteger put: b.			iub at: a asLowercase asInteger put: b asLowercase].	output		nextPutAll: aString;		cr.	[n &gt; 0] whileTrue: 			[1 to: (n &lt; lineLength ifTrue: [n] ifFalse: [lineLength])				do: [:i | output nextPut: (iub at: (aSequence at: n - i + 1) asInteger)].			output cr.			n := n - lineLength]</body></methods><methods><class-id>Shootout.Tests class</class-id> <category>benchmarks</category><body package="ComputerLanguageShootout" selector="binarytrees:to:">binarytrees: n to: output	| minDepth maxDepth stretchDepth check longLivedTree iterations | 	minDepth := 4.	maxDepth := minDepth + 2 max: n.	stretchDepth := maxDepth + 1.	check := (TreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.	output		nextPutAll: 'stretch tree of depth '; print: stretchDepth; tab;		nextPutAll: ' check: '; print: check; cr.	longLivedTree := TreeNode bottomUpTree: 0 depth: maxDepth.	minDepth to: maxDepth by: 2 do: [:depth|		iterations := 1 bitShift: maxDepth - depth + minDepth.		check := 0.		1 to: iterations do: [:i|			check := check + (TreeNode bottomUpTree: i depth: depth) itemCheck.			check := check + (TreeNode bottomUpTree: -1*i depth: depth) itemCheck].		output			print:  (2*iterations); tab; 			nextPutAll: ' trees of depth '; print: depth; tab;			nextPutAll: ' check: '; print: check; cr].	output		nextPutAll: 'long lived tree of depth '; print: maxDepth; tab;		nextPutAll: ' check: '; print: longLivedTree itemCheck; cr</body><body package="ComputerLanguageShootout" selector="chameneos:">chameneos: n   | c1 c2 c3 c4 mp |   c1 := Chameleon color: #blue.   c2 := Chameleon color: #red.   c3 := Chameleon color: #yellow.   c4 := Chameleon color: #blue.   mp := MeetingPlace forMeetings: n.   c1 fork: mp.   c2 fork: mp.   c3 fork: mp.   c4 fork: mp.   c1 wait.   c2 wait.   c3 wait.   c4 wait.   ^c1 meetings + c2 meetings + c3 meetings + c4 meetings</body><body package="ComputerLanguageShootout" selector="fannkuch:to:">fannkuch: n to: output   ^(PermGenerator new: n) maxPfannkuchenTo: output</body><body package="ComputerLanguageShootout" selector="fasta2:to:">fasta2: n to: out	| r lineLength |	lineLength := 60.	self		writeFasta: 'ONE Homo sapiens alu'		from:			( RepeatStream				to: n*2				on:	'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',					'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',					'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',					'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA', 					'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',					'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC', 					'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' )		to: out		lineLength: lineLength.	r := RandomNumber to: 1. "Shared random sequence"	self		writeFasta: 'TWO IUB ambiguity codes'		from:			(( RandomStream2				to: n*3				on: #(	#($a 0.27d)						#($c 0.12d)						#($g 0.12d)						#($t 0.27d)						#($B 0.02d)						#($D 0.02d)						#($H 0.02d)						#($K 0.02d)						#($M 0.02d)						#($N 0.02d)						#($R 0.02d)						#($S 0.02d)						#($V 0.02d)						#($W 0.02d)						#($Y 0.02d)))			random: r;			yourself)		to: out		lineLength: lineLength.	self		writeFasta: 'THREE Homo sapiens frequency'		from:			(( RandomStream2				to: n*5				on: #(	#($a 0.3029549426680d)						#($c 0.1979883004921d)						#($g 0.1975473066391d)						#($t 0.3015094502008d)))				random: r;				yourself)		to: out		lineLength: lineLength.   out flush.   ^''</body><body package="ComputerLanguageShootout" selector="knucleotide2From:to:">knucleotide2From: input to: output   | sequence writeFrequencies writeCount |   sequence := (self readFasta: 'THREE' from: input) asUppercase.   writeFrequencies := [:k | | frequencies count |      frequencies := SortedCollection sortBlock: [:a :b|         (a value = b value) ifTrue: [b key &lt; a key] ifFalse: [b value &lt; a value]].      count := 0.0.      (sequence substringFrequencies2: k)         associationsDo: [:each| frequencies add: each. count := count + each value].      frequencies do: [:each | | percentage |         percentage := (each value / count) * 100.0.         output nextPutAll: each key; space; nextPutAll: (percentage asStringWith: 3); cr]].   writeCount := [:nucleotideFragment | | frequencies count |      frequencies := sequence substringFrequencies2: nucleotideFragment size.      count := frequencies at: nucleotideFragment asSymbol ifAbsent: [0].      output print: count; tab; nextPutAll: nucleotideFragment; cr].   writeFrequencies value: 1. output cr.   writeFrequencies value: 2. output cr.   writeCount value: 'GGT'.   writeCount value: 'GGTA'.   writeCount value: 'GGTATT'.   writeCount value: 'GGTATTTTAATT'.   writeCount value: 'GGTATTTTAATTTATAGT'</body><body package="ComputerLanguageShootout" selector="knucleotide3From:to:">knucleotide3From: input to: output	| sequence writeFrequencies writeCount |	sequence := (self readFasta: 'THREE' from: input) asUppercase.	writeFrequencies :=		[:k | | frequencies count |		frequencies := SortedCollection sortBlock: [:a :b|			(a value = b value) ifTrue: [b key &lt; a key] ifFalse: [b value &lt; a value]].		count := 0.0.		(sequence substringFrequencies: k using: (DNASequenceDictionary new: 1024))			associationsDo: [:each| frequencies add: each. count := count + each value].		frequencies do: [:each | | percentage |			percentage := (each value / count) * 100.0.			output nextPutAll: each key; space; nextPutAll: (percentage asStringWith: 3); cr]].	writeCount := [:nucleotideFragment | | frequencies count |		frequencies := sequence substringFrequencies: nucleotideFragment size using: (DNASequenceDictionary new: 1024).		count := frequencies at: nucleotideFragment ifAbsent: [0].		output print: count; tab; nextPutAll: nucleotideFragment; cr].	writeFrequencies value: 1. output cr.	writeFrequencies value: 2. output cr.	writeCount value: 'GGT'.	writeCount value: 'GGTA'.	writeCount value: 'GGTATT'.	writeCount value: 'GGTATTTTAATT'.	writeCount value: 'GGTATTTTAATTTATAGT'.	^''</body><body package="ComputerLanguageShootout" selector="knucleotideFrom:to:">knucleotideFrom: input to: output   | sequence writeFrequencies writeCount |   sequence := (self readFasta: 'THREE' from: input) asUppercase.   writeFrequencies := [:k | | frequencies count |      frequencies := SortedCollection sortBlock: [:a :b|         (a value = b value) ifTrue: [b key &lt; a key] ifFalse: [b value &lt; a value]].      count := 0.0.      (sequence substringFrequencies: k)         associationsDo: [:each| frequencies add: each. count := count + each value].      frequencies do: [:each | | percentage |         percentage := (each value / count) * 100.0.         output nextPutAll: each key; space; nextPutAll: (percentage asStringWith: 3); cr]].   writeCount :=	[:nucleotideFragment | | frequencies count |      frequencies := sequence substringFrequencies: nucleotideFragment size.      count := frequencies at: nucleotideFragment ifAbsent: [0].      output print: count; tab; nextPutAll: nucleotideFragment; cr].   writeFrequencies value: 1. output cr.   writeFrequencies value: 2. output cr.   writeCount value: 'GGT'.   writeCount value: 'GGTA'.   writeCount value: 'GGTATT'.   writeCount value: 'GGTATTTTAATT'.   writeCount value: 'GGTATTTTAATTTATAGT'</body><body package="ComputerLanguageShootout" selector="mandelbrot2:to:">mandelbrot2: extent to: output 	| limit2 isOverLimit bits bitnum |	limit2 := 4.0d.	bits := bitnum := 0.	0 to: extent - 1 do:		[:y | 		0 to: extent - 1 do:			[:x | | zr zi cr ci i |			zr := zi := 0.0d.			cr := 2.0d * x / extent - 1.5d.			ci := 2.0d * y / extent - 1.0d.			i := 0.						[| tr ti |			tr := zr * zr - (zi * zi) + cr.			ti := 2.0d * zr * zi + ci.			zr := tr.			zi := ti.			(isOverLimit := zr * zr + (zi * zi) &gt; limit2) or: [(i := i + 1) &gt;= 50]]				whileFalse.			bits := bits + bits.			isOverLimit ifFalse: [bits := bits + 1].			bitnum := bitnum + 1.			x = (extent - 1) ifTrue:				[bits := bits bitShift: 8 - bitnum.				bitnum := 8].			bitnum = 8 ifTrue:				[output nextPut: bits.				bits := 0.				bitnum := 0]]]</body><body package="ComputerLanguageShootout" selector="mandelbrot:to:">mandelbrot: n to: output 	| width height limit2 isOverLimit m bits bitnum |	height := width := n asDouble.	limit2 := 4.0d.	m := 50.	bits := bitnum := 0.	0.0d to: height - 1.0d do:		[:y | 		0.0d to: width - 1.0d do:			[:x | | zr zi cr ci i |			zr := zi := 0.0d.			cr := 2.0d * x / width - 1.5d.			ci := 2.0d * y / height - 1.0d.			i := 0.						[| tr ti |			tr := zr * zr - (zi * zi) + cr.			ti := 2.0d * zr * zi + ci.			zr := tr.			zi := ti.			isOverLimit := zr * zr + (zi * zi) &gt; limit2.			isOverLimit not and: [(i := i + 1) &lt; m]]				whileTrue.			bits := bits bitShift: 1.			isOverLimit ifFalse: [bits := bits + 1].			bitnum := bitnum + 1.			x = (width - 1) ifTrue:				[bits := bits bitShift: 8 - bitnum.				bitnum := 8].			bitnum = 8 ifTrue:				[output nextPut: bits.				bits := 0.				bitnum := 0]]]</body><body package="ComputerLanguageShootout" selector="message:">message: n	| tail head sum |	head := tail := Consumer new.	500 timesRepeat: [head := ProducerConsumer fork: head].	sum := 0.	n timesRepeat:		[head msg: 0.		sum := sum + tail msg].	^sum</body><body package="ComputerLanguageShootout" selector="partialsums:to:">partialsums: n to: output	| a1 a2 a3 a4 a5 a6 a7 a8 a9 twothirds alt |	a1 := a2 := a3 := a4 := a5 := a6 := a7 := a8 := a9 := 0.0d.	twothirds := 2.0d/3.0d.	alt := -1.0d.	1.0d to: n do: [:k| | k2 k3 sk ck |		k2 := k*k.		k3 := k2*k.		sk := k sin.		ck := k cos.		alt := -1.0d * alt.		a1 := a1 + (twothirds raisedTo: k - 1.0d).		a2 := a2 + (k raisedTo: -0.5d).		a3 := a3 + (1.0d/(k*(k+1.0d))).		a4 := a4 + (1.0d/(k3*sk*sk)).		a5 := a5 + (1.0d/(k3*ck*ck)).		a6 := a6 + (1.0d/k).		a7 := a7 + (1.0d/k2).		a8 := a8 + (alt/k).		a9 := a9 + (alt/(2.0d*k - 1.0d))].	a1 printOn: output withName: '(2/3)^k'.	a2 printOn: output withName: 'k^-0.5'.	a3 printOn: output withName: '1/k(k+1)'.	a4 printOn: output withName: 'Flint Hills'.	a5 printOn: output withName: 'Cookson Hills'.	a6 printOn: output withName: 'Harmonic'.	a7 printOn: output withName: 'Riemann Zeta'.	a8 printOn: output withName: 'Alternating Harmonic'.	a9 printOn: output withName: 'Gregory'.	^''</body><body package="ComputerLanguageShootout" selector="pidigitsTo:width:to:">pidigitsTo: v width: width to: output 	| n i pidigits |	n := v.	i := 0.	pidigits := PiDigitSpigot new.	[n &gt; 0] whileTrue:		[n &lt; width			ifTrue:				[n timesRepeat: [output nextPut: (Character digitValue: pidigits next)].				n to: width do: [:each | output space].				i := i + n]			ifFalse:				[width timesRepeat: [output nextPut: (Character digitValue: pidigits next)].				i := i + width].		output			tab;			nextPut: $:;			print: i;			cr.		n := n - width]	"self pidigitsTo: 2500 width: 10 to: OS.Stdout"	"Transcript clear. self pidigitsTo: 2500 width: 10 to: Transcript"	"PiDigitSpigot new next: 2500"	"TimeProfiler profile: [PiDigitSpigot new next: 2500]"</body><body package="ComputerLanguageShootout" selector="primeBenchmarkFor:to:using:">primeBenchmarkFor: v to: output using: arrayClass	v to: v - 2 by: -1 do:		[:n| | m |		m := (2 raisedTo: n) * 10000.		output			nextPutAll: 'Primes up to '; nextPutAll: (m asPaddedString: 8);			nextPutAll: ((self nsieve: m using: arrayClass) asPaddedString: 9); cr]	"Transcript cr.	 self primeBenchmarkFor: 11 to: Transcript using: Array."	"Transcript cr.	 self primeBenchmarkFor: 11 to: Transcript using: BitArray."</body><body package="ComputerLanguageShootout" selector="recursive:to:">recursive: nArg to: output 	| n |	n := nArg.	output		nextPutAll: 'Ack(3,'; print: n; nextPutAll: '): '; print: (3 ack: n); cr;		nextPutAll: 'Fib(' , (27.0d + n asStringWith: 1) , '): ', ((27.0d + n) fib asStringWith: 1); cr.	n := n - 1.	output		nextPutAll: 'Tak('; print: 3 * n; nextPut: $,; print: 2 * n; nextPut: $,; print: n; nextPutAll: '): '; print: (3 * n tak: 2 * n z: n); cr;		nextPutAll: 'Fib(3): '; print: 3 fib; cr;		nextPutAll: 'Tak(3.0,2.0,1.0): ', ((3.0d tak: 2.0d z: 1.0d) asStringWith: 1); cr	"self recursive: 11 to: Transcript"</body><body package="ComputerLanguageShootout" selector="regexDNAFrom:to:">regexDNAFrom: input to: output 	| s size1 size2 translation |	s := input contents.	size1 := s size.	"* remove FASTA sequence descriptions and new-lines *"	s := s copyWithRegex: '&gt;[^\r]*\r|\r' matchesReplacedWith: ''.	size2 := s size.	"* regex match *"	#(	'agggtaaa|tttaccct'		'[cgt]gggtaaa|tttaccc[acg]'		'a[act]ggtaaa|tttacc[agt]t'		'ag[act]gtaaa|tttac[agt]ct'		'agg[act]taaa|ttta[agt]cct'		'aggg[acg]aaa|ttt[cgt]ccct'		'agggt[cgt]aa|tt[acg]accct'		'agggta[cgt]a|t[acg]taccct'		'agggtaa[cgt]|[acg]ttaccct') 		do: [:each | 			output nextPutAll: each; space; print: (s occurrencesOfRegex: each); cr].	"* regex substitution *"	"#(	#('B' '(c|g|t)')		#('D' '(a|g|t)')		#('H' '(a|c|t)')		#('K' '(g|t)')		#('M' '(a|c)')		#('N' '(a|c|g|t)')		#('R' '(a|g)')		#('S' '(c|g)')		#('V' '(a|c|g)')		#('W' '(a|t)')		#('Y' '(c|t)')) 		do: [:each | s := s copyReplacingAllRegex: each first with: each last]."	translation := Dictionary new.	#(	#('B' '(c|g|t)')		#('D' '(a|g|t)')		#('H' '(a|c|t)')		#('K' '(g|t)')		#('M' '(a|c)')		#('N' '(a|c|g|t)')		#('R' '(a|g)')		#('S' '(c|g)')		#('V' '(a|c|g)')		#('W' '(a|t)')		#('Y' '(c|t)')) 		do: [:each | translation at: each first put: each last].	s := s			copyWithRegex: '[', (translation keys asArray fold: [:a :b| a, b]), ']'			matchesTranslatedUsing: [:l| translation at: l].	output cr; print: size1; cr; print: size2; cr; print: s size; cr</body><body package="ComputerLanguageShootout" selector="spectralnorm:">spectralnorm: n 	| u v vBv vv |	u := Array new: n withAll: 1.0d.	v := Array new: n withAll: 0.0d.	10 timesRepeat: 		[v := u multiplyAtAv.		 u := v multiplyAtAv].	vBv := 0.0d.	vv := 0.0d.	1 to: n do: 		[:i | 		 vBv := vBv + ((u at: i) * (v at: i)).		 vv := vv + ((v at: i) * (v at: i))].	^((vBv / vv) sqrt asStringWith: 9) withNl</body><body package="ComputerLanguageShootout" selector="sumStream3:">sumStream3: input 	| sum |	sum := 0.	[input atEnd] whileFalse:		[sum := sum + (input upTo: Character cr) asNumber].	^sum printString withNl</body><body package="ComputerLanguageShootout" selector="sumStream:">sumStream: input 	| sum |	sum := 0.	[input atEnd] whileFalse:		[sum := sum + (Integer readFrom: input radix: 10).		 input next].	^sum printString withNl</body></methods><methods><class-id>Shootout.Tests class</class-id> <category>benchmark scripts</category><body package="ComputerLanguageShootout" selector="binarytrees2">binarytrees2	self binarytrees: CEnvironment argv first asNumber to: Stdout.	^''	"self binarytrees: 16 to: Transcript"	"Time microsecondsToRun: [self binarytrees: 16 to: Transcript]"	"TimeProfiler profile: [self binarytrees: 16 to: Transcript]"</body><body package="ComputerLanguageShootout" selector="chameneos2">chameneos2	^(self chameneos: CEnvironment argv first asNumber) printString withNl	"self chameneos: 5000000"	"Time microsecondsToRun: [self chameneos: 5000000]"	"TimeProfiler profile: [self chameneos: 5000000]"	"OEProfiler profile: [self chameneos: 5000000]"</body><body package="ComputerLanguageShootout" selector="fannkuch2">fannkuch2	| n |	n := CEnvironment argv first asNumber.	^'Pfannkuchen(', n printString, ') = ', (self fannkuch: n to: Stdout) printString withNl	"self fannkuch: 10 to: Transcript"</body><body package="ComputerLanguageShootout" selector="fasta">fasta   | n stdout r |   n := CEnvironment argv first asNumber.   stdout := ExternalWriteStream on:       (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).   stdout writeFasta: 'ONE Homo sapiens alu' sequence:   ( RepeatStream to: n*2 on:      'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',      'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',      'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',      'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA',      'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',      'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC',      'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' ).   r := RandomNumber to: 1. "*Shared random sequence*"   stdout writeFasta: 'TWO IUB ambiguity codes' sequence:   (( RandomStream to: n*3 on: (      OrderedCollection new         add: (Association key: $a value: 0.27d);         add: (Association key: $c value: 0.12d);         add: (Association key: $g value: 0.12d);         add: (Association key: $t value: 0.27d);         add: (Association key: $B value: 0.02d);         add: (Association key: $D value: 0.02d);         add: (Association key: $H value: 0.02d);         add: (Association key: $K value: 0.02d);         add: (Association key: $M value: 0.02d);         add: (Association key: $N value: 0.02d);         add: (Association key: $R value: 0.02d);         add: (Association key: $S value: 0.02d);         add: (Association key: $V value: 0.02d);         add: (Association key: $W value: 0.02d);         add: (Association key: $Y value: 0.02d);         yourself )) random: r).   stdout writeFasta: 'THREE Homo sapiens frequency' sequence:   (( RandomStream to: n*5 on: (      OrderedCollection new         add: (Association key: $a value: 0.3029549426680d);         add: (Association key: $c value: 0.1979883004921d);         add: (Association key: $g value: 0.1975473066391d);         add: (Association key: $t value: 0.3015094502008d);         yourself )) random: r).   stdout flush.   ^''</body><body package="ComputerLanguageShootout" selector="fasta2">fasta2	"from vw7.5:"	self fasta2: CEnvironment argv first asNumber to: Stdout.       ^''	"self fasta: 25000 to: Transcript"	"self fasta: 2500000 to: Stdout"	"self fasta: 2500000 to: Stdout"	"| s |	s := 'regex-dna-full-input.txt' asFilename writeStream.	[self fasta: 500000 to: s] ensure: [s close]"</body><body package="ComputerLanguageShootout" selector="hello">hello   ^'hello world' withNl</body><body package="ComputerLanguageShootout" selector="knucleotide">knucleotide	self knucleotideFrom: Stdin to: Stdout.	^''	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 25416745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 2500000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotideFrom: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 1016745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 100000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotideFrom: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 10166745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 1000000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[TimeProfiler profile: [self knucleotideFrom: input to: Transcript]] ensure: [input close]"</body><body package="ComputerLanguageShootout" selector="knucleotide2">knucleotide2	self knucleotide2From: Stdin to: Stdout.	^''	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 25416745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 2500000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotide2From: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 1016745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 100000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotide2From: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 10166745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 1000000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[TimeProfiler profile: [self knucleotide2From: input to: Transcript]] ensure: [input close]"</body><body package="ComputerLanguageShootout" selector="knucleotide3">knucleotide3	self knucleotide3From: Stdin to: Stdout.	^''	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 25416745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 2500000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotide3From: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 1016745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 100000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[self knucleotide3From: input to: Transcript] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 10166745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 1000000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[TimeProfiler profile: [self knucleotide3From: input to: Transcript]] ensure: [input close]"	"| fn input |	fn := 'fasta.dat' asFilename.	(fn exists and: [fn fileSize = 10166745]) ifFalse:		[| output |		output := fn writeStream.		[Cursor write showWhile: [self fasta: 1000000 to: output. output close]]			ifCurtailed: [output close. fn delete]].	input := fn readStream.	[OEProfiler profile: [self knucleotide3From: input to: Transcript]] ensure: [input close]"</body><body package="ComputerLanguageShootout" selector="mandelbrot2">mandelbrot2	| n |	n := CEnvironment argv first asNumber.	Stdout nextPutAll: 'P4'; cr; print: n; space; print: n; cr.	Stdout binary.	self mandelbrot2: n to: Stdout.	Stdout flush.	^''	"| n |	n := 3000.	Stdout nextPutAll: 'P4'; cr; print: n; space; print: n; cr.	Stdout binary.	self mandelbrot2: n to: Stdout.	Stdout flush"	"| span out |	span := 512.	out := WriteStream on: (ByteArray new: span * span).	self mandelbrot2: span to: out.	ScheduledWindow new		component: ((BorderDecorator on: (Image 											extent: span @ span											depth: 1											palette: CoveragePalette monoMaskPalette											usingBits: out contents))			useHorizontalScrollBar);		open"	"| span o1 o2 |	span := 128.	o1 := WriteStream on: (ByteArray new: span * span).	self mandelbrot: span to: o1.	o2 := WriteStream on: (ByteArray new: span * span).	self mandelbrot2: span to: o2.	o1 contents = o2 contents"	"| span out b1 b2 |	ObjectMemory garbageCollect.	span := 512.	out := WriteStream on: (ByteArray new: span * span).	b1 := [Time microsecondsToRun: [out reset. self mandelbrot: span to: out]].	b2 := [Time microsecondsToRun: [out reset. self mandelbrot2: span to: out]].	span := span / 8.	ObjectMemory garbageCollect.	b1 value. b2 value.	span := 512.	b1 value -&gt; b2 value"</body><body package="ComputerLanguageShootout" selector="message2">message2	^(self message: CEnvironment argv first asNumber) printString withNl	"self message: 15000"</body><body package="ComputerLanguageShootout" selector="nbody">nbody   | n bodies |   n := CEnvironment argv first asNumber.   bodies := NBodySystem new initialize.   Stdout nextPutAll: (bodies energy asStringWith: 9); cr.   n timesRepeat: [bodies after: 0.01d].   Stdout nextPutAll: (bodies energy asStringWith: 9); cr.   ^''	"| bodies |	bodies := NBodySystem new initialize.	Transcript print: bodies energy; cr.	20000000 timesRepeat: [bodies after: 0.01d].	Transcript print: bodies energy; cr"</body><body package="ComputerLanguageShootout" selector="nsieve2">nsieve2	| n |	n := CEnvironment argv first asNumber.	(n &lt; 2) ifTrue: [n := 2].	self primeBenchmarkFor: n to: Stdout using: Array.	^''</body><body package="ComputerLanguageShootout" selector="nsievebits2">nsievebits2	| n |	n := CEnvironment argv first asNumber.	(n &lt; 2) ifTrue: [n := 2].	self primeBenchmarkFor: n to: Stdout using: BitArray.	^''</body><body package="ComputerLanguageShootout" selector="partialsums2">partialsums2	self partialsums: CEnvironment argv first asNumber asDouble to: Stdout.	^''	"self partialsums: 2500000 to: Transcript"	"Time microsecondsToRun: [self partialsums: 2500000 to: Transcript]"	"TimeProfiler profile: [self partialsums: 2500000 to: Transcript]"</body><body package="ComputerLanguageShootout" selector="pidigits2">pidigits2	self pidigitsTo: CEnvironment argv first asNumber width: 10 to: Stdout.	^''</body><body package="ComputerLanguageShootout" selector="recursive2">recursive2	self recursive: CEnvironment argv first asNumber to: Stdout.	^''</body><body package="ComputerLanguageShootout" selector="regexdna">regexdna	self regexDNAFrom: Stdin to: Stdout.	^''	"TimeProfiler profile:		[| input |		 input := 'regex-dna-full-input.txt' asFilename readStream.		 [Shootout.Tests regexDNAFrom: input to: Transcript] ensure: [input close]]"</body><body package="ComputerLanguageShootout" selector="revcomp">revcomp   | stdin stdout fasta |   stdin := ExternalReadStream on:      (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   stdout := ExternalWriteStream on:      (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 1)).   fasta := stdin readFasta: 'ONE'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   fasta := stdin readFasta: 'TWO'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   fasta := stdin readFasta: 'THREE'.   stdout writeReverseComplementFasta: fasta key sequence: fasta value.   stdout flush.   ^''</body><body package="ComputerLanguageShootout" selector="revcomp2">revcomp2	#('ONE' 'TWO' 'THREE') do:		[:sequenceName | 		self reverseComplement2From: Stdin named: sequenceName to: Stdout].	Stdout flush.	^''</body><body package="ComputerLanguageShootout" selector="spectralnorm2">spectralnorm2	^self spectralnorm: CEnvironment argv first asNumber	"sef spectralnorm: 2500"</body><body package="ComputerLanguageShootout" selector="sumcol">sumcol   | stdin sum |   stdin := ExternalReadStream on:      (ExternalConnection ioAccessor: (UnixDiskFileAccessor new handle: 0)).   sum := 0.   [stdin atEnd] whileFalse: [      sum := sum + (stdin upTo: Character cr) asNumber].   ^sum printString withNl</body><body package="ComputerLanguageShootout" selector="sumcol2">sumcol2	^self sumStream: Stdin	"| s |	 s := 'sumcol-input.txt' asFilename readStream.	 [self sumStream: s] ensure: [s close]"	"TimeProfiler profile:		[| s |		 s := 'sumcol-input.txt' asFilename readStream.		 [10000 timesRepeat:			[s position: 0.			 self sumStream: s]] ensure: [s close]]"</body><body package="ComputerLanguageShootout" selector="sumcol3">sumcol3	^self sumStream3: Stdin</body></methods><methods><class-id>Shootout.Consumer</class-id> <category>process</category><body package="ComputerLanguageShootout" selector="msg">msg    semaphore wait.    ^msg</body><body package="ComputerLanguageShootout" selector="msg:">msg: data    msg := data.    semaphore signal</body><body package="ComputerLanguageShootout" selector="semaphore:">semaphore: aSemaphore    semaphore := aSemaphore</body></methods><methods><class-id>Shootout.Consumer class</class-id> <category>process</category><body package="ComputerLanguageShootout" selector="new">new    | var |    var := self basicNew.    var semaphore: Semaphore new.    ^var</body></methods><methods><class-id>Shootout.ProducerConsumer</class-id> <category>process</category><body package="ComputerLanguageShootout" selector="consumer:">consumer: aProcess    consumer := aProcess</body><body package="ComputerLanguageShootout" selector="fork">fork    [ self run ] fork</body><body package="ComputerLanguageShootout" selector="run">run    [ consumer msg: self msg + 1 ] repeat</body></methods><methods><class-id>Shootout.ProducerConsumer class</class-id> <category>process</category><body package="ComputerLanguageShootout" selector="fork:">fork: consumer    | proc |    proc := self new.    proc consumer: consumer.    proc fork.    ^proc</body></methods><methods><class-id>Core.DNASequenceDictionary</class-id> <category>private</category><body package="ComputerLanguageShootout" selector="findKeyOrNil:">findKeyOrNil: key  	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the index of the first unused slot."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key dnaSequenceHash boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Shootout.Transformation</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize">initialize   q := 0.   r := 0.   s := 0.   t := 0.   k := 0.</body></methods><methods><class-id>Shootout.Transformation</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="*">* aTransformation   ^self species       q: q * aTransformation q      r: q * aTransformation r + (r * aTransformation t)      s: s * aTransformation q + (t * aTransformation s)      t: s * aTransformation r + (t * aTransformation t)</body><body package="ComputerLanguageShootout" selector="extract:">extract: anInteger   ^(q * anInteger + r) // (s * anInteger + t)</body><body package="ComputerLanguageShootout" selector="next">next   k := k +1.   q := k.   r := 4 * k + 2.   s := 0.   t := 2 * k + 1.</body><body package="ComputerLanguageShootout" selector="q">q   ^q</body><body package="ComputerLanguageShootout" selector="q:r:s:t:">q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   q := anInteger1.   r := anInteger2.   s := anInteger3.   t := anInteger4.   k := 0.</body><body package="ComputerLanguageShootout" selector="r">r   ^r</body><body package="ComputerLanguageShootout" selector="s">s   ^s</body><body package="ComputerLanguageShootout" selector="t">t   ^t</body></methods><methods><class-id>Shootout.Transformation class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="new">new   ^super new initialize</body><body package="ComputerLanguageShootout" selector="q:r:s:t:">q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   ^(super new) q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4</body><body package="ComputerLanguageShootout" selector="unity">unity   ^self q: 1 r: 0 s: 0 t: 1</body></methods><methods><class-id>Shootout.Body</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="mass">mass   ^mass</body><body package="ComputerLanguageShootout" selector="x">x   ^x</body><body package="ComputerLanguageShootout" selector="x:y:z:vx:vy:vz:mass:">x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7   x := d1.   y := d2.    z := d3.    vx := d4.   vy := d5.   vz := d6.   mass := d7</body><body package="ComputerLanguageShootout" selector="y">y   ^y</body><body package="ComputerLanguageShootout" selector="z">z   ^z</body></methods><methods><class-id>Shootout.Body</class-id> <category>nbody</category><body package="ComputerLanguageShootout" selector="addMomentumTo:">addMomentumTo: anArray   anArray at: 1 put: (anArray at: 1) + (vx * mass).   anArray at: 2 put: (anArray at: 2) + (vy * mass).   anArray at: 3 put: (anArray at: 3) + (vz * mass).   ^anArray</body><body package="ComputerLanguageShootout" selector="and:velocityAfter:">and: aBody velocityAfter: dt	        | dx dy dz distance mag |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.      distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   mag := dt / (distance * distance * distance).   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.      aBody increaseVelocity: dx y: dy z: dz m: mass * mag</body><body package="ComputerLanguageShootout" selector="decreaseVelocity:y:z:m:">decreaseVelocity: dx y: dy z: dz m: m   vx := vx - (dx * m).   vy := vy - (dy * m).   vz := vz - (dz * m)</body><body package="ComputerLanguageShootout" selector="increaseVelocity:y:z:m:">increaseVelocity: dx y: dy z: dz m: m   vx := vx + (dx * m).   vy := vy + (dy * m).   vz := vz + (dz * m)</body><body package="ComputerLanguageShootout" selector="kineticEnergy">kineticEnergy   ^0.5d * mass * ((vx * vx) + (vy * vy) + (vz * vz))</body><body package="ComputerLanguageShootout" selector="offsetMomentum:">offsetMomentum: anArray    | m |   m := self class solarMass.   vx := (anArray at: 1) negated / m.   vy := (anArray at: 2) negated / m.   vz := (anArray at: 3) negated / m</body><body package="ComputerLanguageShootout" selector="positionAfter:">positionAfter: dt   x := x + (dt * vx).   y := y + (dt * vy).   z := z + (dt * vz)</body><body package="ComputerLanguageShootout" selector="potentialEnergy:">potentialEnergy: aBody   | dx dy dz distance |   dx := x - aBody x.   dy := y - aBody y.   dz := z - aBody z.   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.   ^mass * aBody mass / distance</body></methods><methods><class-id>Shootout.Body class</class-id> <category>constants</category><body package="ComputerLanguageShootout" selector="daysPerYear">daysPerYear   ^365.24d</body><body package="ComputerLanguageShootout" selector="jupiter">jupiter   ^self new      x: 4.84143144246472090d0      y: -1.16032004402742839d0      z: -1.03622044471123109d-1      vx: 1.66007664274403694d-3 * self daysPerYear      vy: 7.69901118419740425d-3 * self daysPerYear      vz: -6.90460016972063023d-5 * self daysPerYear      mass: 9.54791938424326609d-4 * self solarMass</body><body package="ComputerLanguageShootout" selector="neptune">neptune   ^self new      x: 1.53796971148509165d1      y: -2.59193146099879641d1      z: 1.79258772950371181d-1      vx: 2.68067772490389322d-3 * self daysPerYear      vy: 1.62824170038242295d-3 * self daysPerYear      vz: -9.51592254519715870d-5 * self daysPerYear      mass: 5.15138902046611451d-5 * self solarMass</body><body package="ComputerLanguageShootout" selector="pi">pi   ^3.141592653589793d</body><body package="ComputerLanguageShootout" selector="saturn">saturn   ^self new      x: 8.34336671824457987d0      y: 4.12479856412430479d0      z: -4.03523417114321381d-1      vx: -2.76742510726862411d-3 * self daysPerYear      vy: 4.99852801234917238d-3 * self daysPerYear      vz: 2.30417297573763929d-5 * self daysPerYear      mass: 2.85885980666130812d-4 * self solarMass</body><body package="ComputerLanguageShootout" selector="solarMass">solarMass   ^4.0d * self pi * self pi</body><body package="ComputerLanguageShootout" selector="sun">sun   ^self new      x: 0.0d0      y: 0.0d0      z: 0.0d0      vx: 0.0d0      vy: 0.0d0      vz: 0.0d0      mass: self solarMass</body><body package="ComputerLanguageShootout" selector="uranus">uranus   ^self new      x: 1.28943695621391310d1      y: -1.51111514016986312d1      z: -2.23307578892655734d-1      vx: 2.96460137564761618d-3 * self daysPerYear      vy: 2.37847173959480950d-3 * self daysPerYear      vz: -2.96589568540237556d-5 * self daysPerYear      mass: 4.36624404335156298d-5 * self solarMass</body></methods><methods><class-id>Shootout.Chameleon</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize">initialize    meetings := 0.    waitingForPair := Semaphore new.    semaphore := Semaphore new</body></methods><methods><class-id>Shootout.Chameleon</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="color">color    ^color</body><body package="ComputerLanguageShootout" selector="meetings">meetings    ^meetings</body><body package="ComputerLanguageShootout" selector="wait">wait    semaphore wait</body></methods><methods><class-id>Shootout.Chameleon</class-id> <category>running</category><body package="ComputerLanguageShootout" selector="fork:">fork: meetingPlace    ^[ self run: meetingPlace ] fork</body><body package="ComputerLanguageShootout" selector="run:">run: meetingPlace    [ color == #faded ] whileFalse: [	meetingPlace reachedBy: self.	waitingForPair wait ]</body></methods><methods><class-id>Shootout.Chameleon</class-id> <category>changing colors</category><body package="ComputerLanguageShootout" selector="color:">color: c    color := c</body><body package="ComputerLanguageShootout" selector="fade">fade    color := #faded.    waitingForPair signal.    semaphore signal</body><body package="ComputerLanguageShootout" selector="met:">met: other    | newColor |    meetings := meetings + 1.    color == #red ifTrue: [	newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].    color == #yellow ifTrue: [	newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].    color == #blue ifTrue: [	newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].    color := newColor.    waitingForPair signal</body></methods><methods><class-id>Shootout.Chameleon class</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="color:">color: c    ^self new	initialize;	color: c</body></methods><methods><class-id>Shootout.PermGenerator</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize:">initialize: size    perm := (1 to: size) asArray.    timesRotated := Array new: size withAll: 0.    atEnd := false</body></methods><methods><class-id>Shootout.PermGenerator</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="atEnd">atEnd    ^atEnd</body><body package="ComputerLanguageShootout" selector="next">next    | result |    result := perm copy.    self makeNext.    ^result</body></methods><methods><class-id>Shootout.PermGenerator</class-id> <category>benchmarks</category><body package="ComputerLanguageShootout" selector="maxPfannkuchenTo:">maxPfannkuchenTo: output 	| max permutation check |	max := 0.	check := 0.	[self atEnd] whileFalse:		[permutation := self next.		check &lt; 30 ifTrue:			[permutation do: [:each | output print: each].			output cr.			check := check + 1].		max := max max: permutation pfannkuchen].	^max</body></methods><methods><class-id>Shootout.PermGenerator</class-id> <category>private</category><body package="ComputerLanguageShootout" selector="makeNext">makeNext    | temp remainder |    "Generate the next permutation."    2 to: perm size do: [ :r |	"Rotate the first r items to the left."        temp := perm at: 1.        1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].        perm at: r put: temp.        remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.        remainder = 0 ifFalse: [ ^self ].	"After r rotations, the first r items are in their original positions.	 Go on rotating the first r+1 items."    ].    "We are past the final permutation."    atEnd := true</body></methods><methods><class-id>Shootout.PermGenerator class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="new:">new: size    ^self new	initialize: size;	yourself</body></methods><methods><class-id>Shootout.BitArray</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="at:">at: index    | wordIndex bitMask |    wordIndex := ((index - 1) bitShift: -3) + 1.    bitMask := 1 bitShift: (index - 1 bitAnd: 7).    ^((self basicAt: wordIndex) bitAnd: bitMask) &gt; 0</body><body package="ComputerLanguageShootout" selector="at:put:">at: index put: bit    | wordIndex bitMask word |    wordIndex := ((index - 1) bitShift: -3) + 1.    bitMask := 1 bitShift: (index - 1 bitAnd: 7).    word := self basicAt: wordIndex.    word := word bitOr: bitMask.    bit ifFalse: [word := word - bitMask].    self basicAt: wordIndex put: word.    ^bit</body><body package="ComputerLanguageShootout" selector="atAllPut:">atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	| value |	value := anObject ifTrue: [255] ifFalse: [0].	1 to: self basicSize do: [:index | self basicAt: index put: value]</body></methods><methods><class-id>Shootout.BitArray class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="new:">new: size    ^super new: (size + 7 bitShift: -3)</body></methods><methods><class-id>Shootout.MeetingPlace</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="initialize">initialize    mutex := Semaphore forMutualExclusion.    total := 0</body></methods><methods><class-id>Shootout.MeetingPlace</class-id> <category>running</category><body package="ComputerLanguageShootout" selector="max:">max: maxMeetings    max := maxMeetings</body><body package="ComputerLanguageShootout" selector="organizeMeetingWith:">organizeMeetingWith: second    total &gt;= max	ifTrue: [	    first fade.	    second fade ]	ifFalse: [	    first met: second color.	    second met: first color ].    total := total + 1</body><body package="ComputerLanguageShootout" selector="reachedBy:">reachedBy: chameleon    mutex critical: [	first isNil	    ifTrue: [ first := chameleon ]	    ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ]</body></methods><methods><class-id>Shootout.MeetingPlace class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="forMeetings:">forMeetings: maxMeetings    ^super new	initialize;	max: maxMeetings;	yourself</body></methods><methods><class-id>Shootout.RepeatStream</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="next">next   position &gt;= readLimit ifTrue: [ self position: 0 ].   repeatPtr := repeatPtr + 1.   ^collection at: (position := position + 1)</body></methods><methods><class-id>Shootout.RepeatStream</class-id> <category>testing</category><body package="ComputerLanguageShootout" selector="atEnd">atEnd	^repeatPtr &gt;= repeatLimit</body></methods><methods><class-id>Shootout.RepeatStream</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="to:">to: anInteger   repeatPtr := 0.   repeatLimit := anInteger</body></methods><methods><class-id>Shootout.RepeatStream class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="to:on:">to: anInteger on: aCollection    ^(super on: aCollection) to: anInteger</body></methods><methods><class-id>Shootout.RandomStream</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="on:">on: aCollection 	| size cp |	repeatPtr := 0.	random := RandomNumber to: 1.0.	size := aCollection size.	percentages := Array new: size.	collection := Array new: size.	cp := 0.0d.	1 to: size do:		[:i | 		collection at: i put: (aCollection at: i) key.		percentages at: i put: (cp := cp + (aCollection at: i) value)]</body></methods><methods><class-id>Shootout.RandomStream</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="next">next   | r |   r := random next.   repeatPtr := repeatPtr + 1.   1 to: percentages size do: [:i|       (r &lt; (percentages at: i)) ifTrue: [^collection at: i]]</body><body package="ComputerLanguageShootout" selector="random:">random: aRandomNumber"*Share the random number generator so we can get the expected results.*"   random := aRandomNumber</body></methods><methods><class-id>Shootout.RandomStream2</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="on:">on: aCollection 	| size cp |	repeatPtr := 0.	random := RandomNumber to: 1.0.	size := aCollection size.	percentages := Array new: size.	collection := Array new: size.	cp := 0.0d.	1 to: size do:		[:i | 		collection at: i put: (aCollection at: i) first.		percentages at: i put: (cp := cp + (aCollection at: i) last)]</body></methods><methods><class-id>Shootout.RandomStream2</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="next">next   | r |   r := random next.   repeatPtr := repeatPtr + 1.   1 to: percentages size do: [:i|       (r &lt; (percentages at: i)) ifTrue: [^collection at: i]]</body><body package="ComputerLanguageShootout" selector="random:">random: aRandomNumber"*Share the random number generator so we can get the expected results.*"   random := aRandomNumber</body></methods><methods><class-id>Shootout.TreeNode</class-id> <category>initialize-release</category><body package="ComputerLanguageShootout" selector="left:right:item:">left: leftChild right: rightChild item: anItem   left := leftChild.   right := rightChild.   item := anItem</body></methods><methods><class-id>Shootout.TreeNode</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="itemCheck">itemCheck   ^left isNil       ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]</body></methods><methods><class-id>Shootout.TreeNode class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="bottomUpTree:depth:">bottomUpTree: anItem depth: anInteger   ^(anInteger &gt; 0)       ifTrue: [         self             left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1)             right: (self bottomUpTree: 2*anItem depth: anInteger - 1)              item: anItem         ]      ifFalse: [self left: nil right: nil item: anItem] </body><body package="ComputerLanguageShootout" selector="left:right:item:">left: leftChild right: rightChild item: anItem         ^(super new) left: leftChild right: rightChild item: anItem</body></methods><methods><class-id>Core.Array</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="multiplyAtAv">multiplyAtAv   ^(self multiplyAv) multiplyAtv</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="ComputerLanguageShootout" selector="withNl">withNl   ^self,  String withNl</body></methods><methods><class-id>Core.Double</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="fib">fib   ^self &lt; 2.0d ifTrue: [1.0d] ifFalse: [(self - 2.0d) fib + (self - 1.0d) fib]</body></methods><methods><class-id>OS.ExternalWriteStream</class-id> <category>accessing</category><body package="OS-Streaming" selector="writeFasta:sequence:">writeFasta: aString sequence: aStream   | i |   self nextPut: $&gt;; nextPutAll: aString; cr.   i := 0.   [aStream atEnd] whileFalse: [      (i == 60) ifTrue: [self cr. i := 0].      self nextPut: aStream next.      i := i + 1.      ].   self cr</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="matrixA:">matrixA: anInteger"fixup one-based indexing to zero-based indexing - cleanup later"   | i j |   i := self - 1.    j := anInteger - 1.   ^1.0d / (i + j * (i + j + 1) /2  + i + 1) asDouble</body></methods><methods><class-id>Core.String</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="inject:intoSubstringFrequencies:offset:">inject: aDictionary intoSubstringFrequencies: aLength offset: anInteger 	anInteger to: self size - aLength + 1 by: aLength do:		[:i | | fragment value |		fragment := self copyFrom: i to: i + aLength - 1.		value := aDictionary at: fragment ifAbsent: [0].		aDictionary at: fragment put: value + 1]</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="tak:z:">tak: y z: z   ^y &lt; self       ifTrue: [((self - 1) tak: y z: z) tak: ((y - 1) tak: z z: self) z: ((z - 1) tak: self z: y)]      ifFalse: [z]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="ComputerLanguageShootout" selector="at:putValueOf:ifAbsentPutValueOf:">at: key putValueOf: putBlock ifAbsentPutValueOf: absentBlock	"Set the value at key to be the value of evaluating putBlock with the existing value.	 If key is not found, create a new entry for key and set is value to the evaluation of	 absentBlock. Answer the result of evaluating either block."	| index element anObject |	key == nil ifTrue:		[^self			subscriptBoundsErrorFor: #at:putValueOf:ifAbsentPutValueOf:			index: key			value: absentBlock value].	index := self findKeyOrNil: key.	element := self basicAt: index.	element == nil		ifTrue: [self atNewIndex: index put: (self createKey: key value: (anObject := absentBlock value))]		ifFalse: [element value: (anObject := putBlock value: element value)].	^anObject</body></methods><methods><class-id>OS.ExternalWriteStream</class-id> <category>accessing</category><body package="OS-Streaming" selector="writeReverseComplementFasta:sequence:">writeReverseComplementFasta: aString sequence: aSequence   | lineLength n iub |   (aString isNil) ifTrue: [^self].   lineLength := 60. n := aSequence size.   iub := String new: 128 withAll: $*.   iub at: $a asInteger put: $T. iub at: $A asInteger put: $T.   iub at: $b asInteger put: $V. iub at: $B asInteger put: $V.   iub at: $c asInteger put: $G. iub at: $C asInteger put: $G.   iub at: $d asInteger put: $H. iub at: $D asInteger put: $H.   iub at: $g asInteger put: $C. iub at: $G asInteger put: $C.   iub at: $h asInteger put: $D. iub at: $H asInteger put: $D.   iub at: $k asInteger put: $M. iub at: $K asInteger put: $M.   iub at: $m asInteger put: $K. iub at: $M asInteger put: $K.   iub at: $n asInteger put: $N. iub at: $N asInteger put: $N.   iub at: $r asInteger put: $Y. iub at: $R asInteger put: $Y.   iub at: $s asInteger put: $S. iub at: $S asInteger put: $S.   iub at: $t asInteger put: $A. iub at: $T asInteger put: $A.   iub at: $v asInteger put: $B. iub at: $V asInteger put: $B.   iub at: $w asInteger put: $W. iub at: $W asInteger put: $W.   iub at: $y asInteger put: $R. iub at: $Y asInteger put: $R.   self nextPutAll: aString; cr.   [n &gt; 0] whileTrue: [         1 to: ((n &lt; lineLength) ifTrue: [n] ifFalse: [lineLength]) do:            [:i | self nextPut: (iub at: (aSequence at: n - i + 1) asInteger)].         self cr.         n := n - lineLength.      ]</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="asPaddedString:">asPaddedString: aWidth   | s |   s := WriteStream on: (String new: 10).   self printOn: s paddedWith: $  to: aWidth base: 10.   ^s contents</body></methods><methods><class-id>OS.CEnvironment class</class-id> <category>class accessing</category><body package="ComputerLanguageShootout" selector="argv">argv   | answer isArg |   isArg := false.   answer := OrderedCollection new.   CEnvironment commandLine       do: [:each|         isArg            ifTrue: [               (each first isAlphaNumeric)                   ifTrue: [answer add: each]                  ifFalse: [isArg := false]                   ]            ifFalse: [isArg := each = '-a']      ].   ^answer</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="ComputerLanguageShootout" selector="withNl">withNl   ^super with: Character lf</body></methods><methods><class-id>OS.ExternalReadStream</class-id> <category>accessing</category><body package="OS-Streaming" selector="readFasta:">readFasta: anId   | idString newline buffer description line char |   idString := '&gt;',anId.   newline := Character cr.   "* find start of particular fasta sequence *"   [(self atEnd) or: [         (self peek = $&gt;)            ifTrue: [((line := self upTo: newline)               indexOfSubCollection: idString startingAt: 1) = 1]            ifFalse: [self skipThrough: newline. false]]      ] whileFalse.   "* line-by-line read - it would be a lot faster to block read *"   description := line.   buffer := ReadWriteStream on: (String new: 1028).   [(self atEnd) or: [(char := self peek) = $&gt;]] whileFalse: [      (char = $;)         ifTrue: [self upTo: newline]         ifFalse: [buffer nextPutAll: (self upTo: newline)]      ].   ^Association key: description value: buffer contents</body></methods><methods><class-id>Core.Integer</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="asPaddedString:">asPaddedString: aWidth   | s |   s := WriteStream on: (String new: 10).   self printOn: s paddedWith: $  to: aWidth base: 10.   ^s contents </body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="ackermann:">ackermann: anInteger   ^self = 0      ifTrue: [anInteger + 1]      ifFalse: [         anInteger = 0            ifTrue: [self - 1 ackermann:  1]            ifFalse: [self - 1 ackermann: (self ackermann: anInteger - 1)] ]</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>converting</category><body package="ComputerLanguageShootout" selector="asStringWith:">asStringWith: anInteger   ^(self asFixedPoint: anInteger) printString copyWithout: $s</body></methods><methods><class-id>Core.Array</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="multiplyAv">multiplyAv   | n av |   n := self size.   av := Array new: n withAll: 0.0d.   1 to: n do: [:i| 	      1 to: n do: [:j|         av at: i put: (av at: i) + ((i matrixA: j) * (self at: j)) ]].   ^av</body></methods><methods><class-id>Core.String</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="substringFrequencies:">substringFrequencies: aLength 	| answer |	answer := Dictionary new: 1024.	1 to: aLength do:		[:i |		self inject: answer intoSubstringFrequencies: aLength offset: i].	^answer</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="ack:">ack: aSmallInteger   ^self == 0      ifTrue: [aSmallInteger + 1]      ifFalse: [         aSmallInteger == 0            ifTrue: [self - 1 ack:  1]            ifFalse: [self - 1 ack: (self ack: aSmallInteger - 1)] ]</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>printing</category><body package="ComputerLanguageShootout" selector="printOn:withName:">printOn: aStream withName: aString   aStream  nextPutAll: (self asStringWith: 9); nextPut: Character tab; nextPutAll: aString; cr.</body></methods><methods><class-id>Core.Float</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="takfp:z:">takfp: aFloatY z: aFloatZ   ^aFloatY &lt; self       ifTrue: [          ((self - 1.0) takfp: aFloatY z: aFloatZ)                  takfp: ((aFloatY - 1.0) takfp: aFloatZ z: self)             z: ((aFloatZ - 1.0) takfp: self z: aFloatY)         ]      ifFalse: [aFloatZ]</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="fib">fib   ^self &lt; 2 ifTrue: [1] ifFalse: [(self - 2) fib + (self - 1) fib]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="substringFrequencies:using:">substringFrequencies: aLength using: aDictionary 	1 to: self size - aLength + 1 do: 		[:i | | fragment |		fragment := self copyFrom: i to: i + aLength - 1.		aDictionary at: fragment putValueOf: [:sum| sum + 1] ifAbsentPutValueOf: 1].	^aDictionary</body></methods><methods><class-id>Core.Array</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="pfannkuchen">pfannkuchen    | first complement a b k |    k := 0.    [ (first := self at: 1) == 1 ] whileFalse: [	k := k + 1.	complement := first + 1.	1 to: first // 2 do: [ :i |	    a := self at: i.	    b := self at: complement - i.	    self at: i put: b.	    self at: complement - i put: a.	]    ].    ^k</body></methods><methods><class-id>Core.String</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="inject2:intoSubstringFrequencies:offset:">inject2: aDictionary intoSubstringFrequencies: aLength offset: anInteger   anInteger to: self size - aLength + 1 by: aLength do: [:i |      | fragment value |      fragment := (self copyFrom: i to: i + aLength - 1) asSymbol.      value := aDictionary at: fragment ifAbsent: [ 0 ].      aDictionary at: fragment put: value + 1    ]</body></methods><methods><class-id>Core.Array</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="multiplyAtv">multiplyAtv   | n atv |   n := self size.   atv := Array new: n withAll: 0.0d.   1 to: n do: [:i| 	      1 to: n do: [:j|         atv at: i put: (atv at: i) + ((j matrixA: i) * (self at: j)) ]].   ^atv</body></methods><methods><class-id>Core.String</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="substringFrequencies2:">substringFrequencies2: aLength   | answer |   answer := IdentityDictionary new.   1 to: aLength do: [:i |      self inject2: answer intoSubstringFrequencies: aLength offset: i].   ^answer</body></methods><methods><class-id>Core.String</class-id> <category>comparing</category><body package="ComputerLanguageShootout" selector="dnaSequenceHash">dnaSequenceHash	"Answer a uniformly distributed SmallInteger computed from the contents	of the receiver, which is a string composed of only the lettersd ACGT."	"Each character contributes 2 bts to the hash.  Bit positions climb to 28	 before wrapping"	| hash bitPosition |	hash := 0.	bitPosition := 0.	1 to: self size do:		[:i| | c |		c := self at: i.		hash := hash + ((c &gt;= $G ifTrue: [c = $G ifTrue: [2] ifFalse: [3]] ifFalse: [c = $A ifTrue: [0] ifFalse: [1]]) bitShift: bitPosition).		(bitPosition := bitPosition + 2) &gt;= 28 ifTrue:			[bitPosition := 0.			 hash := hash bitAnd: 16rFFFFFFF]].	^hash</body></methods><methods><class-id>Core.Double</class-id> <category>computer language shootout</category><body package="ComputerLanguageShootout" selector="tak:z:">tak: y z: z   ^y &lt; self       ifTrue: [((self - 1.0d) tak: y z: z) tak: ((y - 1.0d) tak: z z: self) z: ((z - 1.0d) tak: self z: y)]      ifFalse: [z]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ExternalReadStream</name><environment>OS</environment><super>OS.BufferedExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ExternalWriteStream</name><environment>OS</environment><super>OS.BufferedExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>