"* The Computer Language Shootout
    http://shootout.alioth.debian.org/
    contributed by Isaac Gouy
    modified by Eliot Miranda *"!

Object subclass: #PiDigitSpigot   instanceVariableNames: 'z x inverse'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!

Object subclass: #Transformation   instanceVariableNames: 'q r s t k'   classVariableNames: ''   poolDictionaries: ''   category: 'Shootout'!!PiDigitSpigot methodsFor: 'private'!consume: aTransformation   ^z * aTransformation! !!PiDigitSpigot methodsFor: 'private'!digit   ^(z extract: 3) floor! !!PiDigitSpigot methodsFor: 'private'!isSafe: aDigit   ^aDigit = (z extract: 4) floor! !!PiDigitSpigot methodsFor: 'private'!produce: anInteger   inverse q: 10 r: -10 * anInteger s: 0 t: 1.   ^inverse * z! !!PiDigitSpigot methodsFor: 'accessing'!next   | y |   ^(self isSafe: (y := self digit))      ifTrue: [z := self produce: y. y]      ifFalse: [z := self consume: x next. self next]! !!PiDigitSpigot methodsFor: 'initialize-release'!initialize   z := Transformation unity.   x := Transformation new.   inverse := Transformation new.! !!PiDigitSpigot class methodsFor: 'instance creation'!new   ^super new initialize! !!Tests class methodsFor: 'benchmarking'!pidigitsTo: v width: width to: output   | n i pidigits |   n := v.   i := 0.   pidigits := PiDigitSpigot new.   [n > 0] whileTrue:      [n < width         ifTrue:            [n timesRepeat: [output nextPut: (Character digitValue: pidigits next)].            n to: width do: [:each | output space].            i := i + n]         ifFalse:            [width timesRepeat: [output nextPut: (Character digitValue: pidigits next)].            i := i + width].
      output tab; nextPut: $:; print: i; nl.
      n := n - width]! !!Tests class methodsFor: 'benchmark scripts'!pidigits   self pidigitsTo: self arg width: 10 to: self stdout.   ^''! !!Transformation methodsFor: 'accessing'!* aTransformation   ^self species       q: q * aTransformation q      r: q * aTransformation r + (r * aTransformation t)      s: s * aTransformation q + (t * aTransformation s)      t: s * aTransformation r + (t * aTransformation t)! !!Transformation methodsFor: 'accessing'!extract: anInteger   ^(q * anInteger + r) // (s * anInteger + t)! !!Transformation methodsFor: 'accessing'!next   k := k +1.   q := k.   r := 4 * k + 2.   s := 0.   t := 2 * k + 1.! !!Transformation methodsFor: 'accessing'!q   ^q! !!Transformation methodsFor: 'accessing'!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   q := anInteger1.   r := anInteger2.   s := anInteger3.   t := anInteger4.   k := 0.! !!Transformation methodsFor: 'accessing'!r   ^r! !!Transformation methodsFor: 'accessing'!s   ^s! !!Transformation methodsFor: 'accessing'!t   ^t! !!Transformation methodsFor: 'initialize-release'!initialize   q := 0.   r := 0.   s := 0.   t := 0.   k := 0.! !!Transformation class methodsFor: 'instance creation'!new   ^super new initialize! !!Transformation class methodsFor: 'instance creation'!q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4   ^(super new) q: anInteger1 r: anInteger2 s: anInteger3 t: anInteger4! !!Transformation class methodsFor: 'instance creation'!unity   ^self q: 1 r: 0 s: 0 t: 1! !

Tests pidigits!
