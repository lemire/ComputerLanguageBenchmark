<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Rust program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Rust program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">//</span>
<span class="slc">// contributed by the Rust Project Developers</span>
<span class="slc">// contributed by TeXitoi</span>

<span class="kwa">use</span> std<span class="opt">::</span>iter<span class="opt">::</span>repeat<span class="opt">;</span>
<span class="kwa">use</span> std<span class="opt">::</span>sync<span class="opt">::</span>Arc<span class="opt">;</span>
<span class="kwa">use</span> std<span class="opt">::</span>sync<span class="opt">::</span>mpsc<span class="opt">::</span>channel<span class="opt">;</span>
<span class="kwa">use</span> std<span class="opt">::</span>thread<span class="opt">::</span>spawn<span class="opt">;</span>

<span class="slc">//</span>
<span class="slc">// Utilities.</span>
<span class="slc">//</span>

<span class="slc">// returns an infinite iterator of repeated applications of f to x,</span>
<span class="slc">// i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.</span>
<span class="kwa">fn</span> iterate<span class="opt">&lt;</span>T<span class="opt">,</span> F<span class="opt">&gt;(</span>x<span class="opt">:</span> T<span class="opt">,</span> f<span class="opt">:</span> F<span class="opt">) -&gt;</span> Iterate<span class="opt">&lt;</span>T<span class="opt">,</span> F<span class="opt">&gt;</span> <span class="kwa">where</span> F<span class="opt">:</span> <span class="kwd">FnMut</span><span class="opt">(&amp;</span>T<span class="opt">) -&gt;</span> T <span class="opt">{</span>
    Iterate <span class="opt">{</span> f<span class="opt">:</span> f<span class="opt">,</span> next<span class="opt">:</span> x <span class="opt">}</span>
<span class="opt">}</span>
<span class="kwa">struct</span> Iterate<span class="opt">&lt;</span>T<span class="opt">,</span> F<span class="opt">&gt;</span> <span class="kwa">where</span> F<span class="opt">:</span> <span class="kwd">FnMut</span><span class="opt">(&amp;</span>T<span class="opt">) -&gt;</span> T <span class="opt">{</span> f<span class="opt">:</span> F<span class="opt">,</span> next<span class="opt">:</span> T <span class="opt">}</span>
<span class="kwa">impl</span><span class="opt">&lt;</span>T<span class="opt">,</span> F<span class="opt">&gt;</span> Iterator <span class="kwa">for</span> Iterate<span class="opt">&lt;</span>T<span class="opt">,</span> F<span class="opt">&gt;</span> <span class="kwa">where</span> F<span class="opt">:</span> <span class="kwd">FnMut</span><span class="opt">(&amp;</span>T<span class="opt">) -&gt;</span> T <span class="opt">{</span>
    <span class="kwa">type</span> Item <span class="opt">=</span> T<span class="opt">;</span>

    <span class="kwa">fn</span> <span class="kwd">next</span><span class="opt">(&amp;</span><span class="kwa">mut self</span><span class="opt">) -&gt;</span> Option<span class="opt">&lt;</span>T<span class="opt">&gt; {</span>
        <span class="kwa">let mut</span> res <span class="opt">= (</span><span class="kwa">self</span><span class="num">.f</span><span class="opt">)(&amp;</span><span class="kwa">self</span><span class="opt">.</span>next<span class="opt">);</span>
        std<span class="opt">::</span>mem<span class="opt">::</span><span class="kwd">swap</span><span class="opt">(&amp;</span><span class="kwa">mut</span> res<span class="opt">, &amp;</span><span class="kwa">mut self</span><span class="opt">.</span>next<span class="opt">);</span>
        <span class="kwd">Some</span><span class="opt">(</span>res<span class="opt">)</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">// a linked list using borrowed next.</span>
<span class="kwa">enum</span> List<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">:</span>&apos;a<span class="opt">&gt; {</span>
    Nil<span class="opt">,</span>
    <span class="kwd">Cons</span><span class="opt">(</span>T<span class="opt">, &amp;</span>&apos;a List<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt;)</span>
<span class="opt">}</span>
<span class="kwa">struct</span> ListIterator<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">:</span>&apos;a<span class="opt">&gt; {</span>
    cur<span class="opt">: &amp;</span>&apos;a List<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt;</span>
<span class="opt">}</span>
<span class="kwa">impl</span><span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt;</span> List<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt; {</span>
    <span class="kwa">fn</span> <span class="kwd">iter</span><span class="opt">(&amp;</span>&apos;a <span class="kwa">self</span><span class="opt">) -&gt;</span> ListIterator<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt; {</span>
        ListIterator <span class="opt">{</span> cur<span class="opt">:</span> <span class="kwa">self</span> <span class="opt">}</span>
    <span class="opt">}</span>
<span class="opt">}</span>
<span class="kwa">impl</span><span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt;</span> Iterator <span class="kwa">for</span> ListIterator<span class="opt">&lt;</span>&apos;a<span class="opt">,</span> T<span class="opt">&gt; {</span>
    <span class="kwa">type</span> Item <span class="opt">= &amp;</span>&apos;a T<span class="opt">;</span>

    <span class="kwa">fn</span> <span class="kwd">next</span><span class="opt">(&amp;</span><span class="kwa">mut self</span><span class="opt">) -&gt;</span> Option<span class="opt">&lt;&amp;</span>&apos;a T<span class="opt">&gt; {</span>
        <span class="kwa">match</span> <span class="opt">*</span><span class="kwa">self</span><span class="opt">.</span>cur <span class="opt">{</span>
            List<span class="opt">::</span>Nil <span class="opt">=&gt;</span> None<span class="opt">,</span>
            List<span class="opt">::</span><span class="kwd">Cons</span><span class="opt">(</span><span class="kwa">ref</span> elt<span class="opt">,</span> next<span class="opt">) =&gt; {</span>
                <span class="kwa">self</span><span class="opt">.</span>cur <span class="opt">=</span> next<span class="opt">;</span>
                <span class="kwd">Some</span><span class="opt">(</span>elt<span class="opt">)</span>
            <span class="opt">}</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">//</span>
<span class="slc">// preprocess</span>
<span class="slc">//</span>

<span class="slc">// Takes a pieces p on the form [(y1, x1), (y2, x2), ...] and returns</span>
<span class="slc">// every possible transformations (the 6 rotations with their</span>
<span class="slc">// corresponding mirrored piece), with, as minimum coordinates, (0,</span>
<span class="slc">// 0).  If all is false, only generate half of the possibilities (used</span>
<span class="slc">// to break the symmetry of the board).</span>
<span class="kwa">fn</span> <span class="kwd">transform</span><span class="opt">(</span>piece<span class="opt">:</span> Vec<span class="opt">&lt;(</span><span class="kwb">i32</span><span class="opt">,</span> <span class="kwb">i32</span><span class="opt">)&gt; ,</span> all<span class="opt">:</span> bool<span class="opt">) -&gt;</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;(</span><span class="kwb">i32</span><span class="opt">,</span> <span class="kwb">i32</span><span class="opt">)&gt;&gt; {</span>
    <span class="kwa">let mut</span> res<span class="opt">:</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;(</span><span class="kwb">i32</span><span class="opt">,</span> <span class="kwb">i32</span><span class="opt">)&gt;&gt; =</span>
        <span class="slc">// rotations</span>
        <span class="kwd">iterate</span><span class="opt">(</span>piece<span class="opt">, |</span>rot<span class="opt">|</span> rot<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">map</span><span class="opt">(|&amp;(</span>y<span class="opt">,</span> x<span class="opt">)| (</span>x <span class="opt">+</span> y<span class="opt">, -</span>y<span class="opt">)).</span><span class="kwd">collect</span><span class="opt">())</span>
        <span class="opt">.</span><span class="kwd">take</span><span class="opt">(</span><span class="kwa">if</span> all <span class="opt">{</span> <span class="num">6</span> <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span> <span class="num">3</span> <span class="opt">})</span>
        <span class="slc">// mirror</span>
        <span class="num">.f</span>lat<span class="num">_</span>map<span class="opt">(|</span>cur_piece<span class="opt">| {</span>
            <span class="kwd">iterate</span><span class="opt">(</span>cur_piece<span class="opt">, |</span>mir<span class="opt">|</span> mir<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">map</span><span class="opt">(|&amp;(</span>y<span class="opt">,</span> x<span class="opt">)| (</span>x<span class="opt">,</span> y<span class="opt">)).</span><span class="kwd">collect</span><span class="opt">())</span>
            <span class="opt">.</span><span class="kwd">take</span><span class="opt">(</span><span class="num">2</span><span class="opt">)</span>
        <span class="opt">}).</span><span class="kwd">collect</span><span class="opt">();</span>

    <span class="slc">// translating to (0, 0) as minimum coordinates.</span>
    <span class="kwa">for</span> cur_piece <span class="kwa">in</span> res<span class="num">.i</span>ter<span class="num">_</span>m<span class="num">u</span>t<span class="opt">() {</span>
        <span class="kwa">let</span> <span class="opt">(</span>dy<span class="opt">,</span> dx<span class="opt">) = *</span>cur_piece<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">min</span><span class="opt">()</span><span class="num">.u</span>nwrap<span class="opt">();</span>
        <span class="kwa">for</span> <span class="opt">&amp;</span><span class="kwa">mut</span> <span class="opt">(</span><span class="kwa">ref mut</span> y<span class="opt">,</span> <span class="kwa">ref mut</span> x<span class="opt">)</span> <span class="kwa">in</span> cur_piece<span class="num">.i</span>ter<span class="num">_</span>m<span class="num">u</span>t<span class="opt">() {</span>
            <span class="opt">*</span>y <span class="opt">-=</span> dy<span class="opt">; *</span>x <span class="opt">-=</span> dx<span class="opt">;</span>
        <span class="opt">}</span>
    <span class="opt">}</span>

    res
<span class="opt">}</span>

<span class="slc">// A mask is a piece somewhere on the board.  It is represented as a</span>
<span class="slc">// u64: for i in the first 50 bits, m[i] = 1 if the cell at (i/5, i%5)</span>
<span class="slc">// is occupied.  m[50 + id] = 1 if the identifier of the piece is id.</span>

<span class="slc">// Takes a piece with minimum coordinate (0, 0) (as generated by</span>
<span class="slc">// transform).  Returns the corresponding mask if p translated by (dy,</span>
<span class="slc">// dx) is on the board.</span>
<span class="kwa">fn</span> <span class="kwd">mask</span><span class="opt">(</span>dy<span class="opt">:</span> <span class="kwb">i32</span><span class="opt">,</span> dx<span class="opt">:</span> <span class="kwb">i32</span><span class="opt">,</span> id<span class="opt">:</span> <span class="kwb">usize</span><span class="opt">,</span> p<span class="opt">: &amp;</span>Vec<span class="opt">&lt;(</span><span class="kwb">i32</span><span class="opt">,</span> <span class="kwb">i32</span><span class="opt">)&gt;) -&gt;</span> Option<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt; {</span>
    <span class="kwa">let mut</span> m <span class="opt">=</span> <span class="num">1</span> <span class="opt">&lt;&lt; (</span><span class="num">50</span> <span class="opt">+</span> id<span class="opt">);</span>
    <span class="kwa">for</span> <span class="opt">&amp;(</span>y<span class="opt">,</span> x<span class="opt">)</span> <span class="kwa">in</span> p<span class="num">.i</span>ter<span class="opt">() {</span>
        <span class="kwa">let</span> x <span class="opt">=</span> x <span class="opt">+</span> dx <span class="opt">+ (</span>y <span class="opt">+ (</span>dy <span class="opt">%</span> <span class="num">2</span><span class="opt">)) /</span> <span class="num">2</span><span class="opt">;</span>
        <span class="kwa">if</span> x <span class="opt">&lt;</span> <span class="num">0</span> <span class="opt">||</span> x <span class="opt">&gt;</span> <span class="num">4</span> <span class="opt">{</span> <span class="kwa">return</span> None<span class="opt">; }</span>
        <span class="kwa">let</span> y <span class="opt">=</span> y <span class="opt">+</span> dy<span class="opt">;</span>
        <span class="kwa">if</span> y <span class="opt">&lt;</span> <span class="num">0</span> <span class="opt">||</span> y <span class="opt">&gt;</span> <span class="num">9</span> <span class="opt">{</span> <span class="kwa">return</span> None<span class="opt">; }</span>
        m <span class="opt">|=</span> <span class="num">1</span> <span class="opt">&lt;&lt; (</span>y <span class="opt">*</span> <span class="num">5</span> <span class="opt">+</span> x<span class="opt">)</span> <span class="kwa">as</span> <span class="kwb">usize</span><span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwd">Some</span><span class="opt">(</span>m<span class="opt">)</span>
<span class="opt">}</span>

<span class="slc">// Makes every possible masks.  masks[i][id] correspond to every</span>
<span class="slc">// possible masks for piece with identifier id with minimum coordinate</span>
<span class="slc">// (i/5, i%5).</span>
<span class="kwa">fn</span> <span class="kwd">make_masks</span><span class="opt">() -&gt;</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt; &gt; &gt; {</span>
    <span class="kwa">let</span> pieces <span class="opt">=</span> vec<span class="opt">!(</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">3</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">3</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">3</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">1</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">2</span><span class="opt">,</span><span class="num">1</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">2</span><span class="opt">,</span><span class="num">1</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">2</span><span class="opt">,</span><span class="num">1</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">2</span><span class="opt">,</span><span class="num">1</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">3</span><span class="opt">)),</span>
        vec<span class="opt">!((</span><span class="num">0</span><span class="opt">,</span><span class="num">0</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">1</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">2</span><span class="opt">),(</span><span class="num">0</span><span class="opt">,</span><span class="num">3</span><span class="opt">),(</span><span class="num">1</span><span class="opt">,</span><span class="num">2</span><span class="opt">)));</span>

    <span class="slc">// To break the central symmetry of the problem, every</span>
    <span class="slc">// transformation must be taken except for one piece (piece 3</span>
    <span class="slc">// here).</span>
    <span class="kwa">let</span> transforms<span class="opt">:</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;(</span><span class="kwb">i32</span><span class="opt">,</span> <span class="kwb">i32</span><span class="opt">)&gt;&gt;&gt; =</span>
        pieces<span class="num">.i</span>nto<span class="num">_i</span>ter<span class="opt">().</span><span class="kwd">enumerate</span><span class="opt">()</span>
        <span class="opt">.</span><span class="kwd">map</span><span class="opt">(|(</span>id<span class="opt">,</span> p<span class="opt">)|</span> <span class="kwd">transform</span><span class="opt">(</span>p<span class="opt">,</span> id <span class="opt">!=</span> <span class="num">3</span><span class="opt">))</span>
        <span class="opt">.</span><span class="kwd">collect</span><span class="opt">();</span>

    <span class="opt">(</span><span class="num">0</span><span class="opt">.</span><span class="num">.50</span><span class="opt">).</span><span class="kwd">map</span><span class="opt">(|</span>yx<span class="opt">| {</span>
        transforms<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">enumerate</span><span class="opt">().</span><span class="kwd">map</span><span class="opt">(|(</span>id<span class="opt">,</span> t<span class="opt">)| {</span>
            t<span class="num">.i</span>ter<span class="opt">()</span><span class="num">.fi</span>lter<span class="num">_</span>map<span class="opt">(|</span>p<span class="opt">|</span> <span class="kwd">mask</span><span class="opt">(</span>yx <span class="opt">/</span> <span class="num">5</span><span class="opt">,</span> yx <span class="opt">%</span> <span class="num">5</span><span class="opt">,</span> id<span class="opt">,</span> p<span class="opt">)).</span><span class="kwd">collect</span><span class="opt">()</span>
        <span class="opt">}).</span><span class="kwd">collect</span><span class="opt">()</span>
    <span class="opt">}).</span><span class="kwd">collect</span><span class="opt">()</span>
<span class="opt">}</span>

<span class="slc">// Check if all coordinates can be covered by an unused piece and that</span>
<span class="slc">// all unused piece can be placed on the board.</span>
<span class="kwa">fn</span> <span class="kwd">is_board_unfeasible</span><span class="opt">(</span>board<span class="opt">:</span> <span class="kwb">u64</span><span class="opt">,</span> masks<span class="opt">: &amp;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;&gt;&gt;) -&gt;</span> bool <span class="opt">{</span>
    <span class="kwa">let mut</span> coverable <span class="opt">=</span> board<span class="opt">;</span>
    <span class="kwa">for</span> <span class="opt">(</span>i<span class="opt">,</span> masks_at<span class="opt">)</span> <span class="kwa">in</span> masks<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">enumerate</span><span class="opt">() {</span>
        <span class="kwa">if</span> board <span class="opt">&amp;</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> i <span class="opt">!=</span> <span class="num">0</span> <span class="opt">{</span> <span class="kwa">continue</span><span class="opt">; }</span>
        <span class="kwa">for</span> <span class="opt">(</span>cur_id<span class="opt">,</span> pos_masks<span class="opt">)</span> <span class="kwa">in</span> masks_at<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">enumerate</span><span class="opt">() {</span>
            <span class="kwa">if</span> board <span class="opt">&amp;</span> <span class="num">1</span> <span class="opt">&lt;&lt; (</span><span class="num">50</span> <span class="opt">+</span> cur_id<span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span> <span class="kwa">continue</span><span class="opt">; }</span>
            <span class="kwa">for</span> <span class="opt">&amp;</span>cur_m <span class="kwa">in</span> pos_masks<span class="num">.i</span>ter<span class="opt">() {</span>
                <span class="kwa">if</span> cur_m <span class="opt">&amp;</span> board <span class="opt">!=</span> <span class="num">0</span> <span class="opt">{</span> <span class="kwa">continue</span><span class="opt">; }</span>
                coverable <span class="opt">|=</span> cur_m<span class="opt">;</span>
                <span class="slc">// if every coordinates can be covered and every</span>
                <span class="slc">// piece can be used.</span>
                <span class="kwa">if</span> coverable <span class="opt">== (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">60</span><span class="opt">) -</span> <span class="num">1</span> <span class="opt">{</span> <span class="kwa">return false</span><span class="opt">; }</span>
            <span class="opt">}</span>
        <span class="opt">}</span>
        <span class="kwa">if</span> coverable <span class="opt">&amp;</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> i <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span> <span class="kwa">return true</span><span class="opt">; }</span>
    <span class="opt">}</span>
    <span class="kwa">true</span>
<span class="opt">}</span>

<span class="slc">// Filter the masks that we can prove to result to unfeasible board.</span>
<span class="kwa">fn</span> <span class="kwd">filter_masks</span><span class="opt">(</span>masks<span class="opt">: &amp;</span><span class="kwa">mut</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;&gt;&gt;) {</span>
    <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..</span>masks<span class="opt">.</span><span class="kwd">len</span><span class="opt">() {</span>
        <span class="kwa">for</span> j <span class="kwa">in</span> <span class="num">0</span><span class="opt">..</span>masks<span class="opt">[</span>i<span class="opt">].</span><span class="kwd">len</span><span class="opt">() {</span>
            masks<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">] =</span>
                masks<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">]</span><span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">map</span><span class="opt">(|&amp;</span>m<span class="opt">|</span> m<span class="opt">)</span>
                <span class="num">.fi</span>lter<span class="opt">(|&amp;</span>m<span class="opt">| !</span><span class="kwd">is_board_unfeasible</span><span class="opt">(</span>m<span class="opt">,</span> masks<span class="opt">))</span>
                <span class="opt">.</span><span class="kwd">collect</span><span class="opt">();</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">// Gets the identifier of a mask.</span>
<span class="kwa">fn</span> <span class="kwd">get_id</span><span class="opt">(</span>m<span class="opt">:</span> <span class="kwb">u64</span><span class="opt">) -&gt;</span> <span class="kwb">u8</span> <span class="opt">{</span>
    <span class="kwa">for</span> id <span class="kwa">in</span> <span class="num">0</span><span class="opt">.</span><span class="num">.10</span> <span class="opt">{</span>
        <span class="kwa">if</span> m <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt; (</span>id <span class="opt">+</span> <span class="num">50</span><span class="opt">)</span> <span class="kwa">as</span> <span class="kwb">usize</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span> <span class="kwa">return</span> id<span class="opt">; }</span>
    <span class="opt">}</span>
    panic<span class="opt">!(</span><span class="str">&quot;{:016x} does not have a valid identifier&quot;</span><span class="opt">,</span> m<span class="opt">);</span>
<span class="opt">}</span>

<span class="slc">// Converts a list of mask to a Vec&lt;u8&gt;.</span>
<span class="kwa">fn</span> <span class="kwd">to_vec</span><span class="opt">(</span>raw_sol<span class="opt">: &amp;</span>List<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;) -&gt;</span> Vec<span class="opt">&lt;</span><span class="kwb">u8</span><span class="opt">&gt; {</span>
    <span class="kwa">let mut</span> sol <span class="opt">=</span> <span class="kwd">repeat</span><span class="opt">(</span>&apos;<span class="opt">.</span>&apos; <span class="kwa">as</span> <span class="kwb">u8</span><span class="opt">).</span><span class="kwd">take</span><span class="opt">(</span><span class="num">50</span><span class="opt">).</span>collect<span class="opt">::&lt;</span>Vec<span class="opt">&lt;</span>_<span class="opt">&gt;&gt;();</span>
    <span class="kwa">for</span> <span class="opt">&amp;</span>m <span class="kwa">in</span> raw_sol<span class="num">.i</span>ter<span class="opt">() {</span>
        <span class="kwa">let</span> id <span class="opt">=</span> &apos;<span class="num">0</span>&apos; <span class="kwa">as</span> <span class="kwb">u8</span> <span class="opt">+</span> <span class="kwd">get_id</span><span class="opt">(</span>m<span class="opt">);</span>
        <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">.</span><span class="num">.50</span> <span class="opt">{</span>
            <span class="kwa">if</span> m <span class="opt">&amp;</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> i <span class="opt">!=</span> <span class="num">0</span> <span class="opt">{</span> sol<span class="opt">[</span>i<span class="opt">] =</span> id<span class="opt">; }</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
    sol
<span class="opt">}</span>

<span class="slc">// Prints a solution in Vec&lt;u8&gt; form.</span>
<span class="kwa">fn</span> <span class="kwd">print_sol</span><span class="opt">(</span>sol<span class="opt">: &amp;</span>Vec<span class="opt">&lt;</span><span class="kwb">u8</span><span class="opt">&gt;) {</span>
    <span class="kwa">for</span> <span class="opt">(</span>i<span class="opt">,</span> c<span class="opt">)</span> <span class="kwa">in</span> sol<span class="num">.i</span>ter<span class="opt">().</span><span class="kwd">enumerate</span><span class="opt">() {</span>
        <span class="kwa">if</span> i <span class="opt">%</span> <span class="num">5</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span> println<span class="opt">!(</span><span class="str">&quot;&quot;</span><span class="opt">); }</span>
        <span class="kwa">if</span> <span class="opt">(</span>i <span class="opt">+</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">10</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span> print<span class="opt">!(</span><span class="str">&quot; &quot;</span><span class="opt">); }</span>
        print<span class="opt">!(</span><span class="str">&quot;{} &quot;</span><span class="opt">, *</span>c <span class="kwa">as</span> <span class="kwb">char</span><span class="opt">);</span>
    <span class="opt">}</span>
    println<span class="opt">!(</span><span class="str">&quot;&quot;</span><span class="opt">);</span>
<span class="opt">}</span>

<span class="slc">// The data managed during the search</span>
<span class="kwa">struct</span> Data <span class="opt">{</span>
    <span class="slc">// Number of solution found.</span>
    nb<span class="opt">:</span> <span class="kwb">i32</span><span class="opt">,</span>
    <span class="slc">// Lexicographically minimal solution found.</span>
    min<span class="opt">:</span> Vec<span class="opt">&lt;</span><span class="kwb">u8</span><span class="opt">&gt;,</span>
    <span class="slc">// Lexicographically maximal solution found.</span>
    max<span class="opt">:</span> Vec<span class="opt">&lt;</span><span class="kwb">u8</span><span class="opt">&gt;</span>
<span class="opt">}</span>
<span class="kwa">impl</span> Data <span class="opt">{</span>
    <span class="kwa">fn</span> <span class="kwd">new</span><span class="opt">() -&gt;</span> Data <span class="opt">{</span>
        Data <span class="opt">{</span> nb<span class="opt">:</span> <span class="num">0</span><span class="opt">,</span> min<span class="opt">:</span> vec<span class="opt">!(),</span> max<span class="opt">:</span> vec<span class="opt">!() }</span>
    <span class="opt">}</span>
    <span class="kwa">fn</span> <span class="kwd">reduce_from</span><span class="opt">(&amp;</span><span class="kwa">mut self</span><span class="opt">,</span> other<span class="opt">:</span> Data<span class="opt">) {</span>
        <span class="kwa">self</span><span class="opt">.</span>nb <span class="opt">+=</span> other<span class="opt">.</span>nb<span class="opt">;</span>
        <span class="kwa">let</span> Data <span class="opt">{</span> min<span class="opt">,</span> max<span class="opt">, ..} =</span> other<span class="opt">;</span>
        <span class="kwa">if</span> min <span class="opt">&lt;</span> <span class="kwa">self</span><span class="opt">.</span>min <span class="opt">{</span> <span class="kwa">self</span><span class="opt">.</span>min <span class="opt">=</span> min<span class="opt">; }</span>
        <span class="kwa">if</span> max <span class="opt">&gt;</span> <span class="kwa">self</span><span class="opt">.</span>max <span class="opt">{</span> <span class="kwa">self</span><span class="opt">.</span>max <span class="opt">=</span> max<span class="opt">; }</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">// Records a new found solution.  Returns false if the search must be</span>
<span class="slc">// stopped.</span>
<span class="kwa">fn</span> <span class="kwd">handle_sol</span><span class="opt">(</span>raw_sol<span class="opt">: &amp;</span>List<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;,</span> data<span class="opt">: &amp;</span><span class="kwa">mut</span> Data<span class="opt">) {</span>
    <span class="slc">// because we break the symmetry, 2 solutions correspond to a call</span>
    <span class="slc">// to this method: the normal solution, and the same solution in</span>
    <span class="slc">// reverse order, i.e. the board rotated by half a turn.</span>
    data<span class="opt">.</span>nb <span class="opt">+=</span> <span class="num">2</span><span class="opt">;</span>
    <span class="kwa">let</span> sol1 <span class="opt">=</span> <span class="kwd">to_vec</span><span class="opt">(</span>raw_sol<span class="opt">);</span>
    <span class="kwa">let</span> sol2<span class="opt">:</span> Vec<span class="opt">&lt;</span><span class="kwb">u8</span><span class="opt">&gt; =</span> sol1<span class="opt">.</span><span class="kwd">iter</span><span class="opt">().</span><span class="kwd">rev</span><span class="opt">().</span><span class="kwd">map</span><span class="opt">(|</span>x<span class="opt">| *</span>x<span class="opt">).</span><span class="kwd">collect</span><span class="opt">();</span>

    <span class="kwa">if</span> data<span class="opt">.</span>nb <span class="opt">==</span> <span class="num">2</span> <span class="opt">{</span>
        data<span class="opt">.</span>min <span class="opt">=</span> sol1<span class="opt">.</span><span class="kwd">clone</span><span class="opt">();</span>
        data<span class="opt">.</span>max <span class="opt">=</span> sol1<span class="opt">.</span><span class="kwd">clone</span><span class="opt">();</span>
    <span class="opt">}</span>

    <span class="kwa">if</span> sol1 <span class="opt">&lt;</span> data<span class="opt">.</span>min <span class="opt">{</span> data<span class="opt">.</span>min <span class="opt">=</span> sol1<span class="opt">; }</span>
    <span class="kwa">else if</span> sol1 <span class="opt">&gt;</span> data<span class="opt">.</span>max <span class="opt">{</span> data<span class="opt">.</span>max <span class="opt">=</span> sol1<span class="opt">; }</span>
    <span class="kwa">if</span> sol2 <span class="opt">&lt;</span> data<span class="opt">.</span>min <span class="opt">{</span> data<span class="opt">.</span>min <span class="opt">=</span> sol2<span class="opt">; }</span>
    <span class="kwa">else if</span> sol2 <span class="opt">&gt;</span> data<span class="opt">.</span>max <span class="opt">{</span> data<span class="opt">.</span>max <span class="opt">=</span> sol2<span class="opt">; }</span>
<span class="opt">}</span>

<span class="kwa">fn</span> <span class="kwd">search</span><span class="opt">(</span>
    masks<span class="opt">: &amp;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;&gt;&gt;,</span>
    board<span class="opt">:</span> <span class="kwb">u64</span><span class="opt">,</span>
    <span class="kwa">mut</span> i<span class="opt">:</span> <span class="kwb">usize</span><span class="opt">,</span>
    cur<span class="opt">:</span> List<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;,</span>
    data<span class="opt">: &amp;</span><span class="kwa">mut</span> Data<span class="opt">)</span>
<span class="opt">{</span>
    <span class="slc">// Search for the lesser empty coordinate.</span>
    <span class="kwa">while</span> board <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> i<span class="opt">) !=</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> i <span class="opt">&lt;</span> <span class="num">50</span> <span class="opt">{</span> i <span class="opt">+=</span> <span class="num">1</span><span class="opt">; }</span>
    <span class="slc">// the board is full: a solution is found.</span>
    <span class="kwa">if</span> i <span class="opt">&gt;=</span> <span class="num">50</span> <span class="opt">{</span> <span class="kwa">return</span> <span class="kwd">handle_sol</span><span class="opt">(&amp;</span>cur<span class="opt">,</span> data<span class="opt">); }</span>
    <span class="kwa">let</span> masks_at <span class="opt">= &amp;</span>masks<span class="opt">[</span>i<span class="opt">];</span>

    <span class="slc">// for every unused piece</span>
    <span class="kwa">for</span> id <span class="kwa">in</span> <span class="opt">(</span><span class="num">0</span><span class="opt">.</span><span class="num">.10</span><span class="opt">)</span><span class="num">.fi</span>lter<span class="opt">(|&amp;</span>id<span class="opt">|</span> board <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt; (</span>id <span class="opt">+</span> <span class="num">50</span><span class="opt">)) ==</span> <span class="num">0</span><span class="opt">) {</span>
        <span class="slc">// for each mask that fits on the board</span>
        <span class="kwa">for</span> m <span class="kwa">in</span> masks_at<span class="opt">[</span>id<span class="opt">]</span><span class="num">.i</span>ter<span class="opt">()</span><span class="num">.fi</span>lter<span class="opt">(|&amp;</span>m<span class="opt">|</span> board <span class="opt">&amp; *</span>m <span class="opt">==</span> <span class="num">0</span><span class="opt">) {</span>
            <span class="slc">// This check is too costly.</span>
            <span class="slc">//if is_board_unfeasible(board | m, masks) {continue;}</span>
            <span class="kwd">search</span><span class="opt">(</span>masks<span class="opt">,</span> board <span class="opt">| *</span>m<span class="opt">,</span> i <span class="opt">+</span> <span class="num">1</span><span class="opt">,</span> List<span class="opt">::</span><span class="kwd">Cons</span><span class="opt">(*</span>m<span class="opt">, &amp;</span>cur<span class="opt">),</span> data<span class="opt">);</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="kwa">fn</span> <span class="kwd">par_search</span><span class="opt">(</span>masks<span class="opt">:</span> Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span>Vec<span class="opt">&lt;</span><span class="kwb">u64</span><span class="opt">&gt;&gt;&gt;) -&gt;</span> Data <span class="opt">{</span>
    <span class="kwa">let</span> masks <span class="opt">=</span> Arc<span class="opt">::</span><span class="kwd">new</span><span class="opt">(</span>masks<span class="opt">);</span>
    <span class="kwa">let</span> <span class="opt">(</span>tx<span class="opt">,</span> rx<span class="opt">) =</span> <span class="kwd">channel</span><span class="opt">();</span>

    <span class="slc">// launching the search in parallel on every masks at minimum</span>
    <span class="slc">// coordinate (0,0)</span>
    <span class="kwa">for</span> <span class="opt">&amp;</span>m <span class="kwa">in</span> masks<span class="opt">[</span><span class="num">0</span><span class="opt">]</span><span class="num">.i</span>ter<span class="opt">()</span><span class="num">.f</span>lat<span class="num">_</span>map<span class="opt">(|</span>masks_pos<span class="opt">|</span> masks_pos<span class="num">.i</span>ter<span class="opt">()) {</span>
        <span class="kwa">let</span> masks <span class="opt">=</span> masks<span class="opt">.</span><span class="kwd">clone</span><span class="opt">();</span>
        <span class="kwa">let</span> tx <span class="opt">=</span> tx<span class="opt">.</span><span class="kwd">clone</span><span class="opt">();</span>
        <span class="kwd">spawn</span><span class="opt">(</span><span class="kwa">move</span><span class="opt">|| {</span>
            <span class="kwa">let mut</span> data <span class="opt">=</span> Data<span class="opt">::</span><span class="kwd">new</span><span class="opt">();</span>
            <span class="kwd">search</span><span class="opt">(&amp;</span>masks<span class="opt">,</span> m<span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> List<span class="opt">::</span><span class="kwd">Cons</span><span class="opt">(</span>m<span class="opt">, &amp;</span>List<span class="opt">::</span>Nil<span class="opt">), &amp;</span><span class="kwa">mut</span> data<span class="opt">);</span>
            tx<span class="opt">.</span><span class="kwd">send</span><span class="opt">(</span>data<span class="opt">)</span><span class="num">.u</span>nwrap<span class="opt">();</span>
        <span class="opt">});</span>
    <span class="opt">}</span>

    <span class="slc">// collecting the results</span>
    <span class="kwd">drop</span><span class="opt">(</span>tx<span class="opt">);</span>
    <span class="kwa">let mut</span> data <span class="opt">=</span> rx<span class="opt">.</span><span class="kwd">recv</span><span class="opt">()</span><span class="num">.u</span>nwrap<span class="opt">();</span>
    <span class="kwa">for</span> d <span class="kwa">in</span> rx<span class="num">.i</span>ter<span class="opt">() {</span> data<span class="opt">.</span><span class="kwd">reduce_from</span><span class="opt">(</span>d<span class="opt">); }</span>
    data
<span class="opt">}</span>

<span class="kwa">fn</span> <span class="kwd">main</span> <span class="opt">() {</span>
    <span class="kwa">let mut</span> masks <span class="opt">=</span> <span class="kwd">make_masks</span><span class="opt">();</span>
    <span class="kwd">filter_masks</span><span class="opt">(&amp;</span><span class="kwa">mut</span> masks<span class="opt">);</span>
    <span class="kwa">let</span> data <span class="opt">=</span> <span class="kwd">par_search</span><span class="opt">(</span>masks<span class="opt">);</span>
    println<span class="opt">!(</span><span class="str">&quot;{} solutions found&quot;</span><span class="opt">,</span> data<span class="opt">.</span>nb<span class="opt">);</span>
    <span class="kwd">print_sol</span><span class="opt">(&amp;</span>data<span class="opt">.</span>min<span class="opt">);</span>
    <span class="kwd">print_sol</span><span class="opt">(&amp;</span>data<span class="opt">.</span>max<span class="opt">);</span>
    println<span class="opt">!(</span><span class="str">&quot;&quot;</span><span class="opt">);</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
rustc 1.25.0 (84203cac6 2018-03-25)


Thu, 29 Mar 2018 17:00:48 GMT

MAKE:
/opt/src/rust-1.25.0/bin/rustc -C opt-level=3 -C target-cpu=core2 -C lto -C codegen-units=1  meteor.rs -o meteor.rust_run
rm meteor.rs

9.40s to complete and log all make actions

COMMAND LINE:
./meteor.rust_run 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

