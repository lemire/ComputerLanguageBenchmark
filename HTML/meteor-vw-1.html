<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Smalltalk VW program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Smalltalk VW program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">&quot;* The Computer Language Benchmarks Game</span>
<span class="com">    http://benchmarksgame.alioth.debian.org/</span>
<span class="com">    contributed by Nicolas Cellier *&quot;</span>!


<span class="kwc">Smalltalk</span> <span class="kwb">defineClass:</span> <span class="kwd">#MeteorPiece</span>
	<span class="kwb">superclass:</span> #{<span class="kwc">Core</span>.<span class="kwc">Object</span>}
	<span class="kwb">indexedType:</span> <span class="kwd">#none</span>
	<span class="kwb">private:</span> <span class="kwa">false</span>
	<span class="kwb">instanceVariableNames:</span> <span class="str">'mask row '</span>
	<span class="kwb">classInstanceVariableNames:</span> <span class="str">''</span>
	<span class="kwb">imports:</span> <span class="str">''</span>
	<span class="kwb">category:</span> <span class="str">''</span>!

<span class="kwc">Smalltalk</span> <span class="kwb">defineClass:</span> <span class="kwd">#MeteorPieceWithIsland</span>
	<span class="kwb">superclass:</span> #{<span class="kwc">Smalltalk</span>.<span class="kwc">MeteorPiece</span>}
	<span class="kwb">indexedType:</span> <span class="kwd">#none</span>
	<span class="kwb">private:</span> <span class="kwa">false</span>
	<span class="kwb">instanceVariableNames:</span> <span class="str">'islands aPieceCouldFitIntoIsland '</span>
	<span class="kwb">classInstanceVariableNames:</span> <span class="str">''</span>
	<span class="kwb">imports:</span> <span class="str">''</span>
	<span class="kwb">category:</span> <span class="str">''</span>!

<span class="kwc">Smalltalk</span> <span class="kwb">defineClass:</span> <span class="kwd">#MeteorBoard</span>
	<span class="kwb">superclass:</span> #{<span class="kwc">Core</span>.<span class="kwc">Object</span>}
	<span class="kwb">indexedType:</span> <span class="kwd">#none</span>
	<span class="kwb">private:</span> <span class="kwa">false</span>
	<span class="kwb">instanceVariableNames:</span> <span class="str">'pieces ncol ncell twoRows sixRows oddRowsMask evenRowsMask southEdge eastEdge westEdge southToNorthMasks eastToWestMasks northWestMask northEastMask southWestMask southEastMask positionsPerPiece loopCount fillMask '</span>
	<span class="kwb">classInstanceVariableNames:</span> <span class="str">''</span>
	<span class="kwb">imports:</span> <span class="str">''</span>
	<span class="kwb">category:</span> <span class="str">''</span>!

<span class="kwc">Smalltalk</span>.<span class="kwc">Core</span> <span class="kwb">defineClass:</span> <span class="kwd">#BenchmarksGame</span>
	<span class="kwb">superclass:</span> #{<span class="kwc">Core</span>.<span class="kwc">Object</span>}
	<span class="kwb">indexedType:</span> <span class="kwd">#none</span>
	<span class="kwb">private:</span> <span class="kwa">false</span>
	<span class="kwb">instanceVariableNames:</span> <span class="str">''</span>
	<span class="kwb">classInstanceVariableNames:</span> <span class="str">''</span>
	<span class="kwb">imports:</span> <span class="str">''</span>
	<span class="kwb">category:</span> <span class="str">''</span>!

!<span class="kwc">MeteorPiece</span> class <span class="kwb">methodsFor:</span> <span class="str">'instance creation'</span>!

<span class="kwb">mask:</span> p <span class="kwb">islands:</span> i
    ^i <span class="kwb">=</span> <span class="num">0</span>
        <span class="kwb">ifTrue:</span> [<span class="kwc">MeteorPiece</span> new <span class="kwb">mask:</span> p]
        <span class="kwb">ifFalse:</span> [<span class="kwc">MeteorPieceWithIsland</span> new <span class="kwb">mask:</span> p; <span class="kwb">islands:</span> i]! !


!<span class="kwc">MeteorPiece</span> <span class="kwb">methodsFor:</span> <span class="str">'accessing'</span>!

<span class="kwb">mask</span>
    ^mask!

<span class="kwb">fillSolution:</span> aString <span class="kwb">ncol:</span> ncol <span class="kwb">withColor:</span> c 
    <span class="kwd">| offset |</span>
    offset :<span class="kwb">=</span> row <span class="kwb">*</span> ncol.
    mask <span class="kwb">bitsDo:</span> [<span class="kwd">:k</span> | aString <span class="kwb">at:</span> offset <span class="kwb">+</span> k <span class="kwb">put:</span> c]! !

!<span class="kwc">MeteorPiece</span> <span class="kwb">methodsFor:</span> <span class="str">'testing'</span>!

<span class="kwb">fitOnBoard:</span> aBoardMask
    ^<span class="num">0</span> <span class="kwb">==</span> (aBoardMask <span class="kwb">bitAnd:</span> mask)! !

!<span class="kwc">MeteorPiece</span> <span class="kwb">methodsFor:</span> <span class="str">'initialize-release'</span>!

<span class="kwb">forRow:</span> rowOffset
    row :<span class="kwb">=</span> rowOffset!

<span class="kwb">mask:</span> aPieceMask
    mask :<span class="kwb">=</span> aPieceMask! !


!<span class="kwc">MeteorPieceWithIsland</span> <span class="kwb">methodsFor:</span> <span class="str">'testing'</span>!

<span class="kwb">fitOnBoard:</span> aBoardMask
    <span class="kwd">| occupied |</span>
    ^<span class="num">0</span> <span class="kwb">==</span> (aBoardMask <span class="kwb">bitAnd:</span> mask) <span class="kwb">and:</span>
        [(occupied :<span class="kwb">=</span> aBoardMask <span class="kwb">bitAnd:</span> islands) <span class="kwb">=</span> islands
            <span class="kwb">or:</span> [aPieceCouldFitIntoIsland <span class="kwb">and:</span> [(islands <span class="kwb">-</span> occupied) bitCount <span class="kwb">=</span> <span class="num">5</span>]]]! !

!<span class="kwc">MeteorPieceWithIsland</span> <span class="kwb">methodsFor:</span> <span class="str">'initialize-release'</span>!

<span class="kwb">islands:</span> islandMask
    islands :<span class="kwb">=</span> islandMask.
    aPieceCouldFitIntoIsland :<span class="kwb">=</span> islands bitCount <span class="kwb">&gt;=</span> <span class="num">5</span>! !


!<span class="kwc">MeteorBoard</span> class <span class="kwb">methodsFor:</span> <span class="str">'instance creation'</span>!

<span class="kwb">default</span>
    ^<span class="kwa">self</span> basicNew <span class="kwb">fromString:</span>
<span class="str">'0 0 0 0 1 </span>
<span class="str"> 2 2 2 0 1 </span>
<span class="str">2 6 6 1 1 </span>
<span class="str"> 2 6 1 5 5 </span>
<span class="str">8 6 5 5 5 </span>
<span class="str"> 8 6 3 3 3 </span>
<span class="str">4 8 8 9 3 </span>
<span class="str"> 4 4 8 9 3 </span>
<span class="str">4 7 4 7 9 </span>
<span class="str"> 7 7 7 9 9'</span>! !


!<span class="kwc">MeteorBoard</span> <span class="kwb">methodsFor:</span> <span class="str">'solving'</span>!

<span class="kwb">boardStringWithPieces:</span> pArray
    <span class="kwd">| board |</span>
    board :<span class="kwb">=</span> <span class="kwc">String</span> <span class="kwb">new:</span> ncell.
    <span class="num">1</span> <span class="kwb">to:</span> pArray size <span class="kwb">do:</span> [<span class="kwd">:i</span> | <span class="kwd">| c |</span>
        c :<span class="kwb">=</span> <span class="str">'0123456789*'</span> <span class="kwb">at:</span> i.
        (pArray <span class="kwb">at:</span> i) <span class="kwb">fillSolution:</span> board <span class="kwb">ncol:</span> ncol <span class="kwb">withColor:</span> c].
    ^board!

<span class="kwb">solvedPuzzleDo:</span> solutionBlock
    loopCount :<span class="kwb">=</span> <span class="num">0</span>.
    <span class="kwa">self</span>
        <span class="kwb">searchPuzzlesWithColorMask:</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> pieces size) <span class="kwb">-</span> <span class="num">1</span>
        <span class="kwb">boardMask:</span> <span class="num">0</span>
        <span class="kwb">rowOffset:</span> <span class="num">0</span>
        <span class="kwb">pieces:</span> pieces copy
        <span class="kwb">ifFound:</span> [<span class="kwd">:solution</span> |
            solutionBlock <span class="kwb">value:</span> solution; <span class="kwb">value:</span> solution reverse].
    ^loopCount!

<span class="kwb">searchPuzzlesWithColorMask:</span> colorMask <span class="kwb">boardMask:</span> bMask <span class="kwb">rowOffset:</span> rowOff <span class="kwb">pieces:</span> pArray <span class="kwb">ifFound:</span> solutionBlock
    <span class="kwd">| nextFreeCell possibles colorBit iRow boardMask |</span>
    colorMask <span class="kwb">=</span> <span class="num">0</span> <span class="kwb">ifTrue:</span> [ ^solutionBlock <span class="kwb">value:</span> (<span class="kwa">self</span> <span class="kwb">boardStringWithPieces:</span> pieces) ].
    loopCount :<span class="kwb">=</span> loopCount <span class="kwb">+</span> <span class="num">1</span>.
    boardMask :<span class="kwb">=</span> bMask.
    iRow :<span class="kwb">=</span> rowOff.
    [(nextFreeCell :<span class="kwb">=</span> (boardMask <span class="kwb">+</span> <span class="num">1</span>) lowBit) &gt; twoRows]
        <span class="kwb">whileTrue:</span>
            [ iRow :<span class="kwb">=</span> iRow <span class="kwb">+</span> <span class="num">2</span>.
            boardMask :<span class="kwb">=</span> boardMask <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span> twoRows ].
    possibles :<span class="kwb">=</span> (positionsPerPiece <span class="kwb">at:</span> iRow <span class="kwb">//</span> <span class="num">2</span> <span class="kwb">+</span> <span class="num">1</span>) <span class="kwb">at:</span> nextFreeCell.
    colorBit :<span class="kwb">=</span> <span class="num">1</span>.
    <span class="num">1</span> <span class="kwb">to:</span> pieces size <span class="kwb">do:</span> [<span class="kwd">:pieceNumber</span> |
        (colorMask <span class="kwb">bitAnd:</span> colorBit) <span class="kwb">=</span> <span class="num">0</span>
            <span class="kwb">ifFalse:</span>
                [ <span class="kwd">| positions |</span>
                positions :<span class="kwb">=</span> possibles <span class="kwb">at:</span> pieceNumber.
                <span class="num">1</span> <span class="kwb">to:</span> positions size <span class="kwb">do:</span> [<span class="kwd">:i</span> |
                    <span class="kwd">| aPiece |</span>
                    ((aPiece :<span class="kwb">=</span> positions <span class="kwb">at:</span> i) <span class="kwb">fitOnBoard:</span> boardMask)
                        <span class="kwb">ifTrue:</span>
                            [pieces <span class="kwb">at:</span> pieceNumber <span class="kwb">put:</span> (aPiece <span class="kwb">forRow:</span> iRow).
                            <span class="kwa">self</span>
                                <span class="kwb">searchPuzzlesWithColorMask:</span> colorMask <span class="kwb">-</span> colorBit
                                <span class="kwb">boardMask:</span> boardMask <span class="kwb">+</span> aPiece mask
                                <span class="kwb">rowOffset:</span> iRow
                                <span class="kwb">pieces:</span> pArray
                                <span class="kwb">ifFound:</span> solutionBlock]]].
        colorBit :<span class="kwb">=</span> colorBit <span class="kwb">*</span> <span class="num">2</span>].
    ^<span class="kwa">nil</span>! !

!<span class="kwc">MeteorBoard</span> <span class="kwb">methodsFor:</span> <span class="str">'printing'</span>!

<span class="kwb">printSolution:</span> aString <span class="kwb">on:</span> aStream
    <span class="kwd">| src i odd |</span>
    src :<span class="kwb">=</span> aString readStream.
    i :<span class="kwb">=</span> <span class="num">0</span>. odd :<span class="kwb">=</span> <span class="kwa">true</span>.
    [src atEnd]
        <span class="kwb">whileFalse:</span>
            [aStream <span class="kwb">nextPut:</span> src next; space.
            (i :<span class="kwb">=</span> i <span class="kwb">+</span> <span class="num">1</span> <span class="esc">\\</span> ncol) <span class="kwb">=</span> <span class="num">0</span>
                <span class="kwb">ifTrue:</span>
                    [aStream nl.
                    (odd :<span class="kwb">=</span> odd not)  <span class="kwb">ifFalse:</span> [aStream space]]]! !

!<span class="kwc">MeteorBoard</span> <span class="kwb">methodsFor:</span> <span class="str">'generating'</span>!

<span class="kwb">canShiftNE:</span> aPieceMask
    ^(northEastMask <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">canShiftSE:</span> aPieceMask
    ^(southEastMask <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">canShiftSW:</span> aPieceMask
    ^(southEastMask <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">shiftNE:</span> aPieceMask
    <span class="kwd">| evens odds |</span>
    odds :<span class="kwb">=</span> oddRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    evens :<span class="kwb">=</span> evenRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    ^(odds <span class="kwb">bitShift: -</span><span class="num">1</span>) <span class="kwb">+</span> evens <span class="kwb">bitShift:</span> ncol!

<span class="kwb">shiftSW:</span> aPieceMask
    <span class="kwd">| evens odds |</span>
    odds :<span class="kwb">=</span> oddRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    evens :<span class="kwb">=</span> evenRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    ^(evens <span class="kwb">bitShift:</span> <span class="num">1</span>) <span class="kwb">+</span> odds <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span> ncol!

<span class="kwb">flip:</span> aPieceMask
    ^<span class="kwa">self</span> <span class="kwb">shiftSEmost:</span> ((southToNorthMasks
        <span class="kwb">inject:</span> <span class="num">0</span> <span class="kwb">into:</span> [<span class="kwd">:mask :rowMask</span> |
            (mask <span class="kwb">bitShift:</span>  ncol) <span class="kwb">+</span> ((rowMask <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">bitShift:</span> <span class="num">1</span> <span class="kwb">-</span> rowMask lowBit)])
                <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span> ncol)!

<span class="kwb">shiftSE:</span> aPieceMask
    <span class="kwd">| evens odds |</span>
    odds :<span class="kwb">=</span> oddRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    evens :<span class="kwb">=</span> evenRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    ^(odds <span class="kwb">bitShift: -</span><span class="num">1</span>) <span class="kwb">+</span> evens <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span> ncol!

<span class="kwb">canShiftNW:</span> aPieceMask
    ^(northWestMask <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">shiftNW:</span> aPieceMask
    <span class="kwd">| evens odds |</span>
    odds :<span class="kwb">=</span> oddRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    evens :<span class="kwb">=</span> evenRowsMask <span class="kwb">bitAnd:</span> aPieceMask.
    ^(evens <span class="kwb">bitShift:</span> <span class="num">1</span>) <span class="kwb">+</span> odds <span class="kwb">bitShift:</span> ncol!

<span class="kwb">possiblePositionsOnTwoRows</span>
    ^pieces <span class="kwb">collect:</span> [<span class="kwd">:aPieceMask</span> |
        <span class="kwd">| possible iRot |</span>
        possible :<span class="kwb">=</span> (<span class="kwc">Array</span> <span class="kwb">new:</span> twoRows) <span class="kwb">collect:</span> [<span class="kwd">:freeCell</span> | <span class="kwc">Array</span> <span class="kwb">new:</span> <span class="num">12</span> <span class="kwb">withAll:</span> (<span class="kwc">MeteorPiece</span> new <span class="kwb">mask:</span> <span class="num">0</span>)].
        iRot :<span class="kwb">=</span> <span class="num">0</span>.
        <span class="kwa">self</span> <span class="kwb">rotationsOf:</span> aPieceMask <span class="kwb">do:</span> [<span class="kwd">:rotated</span> |
            iRot :<span class="kwb">=</span> iRot <span class="kwb">+</span> <span class="num">1</span>.
            <span class="kwa">self</span> <span class="kwb">placesFor:</span> rotated <span class="kwb">do:</span> [<span class="kwd">:shifted</span> |
                (possible <span class="kwb">at:</span> shifted lowBit) <span class="kwb">at:</span> iRot <span class="kwb">put:</span> (<span class="kwc">MeteorPiece</span>
                    <span class="kwb">mask:</span> ((<span class="kwa">self</span> <span class="kwb">hasEastOrWestIsland:</span> shifted) <span class="kwb">ifTrue:</span> [<span class="num">0</span>] <span class="kwb">ifFalse:</span> [shifted])
                    <span class="kwb">islands:</span> (<span class="kwa">self</span> <span class="kwb">islandsFor:</span> (shifted <span class="kwb">bitOr:</span> shifted <span class="kwb">-</span> <span class="num">1</span>)))]].
        possible]!

<span class="kwb">canShiftE:</span> aPieceMask
    ^(eastEdge <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">shiftSEmost:</span> aPieceMask
    <span class="kwd">| mostSEMask eastColumn lowBit |</span>
    aPieceMask odd <span class="kwb">ifTrue:</span> [^aPieceMask].
    lowBit :<span class="kwb">=</span> aPieceMask lowBit.
    mostSEMask :<span class="kwb">=</span> aPieceMask <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span>  (lowBit <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">//</span> twoRows <span class="kwb">*</span> twoRows).
    (mostSEMask <span class="kwb">bitAnd:</span> southEdge) <span class="kwb">=</span> <span class="num">0</span>
        <span class="kwb">ifTrue:</span> [mostSEMask :<span class="kwb">=</span> (<span class="kwa">self</span> <span class="kwb">canShiftSE:</span> mostSEMask)
            <span class="kwb">ifTrue:</span> [<span class="kwa">self</span> <span class="kwb">shiftSE:</span> mostSEMask]
            <span class="kwb">ifFalse:</span> [<span class="kwa">self</span> <span class="kwb">shiftSW:</span> mostSEMask]].
    eastColumn :<span class="kwb">=</span> eastToWestMasks <span class="kwb">findFirst:</span> [<span class="kwd">:e</span> | (e <span class="kwb">bitAnd:</span> mostSEMask) &gt; <span class="num">0</span>].
    ^mostSEMask <span class="kwb">bitShift:</span> <span class="num">1</span> <span class="kwb">-</span> eastColumn!

<span class="kwb">shiftE:</span> aPieceMask
    ^aPieceMask <span class="kwb">bitShift: -</span><span class="num">1</span>!

<span class="kwb">canShiftW:</span> aPieceMask
    ^(westEdge <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>!

<span class="kwb">placesFor:</span> aPieceMask <span class="kwb">do:</span> aBlock
    <span class="kwd">| westMask eastMask |</span>
    eastMask :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftSEmost:</span> aPieceMask.
    
    [[westMask :<span class="kwb">=</span> eastMask.
    [westMask lowBit &gt; twoRows <span class="kwb">ifTrue:</span> [^<span class="kwa">self</span>].
    (<span class="kwa">self</span> <span class="kwb">hasEastOrWestIsland:</span> westMask) <span class="kwb">ifFalse:</span> [aBlock <span class="kwb">value:</span> westMask].
    <span class="kwa">self</span> <span class="kwb">canShiftW:</span> westMask] <span class="kwb">whileTrue:</span> [westMask :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftW:</span> westMask].
    <span class="kwa">self</span> <span class="kwb">canShiftNE:</span> eastMask] <span class="kwb">whileTrue:</span> [eastMask :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNE:</span> eastMask].
    <span class="kwa">self</span> <span class="kwb">canShiftNW:</span> eastMask] <span class="kwb">whileTrue:</span> [eastMask :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNW:</span> eastMask]!

<span class="kwb">rotationsOf:</span> aPieceMask <span class="kwb">do:</span> aBlock
    <span class="kwd">| next |</span>
    aBlock <span class="kwb">value:</span> (next :<span class="kwb">=</span> aPieceMask); <span class="kwb">value:</span> (<span class="kwa">self</span> <span class="kwb">flip:</span> next).
    <span class="num">5</span> <span class="kwb">timesRepeat:</span>  [aBlock <span class="kwb">value:</span> (next :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">rotate:</span> next); <span class="kwb">value:</span> (<span class="kwa">self</span> <span class="kwb">flip:</span> next)]!

<span class="kwb">rotate:</span> aPieceMask
    <span class="kwd">| rotatedMask pivot rotatedPivot irow row |</span>
    rotatedMask :<span class="kwb">=</span> <span class="num">0</span>.
    irow :<span class="kwb">=</span> <span class="num">1</span>.
    row :<span class="kwb">=</span> aPieceMask <span class="kwb">bitAnd:</span> (southToNorthMasks <span class="kwb">at:</span> irow).
    rotatedPivot :<span class="kwb">=</span> pivot :<span class="kwb">=</span> <span class="num">1</span> <span class="kwb">bitShift:</span> row highBit <span class="kwb">-</span> <span class="num">1</span>.
    
    [rotatedMask :<span class="kwb">=</span> rotatedMask <span class="kwb">+</span> rotatedPivot.
    [(row <span class="kwb">bitAnd:</span> pivot <span class="kwb">-</span> <span class="num">1</span>) <span class="kwb">=</span> <span class="num">0</span>]
        <span class="kwb">whileFalse:</span>
            [pivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftE:</span> pivot.
            rotatedPivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNE:</span> rotatedPivot.
            (row <span class="kwb">bitAnd:</span> pivot) <span class="kwb">=</span> <span class="num">0</span>
                <span class="kwb">ifFalse:</span>
                    [rotatedMask :<span class="kwb">=</span> rotatedMask <span class="kwb">+</span> rotatedPivot]].
    (row :<span class="kwb">=</span> aPieceMask <span class="kwb">bitAnd:</span> (southToNorthMasks <span class="kwb">at:</span> (irow :<span class="kwb">=</span> irow <span class="kwb">+</span> <span class="num">1</span>))) <span class="kwb">=</span> <span class="num">0</span>]
        <span class="kwb">whileFalse:</span>
            [(<span class="kwa">self</span> <span class="kwb">canShiftNE:</span> pivot)
                <span class="kwb">ifTrue:</span>
                    [pivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNE:</span> pivot.
                    rotatedPivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNW:</span> rotatedPivot]
                <span class="kwb">ifFalse:</span>
                    [pivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftNW:</span> pivot.
                    rotatedPivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftW:</span> rotatedPivot].
            [row <span class="kwb">&gt;=</span> (pivot <span class="kwb">bitShift:</span> <span class="num">1</span>)]
                <span class="kwb">whileTrue:</span>
                    [pivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftW:</span> pivot.
                    (<span class="kwa">self</span> <span class="kwb">canShiftSW:</span> rotatedPivot)
                        <span class="kwb">ifFalse:</span>
                            [rotatedPivot :<span class="kwb">=</span> rotatedPivot <span class="kwb">bitShift:</span> twoRows.
                            rotatedMask :<span class="kwb">=</span> rotatedMask <span class="kwb">bitShift:</span> twoRows.].
                    rotatedPivot :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">shiftSW:</span> rotatedPivot]].
    ^<span class="kwa">self</span> <span class="kwb">shiftSEmost:</span> rotatedMask!

<span class="kwb">shiftW:</span> aPieceMask
    ^aPieceMask <span class="kwb">bitShift:</span> <span class="num">1</span>! !

!<span class="kwc">MeteorBoard</span> <span class="kwb">methodsFor:</span> <span class="str">'islands'</span>!

<span class="kwb">fillMaskStartingAt:</span> pos <span class="kwb">stoppingAbove:</span> maxCell <span class="kwb">ifFoundEnough:</span> exitBlock
    (fillMask <span class="kwb">bitAnd:</span> pos) <span class="kwb">=</span> <span class="num">0</span> <span class="kwb">ifFalse:</span> [^<span class="kwa">self</span>].
    (pos &gt; maxCell) <span class="kwb">ifTrue:</span> [^exitBlock value].
    fillMask :<span class="kwb">=</span> fillMask <span class="kwb">+</span> pos.
    (<span class="kwa">self</span> <span class="kwb">canShiftE:</span> pos) <span class="kwb">ifTrue:</span> [<span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> (<span class="kwa">self</span> <span class="kwb">shiftE:</span> pos) <span class="kwb">stoppingAbove:</span> maxCell <span class="kwb">ifFoundEnough:</span> exitBlock].
    (<span class="kwa">self</span> <span class="kwb">canShiftNE:</span> pos) <span class="kwb">ifTrue:</span> [<span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> (<span class="kwa">self</span> <span class="kwb">shiftNE:</span> pos) <span class="kwb">stoppingAbove:</span> maxCell <span class="kwb">ifFoundEnough:</span> exitBlock].
    (<span class="kwa">self</span> <span class="kwb">canShiftNW:</span> pos) <span class="kwb">ifTrue:</span> [<span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> (<span class="kwa">self</span> <span class="kwb">shiftNW:</span> pos) <span class="kwb">stoppingAbove:</span> maxCell <span class="kwb">ifFoundEnough:</span> exitBlock].
    (<span class="kwa">self</span> <span class="kwb">canShiftW:</span> pos) <span class="kwb">ifTrue:</span> [<span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> (<span class="kwa">self</span> <span class="kwb">shiftW:</span> pos) <span class="kwb">stoppingAbove:</span> maxCell <span class="kwb">ifFoundEnough:</span> exitBlock].
    ^<span class="kwa">self</span>!

<span class="kwb">hasEastOrWestIsland:</span> aMask
    ^ (<span class="kwa">self</span> <span class="kwb">hasInsetZero:</span> southEdge <span class="kwb">*</span> (eastEdge <span class="kwb">bitAnd:</span> aMask))
        <span class="kwb">or:</span> [(<span class="kwa">self</span> <span class="kwb">hasInsetZero:</span> southEdge <span class="kwb">*</span> (westEdge <span class="kwb">bitAnd:</span> aMask))
            <span class="kwb">or:</span> [(aMask <span class="kwb">bitAnd:</span> eastEdge) &gt; <span class="num">0</span> <span class="kwb">and:</span> [(aMask <span class="kwb">bitAnd:</span> westEdge) &gt; <span class="num">0</span> <span class="kwb">and:</span> [(<span class="kwa">self</span> <span class="kwb">findIsland:</span> aMask) bitCount <span class="esc">\\</span> <span class="num">5</span> &gt; <span class="num">0</span>]]]]!

<span class="kwb">hasInsetZero:</span> aMask
    <span class="kwd">| allOnes |</span>
    allOnes :<span class="kwb">=</span> aMask <span class="kwb">bitOr:</span> aMask <span class="kwb">-</span> <span class="num">1</span>.
    ^(allOnes <span class="kwb">bitAnd:</span> allOnes <span class="kwb">+</span> <span class="num">1</span>) &gt; <span class="num">0</span>!

<span class="kwb">findIsland:</span> aMask
    <span class="kwd">| nextFreeCellMask open |</span>
    nextFreeCellMask :<span class="kwb">=</span> <span class="num">1</span> <span class="kwb">+</span> aMask <span class="kwb">bitAnd: -</span><span class="num">1</span> <span class="kwb">-</span> aMask.
    fillMask :<span class="kwb">=</span>  aMask.
    open :<span class="kwb">=</span> <span class="kwa">false</span>.
    <span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> nextFreeCellMask <span class="kwb">stoppingAbove:</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> fillMask highBit <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">//</span> ncol <span class="kwb">*</span> ncol <span class="kwb">-</span> <span class="num">1</span>) <span class="kwb">ifFoundEnough:</span> [open :<span class="kwb">=</span> <span class="kwa">true</span>].
    ^open
        <span class="kwb">ifTrue:</span> [<span class="num">0</span>]
        <span class="kwb">ifFalse:</span> [fillMask <span class="kwb">-</span> aMask]!

<span class="kwb">northIslandsFor:</span> aPieceMask <span class="kwb">row:</span> iRow
    <span class="kwd">| filled isleSEW bitReverse isleNE isleNW |</span>
    bitReverse :<span class="kwb">=</span> (#(<span class="kwb">-</span><span class="num">1</span> <span class="kwb">-</span><span class="num">1 6 4 2</span>) <span class="kwb">at:</span> iRow) <span class="kwb">*</span> ncol.
    filled :<span class="kwb">=</span> aPieceMask <span class="kwb">bitOr:</span> aPieceMask <span class="kwb">-</span> <span class="num">1</span>.
    isleSEW :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">islandsFor:</span> filled.
    (aPieceMask <span class="kwb">bitAnd:</span> (eastEdge <span class="kwb">bitOr:</span> westEdge)) <span class="kwb">=</span> <span class="num">0</span> <span class="kwb">ifFalse:</span> [^isleSEW].
    (isleSEW <span class="kwb">bitAnd:</span> (eastEdge <span class="kwb">bitOr:</span> westEdge)) <span class="kwb">=</span> <span class="num">0</span> <span class="kwb">ifFalse:</span> [^isleSEW].
    (southEdge <span class="kwb">bitAnd:</span> aPieceMask) <span class="kwb">=</span> <span class="num">0</span>
        <span class="kwb">ifTrue:</span> [filled :<span class="kwb">=</span> (filled <span class="kwb">bitShift:</span> <span class="num">0</span> <span class="kwb">-</span> ncol) <span class="kwb">bitShift:</span> ncol].
    isleNE :<span class="kwb">=</span> ((<span class="kwa">self</span> <span class="kwb">islandsFor:</span> (filled <span class="kwb">bitReverse:</span> bitReverse)) <span class="kwb">bitReverse:</span> bitReverse) <span class="kwb">bitOr:</span> isleSEW.
    isleNW :<span class="kwb">=</span> ((<span class="num">1</span> <span class="kwb">bitShift:</span> bitReverse) <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">-</span> (isleNE <span class="kwb">bitOr:</span> (aPieceMask <span class="kwb">bitOr:</span> aPieceMask <span class="kwb">-</span> <span class="num">1</span>))) <span class="kwb">bitOr:</span> isleSEW.
    ^isleNW bitCount &lt; isleNE bitCount
        <span class="kwb">ifTrue:</span> [isleNW]
        <span class="kwb">ifFalse:</span> [isleNE]!

<span class="kwb">hasNorthIsland:</span> aPieceMask <span class="kwb">row:</span> iRow
    <span class="kwd">| bitReverse |</span>
    bitReverse :<span class="kwb">=</span> (#(<span class="kwb">-</span><span class="num">1</span> <span class="kwb">-</span><span class="num">1 6 4 2</span>) <span class="kwb">at:</span> iRow) <span class="kwb">*</span> ncol.
    ^<span class="kwa">self</span> <span class="kwb">hasSouthIsland:</span> (aPieceMask <span class="kwb">bitReverse:</span> bitReverse)!

<span class="kwb">hasSouthIsland:</span> aMask
    ^(<span class="kwa">self</span> <span class="kwb">findIsland:</span> aMask) bitCount <span class="esc">\\</span> <span class="num">5</span> &gt; <span class="num">0</span>
        <span class="kwb">or:</span> [(<span class="kwa">self</span> <span class="kwb">findIsland:</span> fillMask) bitCount <span class="esc">\\</span> <span class="num">5</span> &gt; <span class="num">0</span>]!

<span class="kwb">islandsFor:</span> aPieceMask
    <span class="kwd">| islands aMask nextFreeCellMask open top |</span>
    islands :<span class="kwb">=</span> <span class="num">0</span>.
    fillMask :<span class="kwb">=</span> aPieceMask.
    top :<span class="kwb">=</span> <span class="num">1</span> <span class="kwb">bitShift:</span> (fillMask highBit <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">//</span> ncol <span class="kwb">*</span> ncol <span class="kwb">-</span> <span class="num">1</span>).
    [(nextFreeCellMask :<span class="kwb">=</span> <span class="num">1</span> <span class="kwb">+</span> fillMask <span class="kwb">bitAnd: -</span><span class="num">1</span> <span class="kwb">-</span> fillMask) <span class="kwb">&lt;=</span> top]
        <span class="kwb">whileTrue:</span>
            [open :<span class="kwb">=</span> <span class="kwa">false</span>.
            aMask :<span class="kwb">=</span> fillMask.
            <span class="kwa">self</span> <span class="kwb">fillMaskStartingAt:</span> nextFreeCellMask <span class="kwb">stoppingAbove:</span> top <span class="kwb">ifFoundEnough:</span> [open :<span class="kwb">=</span> <span class="kwa">true</span>].
            open <span class="kwb">ifFalse:</span> [islands :<span class="kwb">=</span> islands <span class="kwb">+</span> (fillMask <span class="kwb">-</span> aMask)]].
    ^islands! !

!<span class="kwc">MeteorBoard</span> <span class="kwb">methodsFor:</span> <span class="str">'initialize-release'</span>!

<span class="kwb">initializePossiblePositions</span>
    <span class="kwd">| positionsPerPiecePerCell thePieceWhichBreakSymmetry |</span>
    positionsPerPiecePerCell :<span class="kwb">=</span> <span class="kwa">self</span> possiblePositionsOnTwoRows.
    thePieceWhichBreakSymmetry :<span class="kwb">=</span> <span class="num">6</span>.
    positionsPerPiece :<span class="kwb">=</span> (<span class="num">1</span> <span class="kwb">to:</span> <span class="num">5</span>) <span class="kwb">collect:</span> [<span class="kwd">:iRow</span> |
        <span class="kwd">| maxMaskForRow northRow |</span>
        maxMaskForRow :<span class="kwb">=</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> (#(<span class="num">6 6 6 4 2</span>) <span class="kwb">at:</span> iRow) <span class="kwb">*</span> ncol) <span class="kwb">-</span> <span class="num">1</span>.
        northRow :<span class="kwb">=</span>  southEdge <span class="kwb">bitShift:</span> ((#(<span class="kwb">-</span><span class="num">1</span> <span class="kwb">-</span><span class="num">1 6 4 2</span>) <span class="kwb">at:</span> iRow) <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">*</span> ncol).
        (<span class="num">1</span> <span class="kwb">to:</span> twoRows) <span class="kwb">collect:</span> [<span class="kwd">:cellNumber</span> |
            (<span class="num">1</span> <span class="kwb">to:</span> pieces size) <span class="kwb">collect:</span> [<span class="kwd">:pieceNumber</span> |
                <span class="kwd">| orientations n str |</span>
                orientations :<span class="kwb">=</span> (positionsPerPiecePerCell <span class="kwb">at:</span> pieceNumber) <span class="kwb">at:</span> cellNumber.
                n :<span class="kwb">=</span> pieceNumber <span class="kwb">=</span> thePieceWhichBreakSymmetry <span class="kwb">ifTrue:</span> [<span class="num">6</span>] <span class="kwb">ifFalse:</span> [<span class="num">12</span>].
                str :<span class="kwb">=</span> (<span class="kwc">Array</span> <span class="kwb">new:</span> n) writeStream.
                <span class="num">1</span> <span class="kwb">to:</span> n <span class="kwb">do:</span> [<span class="kwd">:i</span> |
                    <span class="kwd">| aPiece |</span>
                    aPiece :<span class="kwb">=</span> orientations <span class="kwb">at:</span> i.
                    (aPiece mask &gt; <span class="num">0</span> <span class="kwb">and:</span> [aPiece mask <span class="kwb">&lt;=</span> maxMaskForRow])
                        <span class="kwb">ifTrue:</span>
                            [(iRow <span class="kwb">=</span> <span class="num">1</span> <span class="kwb">and:</span> [cellNumber <span class="kwb">&lt;=</span> ncol])
                                <span class="kwb">ifTrue:</span> [(<span class="kwa">self</span> <span class="kwb">hasSouthIsland:</span> aPiece mask)
                                    <span class="kwb">ifFalse:</span> [str <span class="kwb">nextPut:</span> (<span class="kwc">MeteorPiece</span> <span class="kwb">mask:</span> aPiece mask <span class="kwb">islands:</span> <span class="num">0</span>)]]
                                <span class="kwb">ifFalse:</span> [(aPiece mask <span class="kwb">bitAnd:</span> northRow) &gt; <span class="num">0</span>
                                    <span class="kwb">ifTrue:</span> [(<span class="kwa">self</span> <span class="kwb">hasNorthIsland:</span> aPiece mask <span class="kwb">row:</span> iRow)
                                        <span class="kwb">ifFalse:</span>
                                            [<span class="kwd">| isle |</span>
                                            isle :<span class="kwb">=</span> iRow <span class="kwb">=</span> <span class="num">5</span>
                                                <span class="kwb">ifTrue:</span> [<span class="num">0</span>]
                                                <span class="kwb">ifFalse:</span> [<span class="kwa">self</span> <span class="kwb">northIslandsFor:</span> aPiece mask <span class="kwb">row:</span> iRow].
                                            str <span class="kwb">nextPut:</span> (<span class="kwc">MeteorPiece</span> <span class="kwb">mask:</span> aPiece mask <span class="kwb">islands:</span> isle)]]
                                    <span class="kwb">ifFalse:</span> [str <span class="kwb">nextPut:</span> aPiece]]]].
                str contents]]]!

<span class="kwb">fromString:</span> aString
    <span class="kwd">| rawString |</span>
    rawString :<span class="kwb">=</span> aString <span class="kwb">reject:</span> [<span class="kwd">:e</span> | e isSeparator].
    ncell :<span class="kwb">=</span> rawString size.
    ncol :<span class="kwb">=</span> <span class="num">0</span>.
    (aString readStream <span class="kwb">upTo:</span> <span class="kwc">Character</span> cr) <span class="kwb">do:</span> [<span class="kwd">:e</span> | e isSeparator <span class="kwb">ifFalse:</span> [ncol :<span class="kwb">=</span> ncol <span class="kwb">+</span> <span class="num">1</span>]].
    twoRows :<span class="kwb">=</span> ncol <span class="kwb">*</span> <span class="num">2</span>.
    sixRows :<span class="kwb">=</span> ncol <span class="kwb">*</span> <span class="num">6</span>.
    <span class="kwa">self</span> initializeRowColMasks.
    pieces :<span class="kwb">=</span> rawString asSet sorted <span class="kwb">collect:</span> [<span class="kwd">:char</span> |
        <span class="kwa">self</span> <span class="kwb">shiftSEmost:</span>
            (rawString <span class="kwb">inject:</span> <span class="num">0</span> <span class="kwb">into:</span> [<span class="kwd">:pmask :c</span> | pmask <span class="kwb">*</span> <span class="num">2</span> <span class="kwb">+</span> (c <span class="kwb">=</span> char <span class="kwb">ifTrue:</span> [<span class="num">1</span>] <span class="kwb">ifFalse:</span> [<span class="num">0</span>])])].
    <span class="kwa">self</span> initializePossiblePositions!

<span class="kwb">initializeRowColMasks</span>
    southEdge :<span class="kwb">=</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> ncol) <span class="kwb">-</span> <span class="num">1</span>.
    southToNorthMasks :<span class="kwb">=</span> (<span class="num">0</span> <span class="kwb">to:</span> <span class="num">5</span>) <span class="kwb">collect:</span> [<span class="kwd">:i</span> | southEdge <span class="kwb">bitShift:</span> ncol <span class="kwb">*</span> i].
    eastEdge :<span class="kwb">=</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> sixRows)<span class="kwb">-</span><span class="num">1</span><span class="kwb">/</span>southEdge.
    eastToWestMasks :<span class="kwb">=</span> (<span class="num">0</span> <span class="kwb">to:</span> ncol <span class="kwb">-</span> <span class="num">1</span>) <span class="kwb">collect:</span> [<span class="kwd">:i</span> | eastEdge <span class="kwb">bitShift:</span> i].
    westEdge :<span class="kwb">=</span> eastToWestMasks last.
    oddRowsMask :<span class="kwb">=</span> (<span class="num">1</span> <span class="kwb">bitShift:</span> sixRows)<span class="kwb">-</span><span class="num">1</span><span class="kwb">/</span>((<span class="num">1</span> <span class="kwb">bitShift:</span> twoRows)<span class="kwb">-</span><span class="num">1</span>)<span class="kwb">*</span>southEdge.
    evenRowsMask :<span class="kwb">=</span> oddRowsMask <span class="kwb">bitShift:</span> ncol.
    northWestMask :<span class="kwb">=</span> westEdge <span class="kwb">bitAnd:</span> evenRowsMask.
    northEastMask :<span class="kwb">=</span> eastEdge <span class="kwb">bitAnd:</span> oddRowsMask.
    southWestMask :<span class="kwb">=</span> southEdge <span class="kwb">bitOr:</span> (westEdge <span class="kwb">bitAnd:</span> evenRowsMask).
    southEastMask :<span class="kwb">=</span> southEdge <span class="kwb">bitOr:</span> (eastEdge <span class="kwb">bitAnd:</span> oddRowsMask).! !


!<span class="kwc">Core</span>.<span class="kwc">BenchmarksGame</span> class <span class="kwb">methodsFor:</span> <span class="str">'private'</span>!

<span class="kwb">meteor:</span> nMax <span class="kwb">to:</span> outputStream
    <span class="kwd">| board count minSolution maxSolution |</span>
    count :<span class="kwb">=</span> <span class="num">0</span>.
    minSolution :<span class="kwb">=</span> <span class="kwc">String</span> <span class="kwb">new:</span> <span class="num">50</span> <span class="kwb">withAll:</span> <span class="num">$9</span>.
    maxSolution :<span class="kwb">=</span> <span class="kwc">String</span> <span class="kwb">new:</span> <span class="num">50</span> <span class="kwb">withAll:</span> <span class="num">$0</span>.
    (board :<span class="kwb">=</span> <span class="kwc">MeteorBoard</span> default) <span class="kwb">solvedPuzzleDo:</span>
        [<span class="kwd">:aString</span> |
            count :<span class="kwb">=</span> count <span class="kwb">+</span> <span class="num">1</span>.
            aString &lt; minSolution <span class="kwb">ifTrue:</span> [minSolution :<span class="kwb">=</span> aString].
            aString &gt; maxSolution <span class="kwb">ifTrue:</span> [maxSolution :<span class="kwb">=</span> aString]]. 
    outputStream <span class="kwb">print:</span> count; <span class="kwb">nextPutAll:</span> <span class="str">' solutions found'</span>; nl; nl.
    board <span class="kwb">printSolution:</span> minSolution <span class="kwb">on:</span> outputStream.
    outputStream nl.
    board <span class="kwb">printSolution:</span> maxSolution <span class="kwb">on:</span> outputStream.
    outputStream nl.! !

!<span class="kwc">Core</span>.<span class="kwc">BenchmarksGame</span> class <span class="kwb">methodsFor:</span> <span class="str">'initialize-release'</span>!

<span class="kwb">program</span>
    <span class="kwd">| n |</span>
    n :<span class="kwb">=</span> <span class="kwc">CEnvironment</span> commandLine last asNumber.
    <span class="kwa">self</span> <span class="kwb">meteor:</span> n <span class="kwb">to:</span> <span class="kwc">Stdout</span>.
    ^<span class="str">''</span>! !

!<span class="kwc">Core</span>.<span class="kwc">Integer</span> <span class="kwb">methodsFor:</span> <span class="str">'bit manipulation'</span>!

<span class="kwb">bitCount</span>
    <span class="kwd">| count remainder |</span>
    count :<span class="kwb">=</span> <span class="num">0</span>.
    remainder :<span class="kwb">=</span> <span class="kwa">self</span>.
    [count :<span class="kwb">=</span> count <span class="kwb">+</span> (remainder <span class="kwb">bitAnd:</span> <span class="num">255</span>) bitCountOfByte.
    remainder &gt; <span class="num">255</span>]
        <span class="kwb">whileTrue:</span>
            [remainder :<span class="kwb">=</span> remainder <span class="kwb">bitShift: -</span><span class="num">8</span>].
    ^count!

<span class="kwb">bitReverse:</span> highBit 
    <span class="kwd">| v r s |</span>
    highBit &lt; <span class="kwa">self</span> highBit <span class="kwb">ifTrue:</span> [ <span class="kwa">self</span> <span class="kwb">error:</span> <span class="str">'Not enough bits.'</span> ].
    v :<span class="kwb">=</span> <span class="kwa">self</span>.
    r :<span class="kwb">=</span> v <span class="kwb">bitAnd:</span> <span class="num">1</span>.
    s :<span class="kwb">=</span> highBit <span class="kwb">-</span> <span class="num">1</span>.
    [ v :<span class="kwb">=</span> v <span class="kwb">bitShift: -</span><span class="num">1</span>.
    v <span class="kwb">=</span> <span class="num">0</span> ] <span class="kwb">whileFalse:</span>
        [ r :<span class="kwb">=</span> r <span class="kwb">bitShift:</span> <span class="num">1</span>.
        r :<span class="kwb">=</span> r <span class="kwb">bitOr:</span> (v <span class="kwb">bitAnd:</span> <span class="num">1</span>).
        s :<span class="kwb">=</span> s <span class="kwb">-</span> <span class="num">1</span> ].
    ^ r <span class="kwb">bitShift:</span> s!

<span class="kwb">bitsDo:</span> aBlock
    <span class="kwd">| mask |</span>
    <span class="kwa">self</span> &lt; <span class="num">0</span> <span class="kwb">ifTrue:</span> [^<span class="kwa">self</span> <span class="kwb">error:</span> <span class="str">'Cannot enumerate bits of a negative integer'</span>].
    mask :<span class="kwb">=</span> <span class="kwa">self</span>.
    [mask <span class="kwb">=</span> <span class="num">0</span>]
        <span class="kwb">whileFalse:</span>
            [aBlock <span class="kwb">value:</span> mask lowBit.
            mask :<span class="kwb">=</span> mask <span class="kwb">bitAnd:</span> mask <span class="kwb">-</span> <span class="num">1</span>]! !


!<span class="kwc">Core</span>.<span class="kwc">SmallInteger</span> <span class="kwb">methodsFor:</span> <span class="str">'bit manipulation'</span>!

<span class="kwb">bitCountOfByte</span>
    <span class="com">&quot;Count the number of bits set to 1 in a byte.&quot;</span>

    ^#[<span class="num">0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4</span>
       <span class="num">1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5</span>
       <span class="num">1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7</span>
       <span class="num">1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7</span>
       <span class="num">2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6</span>
       <span class="num">3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7</span>
       <span class="num">3 4 4 5 4 5 5 6 4 5 5 6 5 6 6 7</span>
       <span class="num">4 5 5 6 5 6 6 7 5 6 6 7 6 7 7 8</span>] <span class="kwb">at:</span> <span class="kwa">self</span> <span class="kwb">+</span> <span class="num">1</span>

    <span class="com">&quot;Evaluate this expression to form above byte array:</span>
<span class="com">    ((0 to: 255)</span>
<span class="com">        collect: [:i | </span>
<span class="com">            | bitCount n |</span>
<span class="com">            n := i.</span>
<span class="com">            bitCount := 0.</span>
<span class="com">            [n = 0]</span>
<span class="com">                whileFalse:</span>
<span class="com">                    [bitCount := bitCount + 1.</span>
<span class="com">                    n := n bitAnd: n - 1].</span>
<span class="com">            bitCount]</span>
<span class="com">        as: ByteArray)&quot;</span>!

<span class="kwb">byteReversed</span>
    <span class="com">&quot;Answer the receiver with bits reversed in a byte.</span>
<span class="com">    The receiver must be between 0 and 255.</span>
<span class="com">    The constant has been obtained by this snippet:</span>
<span class="com">    (0 to: 255) collect: [:e |</span>
<span class="com">        | r |</span>
<span class="com">        r := ((e bitAnd: 2r11110000) bitShift: -4) + ((e bitAnd: 2r00001111) bitShift: 4).</span>
<span class="com">        r := ((r bitAnd: 2r11001100) bitShift: -2) + ((r bitAnd: 2r00110011) bitShift: 2).</span>
<span class="com">        ((r bitAnd: 2r10101010) bitShift: -1) + ((r bitAnd: 2r01010101) bitShift: 1).] as: ByteArray&quot;</span>
    
    ^#[  <span class="num">0 128  64 192  32 160  96 224  16 144  80 208  48 176 112 240</span>
         <span class="num">8 136  72 200  40 168 104 232  24 152  88 216  56 184 120 248</span>
         <span class="num">4 132  68 196  36 164 100 228  20 148  84 212  52 180 116 244</span>
        <span class="num">12 140  76 204  44 172 108 236  28 156  92 220  60 188 124 252</span>
         <span class="num">2 130  66 194  34 162  98 226  18 146  82 210  50 178 114 242</span>
        <span class="num">10 138  74 202  42 170 106 234  26 154  90 218  58 186 122 250</span>
         <span class="num">6 134  70 198  38 166 102 230  22 150  86 214  54 182 118 246</span>
        <span class="num">14 142  78 206  46 174 110 238  30 158  94 222  62 190 126 254</span>
         <span class="num">1 129  65 193  33 161  97 225  17 145  81 209  49 177 113 241</span>
         <span class="num">9 137  73 201  41 169 105 233  25 153  89 217  57 185 121 249</span>
         <span class="num">5 133  69 197  37 165 101 229  21 149  85 213  53 181 117 245</span>
        <span class="num">13 141  77 205  45 173 109 237  29 157  93 221  61 189 125 253</span>
         <span class="num">3 131  67 195  35 163  99 227  19 147  83 211  51 179 115 243</span>
        <span class="num">11 139  75 203  43 171 107 235  27 155  91 219  59 187 123 251</span>
         <span class="num">7 135  71 199  39 167 103 231  23 151  87 215  55 183 119 247</span>
        <span class="num">15 143  79 207  47 175 111 239  31 159  95 223  63 191 127 255</span>] <span class="kwb">at:</span> <span class="num">1</span> <span class="kwb">+</span> <span class="kwa">self</span>! !


!<span class="kwc">Core</span>.<span class="kwc">LargePositiveInteger</span> <span class="kwb">methodsFor:</span> <span class="str">'bit manipulation'</span>!

<span class="kwb">bitReverse:</span> highBit 
    <span class="com">&quot;This implementation is faster than super&quot;</span>
    
    <span class="kwd">| digitSize reversed |</span>
    highBit &lt; <span class="kwa">self</span> highBit <span class="kwb">ifTrue:</span> [ <span class="kwa">self</span> <span class="kwb">error:</span> <span class="str">'Not enough bits.'</span> ].
    digitSize :<span class="kwb">=</span> highBit <span class="kwb">+</span> <span class="num">7</span> <span class="kwb">//</span> <span class="num">8</span>.
    reversed :<span class="kwb">=</span> <span class="kwa">self</span> class <span class="kwb">basicNew:</span> digitSize.
    <span class="num">1</span> <span class="kwb">to:</span> <span class="kwa">self</span> digitLength <span class="kwb">do:</span> [<span class="kwd">:i</span> |
        reversed <span class="kwb">digitAt:</span> digitSize <span class="kwb">+</span> <span class="num">1</span> <span class="kwb">-</span> i <span class="kwb">put:</span> (<span class="kwa">self</span> <span class="kwb">digitAt:</span> i) byteReversed].
    ^reversed <span class="kwb">bitShift:</span> highBit <span class="kwb">-</span> (digitSize <span class="kwb">*</span> <span class="num">8</span>)!

<span class="kwb">bitsDo:</span> aBlock
    <span class="kwd">| mask offset |</span>
    <span class="num">1</span> <span class="kwb">to:</span> <span class="kwa">self</span> digitLength <span class="kwb">do:</span> [<span class="kwd">:iByte</span> |
        offset :<span class="kwb">=</span> iByte <span class="kwb">-</span> <span class="num">1</span> <span class="kwb">bitShift:</span> <span class="num">3</span>.
        mask :<span class="kwb">=</span> <span class="kwa">self</span> <span class="kwb">digitAt:</span> iByte.
        [mask <span class="kwb">=</span> <span class="num">0</span>]
            <span class="kwb">whileFalse:</span>
                [aBlock <span class="kwb">value:</span> mask lowBit <span class="kwb">+</span> offset.
                mask :<span class="kwb">=</span> mask <span class="kwb">bitAnd:</span> mask <span class="kwb">-</span> <span class="num">1</span>]]!

<span class="kwb">bitCount</span>
    <span class="com">&quot;Count the number of bits set to 1 in self&quot;</span>

    <span class="kwd">| bitCount |</span>
    bitCount :<span class="kwb">=</span> <span class="num">0</span>.
    <span class="num">1</span> <span class="kwb">to:</span> <span class="kwa">self</span> digitLength <span class="kwb">do:</span> [<span class="kwd">:i</span> |
        bitCount :<span class="kwb">=</span> bitCount <span class="kwb">+</span> (<span class="kwa">self</span> <span class="kwb">digitAt:</span> i) bitCountOfByte].
    ^bitCount! !

!<span class="kwc">Core</span>.<span class="kwc">Stream</span> <span class="kwb">methodsFor:</span> <span class="str">'benchmarks game'</span>!

<span class="kwb">nl</span>
   <span class="kwa">self</span> <span class="kwb">nextPut:</span> <span class="kwc">Character</span> lf! !
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
VisualWorks&#174; Personal Use Edition Release 8.2 of July 15, 2016




Tue, 02 May 2017 18:54:06 GMT

MAKE:
cp /usr/local/src/vw8.2pul/image/visualnc64.im meteor.vw_run.im
/usr/local/src/vw8.2pul/bin/linuxx86_64/vwlinuxx86_64 meteor.vw_run.im -nogui -pcl MatriX -filein meteor.vw -doit 'ObjectMemory snapshotThenQuit'

Autoloading MatriX from $(VISUALWORKS)/preview/matrix/MatriX.pcl
Autoloading Xtreams-Support from $(VISUALWORKS)/xtreams/Xtreams-Support.pcl
Autoloading Xtreams-Core from $(VISUALWORKS)/xtreams/Xtreams-Core.pcl
Autoloading Xtreams-Terminals from $(VISUALWORKS)/xtreams/Xtreams-Terminals.pcl
Autoloading Xtreams-Transforms from $(VISUALWORKS)/xtreams/Xtreams-Transforms.pcl
Autoloading Xtreams-Substreams from $(VISUALWORKS)/xtreams/Xtreams-Substreams.pcl
Autoloading Xtreams-Multiplexing from $(VISUALWORKS)/xtreams/Xtreams-Multiplexing.pcl
Filing in from:
	meteor.vw
MeteorPiece class&lt;instance creation
MeteorPiece&lt;accessing
MeteorPiece&lt;testing
MeteorPiece&lt;initialize-release
MeteorPieceWithIsland&lt;testing
MeteorPieceWithIsland&lt;initialize-release
MeteorBoard class&lt;instance creation
MeteorBoard&lt;solving
MeteorBoard&lt;printing
MeteorBoard&lt;generating
MeteorBoard&lt;islands
MeteorBoard&lt;initialize-release
BenchmarksGame class&lt;private
BenchmarksGame class&lt;initialize-release
Integer&lt;bit manipulation
Do you want to add Root.Smalltalk.Core.Integer&gt;&gt;bitCount to the previously unchanged package, Magnitude-Numbers
						OK to continue?
SmallInteger&lt;bit manipulation
LargePositiveInteger&lt;bit manipulation
Stream&lt;benchmarks game
Do you want to add Root.Smalltalk.Core.Stream&gt;&gt;nl to the previously unchanged package, Collections-Streams
						OK to continue?
/home/dunham/benchmarksgame_quadcore/meteor/tmp/meteor.vw_run.im created at May 2, 2017 11:54:05 AM
4.53s to complete and log all make actions

COMMAND LINE:
/usr/local/src/vw8.2pul/bin/linuxx86_64/vwlinuxx86_64 meteor.vw_run.im -nogui -evaluate &quot;BenchmarksGame program&quot; -a 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

