<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Chapel&nbsp;#2 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Chapel&nbsp;#2 program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com">   http://benchmarksgame.alioth.debian.org/</span>
<span class="com"></span>
<span class="com">   contributed by Kyle Brady and Ben Albrecht</span>
<span class="com">   derived from the C++ implementation by Stefan Westen</span>
<span class="com"> */</span>

<span class="kwa">use</span> BitOps<span class="opt">;</span>

<span class="kwa">param</span> boardCells <span class="opt">=</span> <span class="num">50</span><span class="opt">,</span>          <span class="slc">// Number of cells on board</span>
      boardWidth <span class="opt">=</span> <span class="num">5</span><span class="opt">,</span>           <span class="slc">// Number of cells along x-axis</span>
      boardHeight <span class="opt">=</span> <span class="num">10</span><span class="opt">,</span>         <span class="slc">// Number of cells along y-axis</span>
      totalMasks <span class="opt">=</span> <span class="num">8192</span><span class="opt">,</span>        <span class="slc">// Upper bound for allMasks needed (power of 2)</span>
      piecePermutations <span class="opt">=</span> <span class="num">12</span><span class="opt">,</span>   <span class="slc">// Number of permutations for a single piece</span>
      numPieces <span class="opt">=</span> <span class="num">10</span><span class="opt">,</span>           <span class="slc">// Number of puzzle pieces</span>
      pieceCells <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>           <span class="slc">// Number of cells that make up a puzzle piece</span>

<span class="kwa">const</span> boardDom <span class="opt">= {</span><span class="num">0</span><span class="opt">..#</span>boardCells<span class="opt">},</span>
      piecesDom <span class="opt">= {</span><span class="num">0</span><span class="opt">..#</span>numPieces<span class="opt">};</span>

<span class="slc">// Arrays of masks to store all pieces and their possible configurations</span>
<span class="kwa">var</span> allMasks<span class="opt">: [</span><span class="num">0</span><span class="opt">..#</span>totalMasks<span class="opt">]</span> <span class="kwb">int</span><span class="opt">,</span>
    maskStart<span class="opt">: [</span>boardDom<span class="opt">][</span><span class="num">0</span><span class="opt">..#</span>numPieces<span class="opt">-</span><span class="num">2</span><span class="opt">]</span> <span class="kwb">int</span><span class="opt">;</span>

<span class="slc">// Arrays of min and max, and an integer storing the number of solutions</span>
<span class="kwa">var</span> minSolution<span class="opt">,</span> maxSolution<span class="opt">: [</span>boardDom<span class="opt">]</span> <span class="kwb">int</span><span class="opt">,</span>
    solutions <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>

<span class="slc">// Masks for evens and left border</span>
<span class="kwa">var</span> evenRowsLookup<span class="opt">,</span> leftBorderLookup<span class="opt">: [</span>boardDom<span class="opt">]</span> <span class="kwb">int</span><span class="opt">;</span>

<span class="slc">// Predefined masks commonly used throughout program</span>
<span class="kwa">param</span> maskEven   <span class="opt">=</span> <span class="num">0xf07c1f07c1f07c1f</span><span class="opt">:</span> <span class="kwb">int</span><span class="opt">,</span> <span class="slc">// Even rows of board (0, 2, 4, ..)</span>
      maskBorder <span class="opt">=</span> <span class="num">0x1084210842108421</span><span class="opt">:</span> <span class="kwb">int</span><span class="opt">,</span> <span class="slc">// Right border of board</span>
      maskBoard  <span class="opt">=</span> <span class="num">0xFFFC000000000000</span><span class="opt">:</span> <span class="kwb">int</span><span class="opt">,</span> <span class="slc">// bits of board within 64-bit int</span>
      maskBottom <span class="opt">=</span> <span class="num">0x00000000003FFFFF</span><span class="opt">:</span> <span class="kwb">int</span><span class="opt">,</span> <span class="slc">// Bottom 22 elements of boards</span>
      maskUsed   <span class="opt">=</span> <span class="num">0x00000000FFC00000</span><span class="opt">:</span> <span class="kwb">int</span><span class="opt">;</span> <span class="slc">// Board + 4 additional bits</span>

<span class="slc">//</span>
<span class="slc">// Find and print the minimum and maximum solutions to meteor puzzle</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">main</span><span class="opt">(</span>args<span class="opt">: []</span> <span class="kwb">string</span><span class="opt">) {</span>

  <span class="kwc">initialize</span><span class="opt">();</span>

  <span class="kwa">sync</span> <span class="kwc">searchParallel</span><span class="opt">();</span>

  <span class="kwc">writef</span><span class="opt">(</span><span class="str">&quot;%i solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span><span class="opt">,</span> solutions<span class="opt">);</span>
  <span class="kwc">printBoard</span><span class="opt">(</span>minSolution<span class="opt">);</span>
  <span class="kwc">printBoard</span><span class="opt">(</span>maxSolution<span class="opt">);</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Set up allMasks with pre-filtered piece permutations to search</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">initialize</span><span class="opt">() {</span>

  <span class="slc">// Set up array of evens and borders masks</span>
  <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardCells <span class="opt">{</span>
    evenRowsLookup<span class="opt">[</span>i<span class="opt">] = (</span>maskEven <span class="opt">&gt;&gt;</span> i<span class="opt">);</span>
    leftBorderLookup<span class="opt">[</span>i<span class="opt">] = (</span>maskBorder <span class="opt">&gt;&gt;</span> i<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="kwa">var</span> totalCount <span class="opt">=</span> <span class="num">0</span><span class="opt">,</span>
      coords<span class="opt">: [</span><span class="num">0</span><span class="opt">..#</span>pieceCells<span class="opt">]</span> <span class="num">2</span><span class="opt">*</span><span class="kwb">int</span><span class="opt">;</span>

  <span class="com">/* The 10 puzzle pieces are defined with hexagonal cell coordinates, where</span>
<span class="com">     the first cell of a piece always begins at the origin cell, (0, 0).</span>
<span class="com">     This coordinate system is best conveyed through a diagram:</span>
<span class="com"></span>
<span class="com">                         (0, -1)       (1, -1)</span>
<span class="com"></span>
<span class="com">                  (-1, 0)       (0 , 0)       (1 , 0)</span>
<span class="com"></span>
<span class="com">                         (-1, 1)       (0 , 1)</span>
<span class="com"></span>
<span class="com">     Therefore, the cell to the South of the origin can be computed as follows:</span>
<span class="com"></span>
<span class="com">        S =    SW   +   SE</span>
<span class="com">        S = (-1, 1) + (0, 1) = (-1, 2)</span>
<span class="com"></span>
<span class="com">     The following illustrates the piece shapes and their cell indices:</span>
<span class="com"></span>
<span class="com">        Piece 0      Piece 1      Piece 2      Piece 3      Piece 4</span>
<span class="com"></span>
<span class="com">        0 1 2 3         0          0 1 2        0 1 2        0</span>
<span class="com">               4         1        3                3          1 2</span>
<span class="com">                      2 3          4                4        3   4</span>
<span class="com">                     4</span>
<span class="com"></span>
<span class="com">        Piece 5      Piece 6      Piece 7      Piece 8      Piece 9</span>
<span class="com"></span>
<span class="com">           0 1        0 1          0   1        0            0</span>
<span class="com">        2 3 4          2          2 3 4          1            1</span>
<span class="com">                      3                           2 3          2</span>
<span class="com">                       4                             4        3 4</span>
<span class="com"></span>
<span class="com">  */</span>
  <span class="kwa">const</span> pieces<span class="opt">: [</span>piecesDom<span class="opt">][</span><span class="num">0</span><span class="opt">..#</span>pieceCells<span class="opt">]</span> <span class="num">2</span><span class="opt">*</span><span class="kwb">int</span> <span class="opt">=</span>
  <span class="opt">[</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">3</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">3</span><span class="opt">,</span> <span class="num">1</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (-</span><span class="num">2</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (-</span><span class="num">3</span><span class="opt">,</span> <span class="num">3</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (-</span><span class="num">2</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">3</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (</span> <span class="num">1</span><span class="opt">,</span> <span class="num">3</span><span class="opt">)],</span>
    <span class="opt">[(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">), (</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">2</span><span class="opt">), (-</span><span class="num">1</span><span class="opt">,</span> <span class="num">3</span><span class="opt">), (</span> <span class="num">0</span><span class="opt">,</span> <span class="num">3</span><span class="opt">)]</span>
  <span class="opt">];</span>

  <span class="slc">// Generate bit mask for permutations of all pieces that fit on rows 2 &amp; 3</span>
  <span class="kwa">for</span> yBase <span class="kwa">in</span> <span class="num">2</span><span class="opt">.</span><span class="num">.3</span> <span class="opt">{</span>
    <span class="kwa">for</span> xBase <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardWidth <span class="opt">{</span>
      <span class="slc">// Compute base position for xBase, yBase coordinates</span>
      <span class="kwa">const</span> pos <span class="opt">= (</span>xBase <span class="opt">+</span> boardWidth <span class="opt">*</span> yBase<span class="opt">);</span>

      <span class="slc">// Record total number of fitted pieces at this point</span>
      maskStart<span class="opt">[</span>pos<span class="opt">][</span><span class="num">0</span><span class="opt">] =</span> totalCount<span class="opt">;</span>

      <span class="slc">// Loop over piece indices</span>
      <span class="kwa">for</span> piece <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>numPieces <span class="opt">{</span>

        <span class="slc">// Get x y coordinates of piece cells</span>
        <span class="kwa">for</span> <span class="opt">(</span>coord<span class="opt">,</span> pieceCell<span class="opt">)</span> <span class="kwa">in zip</span><span class="opt">(</span>coords<span class="opt">,</span> pieces<span class="opt">[</span>piece<span class="opt">])</span> <span class="kwa">do</span>
          coord <span class="opt">=</span> pieceCell<span class="opt">;</span>

        <span class="slc">// Loop over 12 permutations for a given piece (6 rotations * 2 flips)</span>
        <span class="kwa">for</span> currentPermutation <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>piecePermutations <span class="opt">{</span>

          <span class="slc">// Skip piece 3 and specific permutations</span>
          <span class="kwa">if</span> piece <span class="opt">!=</span> <span class="num">3</span> <span class="opt">|| (</span>currentPermutation<span class="opt">/</span><span class="num">3</span><span class="opt">) %</span> <span class="num">2</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span>

            <span class="slc">//</span>
            <span class="slc">// Overload min function to use for reduction of piece coordinates</span>
            <span class="slc">//</span>
            <span class="kwa">proc</span> <span class="kwc">min</span><span class="opt">((</span>x1<span class="opt">,</span> y1<span class="opt">), (</span>x2<span class="opt">,</span> y2<span class="opt">)) {</span>
              <span class="kwa">if</span> y1 <span class="opt">&lt;</span> y2 <span class="opt">|| (</span>y1 <span class="opt">==</span> y2 <span class="opt">&amp;&amp;</span> x1 <span class="opt">&lt;</span> x2<span class="opt">)</span> <span class="kwa">then</span>
                <span class="kwa">return</span> <span class="opt">(</span>x1<span class="opt">,</span> y1<span class="opt">);</span>
              <span class="kwa">return</span> <span class="opt">(</span>x2<span class="opt">,</span> y2<span class="opt">);</span>
            <span class="opt">}</span>

            <span class="slc">// Serial reduction to find min coords of a given permutation</span>
            <span class="kwa">var</span> <span class="opt">(</span>xMin<span class="opt">,</span> yMin<span class="opt">) =</span> min <span class="kwa">reduce for</span> c <span class="kwa">in</span> coords <span class="kwa">do</span> c<span class="opt">;</span>

            <span class="kwa">var</span> mask <span class="opt">=</span> <span class="num">0</span><span class="opt">,</span>       <span class="slc">// Bit mask representing piece&apos;s permutation</span>
                fit <span class="opt">=</span> <span class="kwa">true</span><span class="opt">;</span>     <span class="slc">// Track if piece&apos;s permutation fits board</span>

            <span class="slc">// Offsets for piece coordinates, such that &apos;island&apos; is not formed</span>
            <span class="kwa">const</span> xOff <span class="opt">= (</span>xBase <span class="opt">-</span> yBase<span class="opt">/</span><span class="num">2</span><span class="opt">) -</span> xMin<span class="opt">,</span>
                  yOff<span class="opt">=</span> yBase <span class="opt">-</span> yMin<span class="opt">;</span>

            <span class="slc">// Set bit mask for given piece&apos;s permutation if it fits on board</span>
            <span class="kwa">for</span> <span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">)</span> <span class="kwa">in</span> coords <span class="opt">{</span>

              <span class="kwa">var</span> nY <span class="opt">=</span> y <span class="opt">+</span> yOff<span class="opt">,</span>
                  nX <span class="opt">=</span> x <span class="opt">+</span> xOff <span class="opt">+</span> nY<span class="opt">/</span><span class="num">2</span><span class="opt">;</span>

              <span class="kwa">if</span> nX <span class="opt">&gt;=</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> nX <span class="opt">&lt;</span> boardWidth <span class="opt">{</span>
                <span class="kwa">const</span> numBits <span class="opt">=</span> nX <span class="opt">-</span> xBase <span class="opt">+</span> boardWidth <span class="opt">* (</span>nY <span class="opt">-</span> yBase<span class="opt">);</span>
                mask <span class="opt">|= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> numBits<span class="opt">);</span>
              <span class="opt">}</span> <span class="kwa">else</span>
                fit <span class="opt">=</span> <span class="kwa">false</span><span class="opt">;</span>
            <span class="opt">}</span>

            <span class="slc">// If it fits and is a &quot;good piece&quot;, add it to the array of masks</span>
            <span class="kwa">if</span> fit <span class="opt">{</span>
              <span class="kwa">if</span> <span class="kwc">goodPiece</span><span class="opt">(</span>mask<span class="opt">,</span> pos<span class="opt">) {</span>
                allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> mask <span class="opt">| (</span><span class="num">1</span> <span class="opt">&lt;&lt; (</span>piece <span class="opt">+</span> <span class="num">22</span><span class="opt">));</span>
                totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
              <span class="opt">}</span>
            <span class="opt">}</span>
          <span class="opt">}</span>

          <span class="slc">// Permute piece for next iteration</span>
          <span class="kwa">for</span> <span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">)</span> <span class="kwa">in</span> coords <span class="opt">{</span>
            <span class="slc">// Rotation</span>
            <span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">) = (</span>x <span class="opt">+</span> y<span class="opt">, -</span>x<span class="opt">);</span>

            <span class="slc">// Reflection</span>
            <span class="kwa">if</span> currentPermutation <span class="opt">==</span> <span class="num">5</span> <span class="kwa">then</span>
              <span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">) = (</span>x <span class="opt">+</span> y<span class="opt">, -</span>y<span class="opt">);</span>
          <span class="opt">}</span>
        <span class="opt">}</span> <span class="slc">// permutations</span>
      <span class="opt">}</span> <span class="slc">// pieces</span>

      allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> <span class="num">0</span><span class="opt">;</span>
      totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="opt">}</span> <span class="slc">// xBase</span>
  <span class="opt">}</span> <span class="slc">// yBase</span>

  <span class="slc">// Generate bit masks for translation of permutations that fit on rows 2 &amp; 3</span>
  <span class="kwa">for</span> yBase <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardHeight <span class="opt">{</span>
    <span class="slc">// Skip rows 2 &amp; 3, since we already generated their masks</span>
    <span class="kwa">if</span> yBase <span class="opt">!=</span> <span class="num">2</span> <span class="opt">&amp;&amp;</span> yBase <span class="opt">!=</span> <span class="num">3</span> <span class="opt">{</span>
      <span class="kwa">for</span> xBase <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardWidth <span class="opt">{</span>
        <span class="kwa">const</span> pos <span class="opt">= (</span>xBase <span class="opt">+</span> boardWidth <span class="opt">*</span> yBase<span class="opt">),</span>
              origPos <span class="opt">=</span> xBase <span class="opt">+</span> boardWidth <span class="opt">* (</span>yBase <span class="opt">%</span> <span class="num">2</span> <span class="opt">+</span> <span class="num">2</span><span class="opt">);</span>
        maskStart<span class="opt">[</span>pos<span class="opt">][</span><span class="num">0</span><span class="opt">] =</span> totalCount<span class="opt">;</span>
        <span class="kwa">var</span> pMask <span class="opt">=</span> maskStart<span class="opt">[</span>origPos<span class="opt">][</span><span class="num">0</span><span class="opt">];</span>
        <span class="kwa">const</span> bottom <span class="opt">= ((</span>maskBoard <span class="opt">&gt;&gt;</span> pos<span class="opt">) &amp;</span> maskBottom<span class="opt">),</span>
              lastRow <span class="opt">= ((</span>maskBoard <span class="opt">&gt;&gt; (</span>pos <span class="opt">+</span> boardWidth<span class="opt">)) &amp;</span> maskBottom<span class="opt">);</span>
        <span class="kwa">while</span> allMasks<span class="opt">[</span>pMask<span class="opt">] {</span>
          <span class="kwa">const</span> mask <span class="opt">=</span> allMasks<span class="opt">[</span>pMask<span class="opt">];</span>
          pMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
          <span class="kwa">if</span> <span class="opt">(</span>mask <span class="opt">&amp;</span> bottom<span class="opt">) ==</span> <span class="num">0</span> <span class="opt">{</span>
            <span class="kwa">if</span> <span class="opt">(</span>yBase <span class="opt">==</span> <span class="num">0</span> <span class="opt">|| ((</span>mask <span class="opt">&amp;</span> lastRow<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)) &amp;&amp;</span>
               <span class="opt">!</span><span class="kwc">goodPiece</span><span class="opt">(</span>mask <span class="opt">&amp;</span> maskBottom<span class="opt">,</span> pos<span class="opt">)</span> <span class="kwa">then</span>
              <span class="kwa">continue</span><span class="opt">;</span>

            allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> mask<span class="opt">;</span>
            totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
          <span class="opt">}</span>
        <span class="opt">}</span>
        allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> <span class="num">0</span><span class="opt">;</span>
        totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
  <span class="opt">}</span>

  <span class="kwa">for</span> filter <span class="kwa">in</span> <span class="num">1</span><span class="opt">.</span><span class="num">.7</span> <span class="opt">{</span>
    <span class="kwa">for</span> pos <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardCells <span class="opt">{</span>
      maskStart<span class="opt">[</span>pos<span class="opt">][</span>filter<span class="opt">] =</span> totalCount<span class="opt">;</span>
      <span class="kwa">const</span> filterMask <span class="opt">= ((</span>filter <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) &lt;&lt;</span> <span class="num">1</span><span class="opt">) |</span>
                         <span class="opt">((</span>filter <span class="opt">&amp;</span> <span class="num">6</span><span class="opt">) &lt;&lt; (</span><span class="num">4</span> <span class="opt">- (</span>evenRowsLookup<span class="opt">[</span>pos<span class="opt">] &amp;</span> <span class="num">1</span><span class="opt">)));</span>
      <span class="kwa">var</span> pMask <span class="opt">=</span> maskStart<span class="opt">[</span>pos<span class="opt">][</span><span class="num">0</span><span class="opt">];</span>
      <span class="kwa">while</span> allMasks<span class="opt">[</span>pMask<span class="opt">] {</span>
        <span class="kwa">const</span> mask <span class="opt">=</span> allMasks<span class="opt">[</span>pMask<span class="opt">];</span>
        <span class="kwa">if</span> <span class="opt">(</span>mask <span class="opt">&amp;</span> filterMask<span class="opt">) ==</span> <span class="num">0</span> <span class="opt">{</span>
          allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> mask<span class="opt">;</span>
          totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
        <span class="opt">}</span>
        pMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
      <span class="opt">}</span>
      allMasks<span class="opt">[</span>totalCount<span class="opt">] =</span> <span class="num">0</span><span class="opt">;</span>
      totalCount <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="opt">}</span>
  <span class="opt">}</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Add initial piece to board, then fire off remaining searches in parallel</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">searchParallel</span><span class="opt">(</span><span class="kwa">in</span> board<span class="opt">=</span><span class="num">0</span><span class="opt">,</span> <span class="kwa">in</span> pos<span class="opt">=</span><span class="num">0</span><span class="opt">,</span> used<span class="opt">=</span><span class="num">0</span><span class="opt">,</span> placed<span class="opt">=</span><span class="num">0</span><span class="opt">,</span> firstPiece<span class="opt">=</span><span class="num">0</span><span class="opt">) {</span>

  <span class="kwa">const</span> count <span class="opt">=</span> <span class="kwc">ctz</span><span class="opt">(~</span>board<span class="opt">);</span>
  pos <span class="opt">+=</span> count<span class="opt">;</span>
  board <span class="opt">&gt;&gt;=</span> count<span class="opt">;</span>

  <span class="kwa">const</span> boardAndUsed <span class="opt">=</span> board <span class="opt">|</span> used<span class="opt">;</span>
  <span class="kwa">var</span> currentMask <span class="opt">=</span> maskStart<span class="opt">[</span>pos<span class="opt">][</span><span class="num">0</span><span class="opt">];</span>

  <span class="kwa">if</span> placed <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span>
    <span class="kwa">while</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>
      <span class="kwa">if</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>
        <span class="kwa">const</span> mask <span class="opt">=</span> allMasks<span class="opt">[</span>currentMask<span class="opt">];</span>
        currentMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
        <span class="kwc">searchParallel</span><span class="opt">(</span>board <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskBottom<span class="opt">),</span> pos<span class="opt">,</span>
                       used <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskUsed<span class="opt">),</span> placed <span class="opt">+</span> <span class="num">1</span><span class="opt">,</span> mask<span class="opt">);</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
  <span class="slc">// 1 piece has been placed</span>
  <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
    <span class="kwa">while</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>
      <span class="kwa">while</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] &amp;</span> boardAndUsed <span class="kwa">do</span>
        currentMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>

      <span class="kwa">if</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>
        <span class="kwa">const</span> mask <span class="opt">=</span> allMasks<span class="opt">[</span>currentMask<span class="opt">];</span>
        currentMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
        <span class="kwa">begin</span> <span class="kwc">searchLinearHelper</span><span class="opt">(</span>board <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskBottom<span class="opt">),</span> pos<span class="opt">,</span>
                                 used <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskUsed<span class="opt">),</span> placed<span class="opt">+</span><span class="num">1</span><span class="opt">,</span>
                                 firstPiece<span class="opt">,</span> mask<span class="opt">);</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
  <span class="opt">}</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Pretty printed output of board</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">printBoard</span><span class="opt">(</span>board<span class="opt">) {</span>
  <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardCells <span class="opt">{</span>
    <span class="kwc">writef</span><span class="opt">(</span><span class="str">&quot;%i &quot;</span><span class="opt">,</span> board<span class="opt">[</span>i<span class="opt">]);</span>
    <span class="kwa">if</span> i <span class="opt">%</span> boardWidth <span class="opt">==</span> <span class="num">4</span> <span class="opt">{</span>
      <span class="kwc">writeln</span><span class="opt">();</span>
      <span class="kwa">if</span> i <span class="opt">&amp;</span> <span class="num">1</span> <span class="opt">==</span> <span class="num">0</span> <span class="kwa">then</span>
        <span class="kwc">write</span><span class="opt">(</span><span class="str">&quot; &quot;</span><span class="opt">);</span>
    <span class="opt">}</span>
  <span class="opt">}</span>
  <span class="kwc">writeln</span><span class="opt">();</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Determine if piece and permutation (mask) at a given position (pos) is valid</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">goodPiece</span><span class="opt">(</span>mask<span class="opt">,</span> pos<span class="opt">) {</span>
   <span class="kwa">const</span> evenRows <span class="opt">=</span> maskEven<span class="opt">,</span>
         oddRows <span class="opt">= ~</span>evenRows<span class="opt">,</span>
         leftBorder <span class="opt">=</span> maskBorder<span class="opt">,</span>
         rightBorder <span class="opt">=</span> leftBorder <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">;</span>

   <span class="kwa">var</span> b <span class="opt">= (</span>mask <span class="opt">&lt;&lt;</span> pos<span class="opt">) |</span> maskBoard<span class="opt">;</span>

   b <span class="opt">= ~</span>b<span class="opt">;</span>

   <span class="kwa">while</span> b <span class="opt">{</span>
      <span class="kwa">var</span> a <span class="opt">=</span> b <span class="opt">&amp; (-</span>b<span class="opt">);</span>

      <span class="kwa">do</span> <span class="opt">{</span>
        <span class="kwa">const</span> s1 <span class="opt">=</span> a <span class="opt">&lt;&lt;</span> <span class="num">5</span><span class="opt">,</span>
              s2 <span class="opt">=</span> a <span class="opt">&gt;&gt;</span> <span class="num">5</span><span class="opt">,</span>
              s3 <span class="opt">= (</span>a <span class="opt">&lt;&lt;</span> <span class="num">1</span><span class="opt">) &amp; (~</span>leftBorder<span class="opt">),</span>
              s4 <span class="opt">= (</span>a <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">) &amp; (~</span>rightBorder<span class="opt">),</span>
              s5 <span class="opt">= ((</span>a <span class="opt">&amp;</span> evenRows<span class="opt">) &gt;&gt;</span> <span class="num">6</span><span class="opt">) &amp; (~</span>rightBorder<span class="opt">),</span>
              s6 <span class="opt">= ((</span>a <span class="opt">&amp;</span> evenRows<span class="opt">) &lt;&lt;</span> <span class="num">4</span><span class="opt">) &amp; (~</span>rightBorder<span class="opt">),</span>
              s7 <span class="opt">= ((</span>a <span class="opt">&amp;</span> oddRows<span class="opt">) &gt;&gt;</span> <span class="num">4</span><span class="opt">) &amp; (~</span>leftBorder<span class="opt">),</span>
              s8 <span class="opt">= ((</span>a <span class="opt">&amp;</span> oddRows<span class="opt">) &lt;&lt;</span> <span class="num">6</span><span class="opt">) &amp; (~</span>leftBorder<span class="opt">),</span>
              aOld <span class="opt">=</span> a<span class="opt">;</span>
        a <span class="opt">= (</span>a <span class="opt">|</span> s1 <span class="opt">|</span> s2 <span class="opt">|</span> s3 <span class="opt">|</span> s4 <span class="opt">|</span> s5 <span class="opt">|</span> s6 <span class="opt">|</span> s7 <span class="opt">|</span> s8<span class="opt">) &amp;</span> b<span class="opt">;</span>
      <span class="opt">}</span> <span class="kwa">while</span> aOld <span class="opt">!=</span> a<span class="opt">;</span>

      <span class="kwa">if</span> <span class="kwc">popcount</span><span class="opt">(</span>a<span class="opt">) %</span> <span class="num">5</span> <span class="opt">!=</span> <span class="num">0</span> <span class="kwa">then</span>
        <span class="kwa">return false</span><span class="opt">;</span>

      b <span class="opt">^=</span> a<span class="opt">;</span>
   <span class="opt">}</span>
   <span class="kwa">return true</span><span class="opt">;</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Wrapper to set up initial call to recursive searchLinear</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">searchLinearHelper</span><span class="opt">(</span>board<span class="opt">,</span> pos<span class="opt">,</span> used<span class="opt">,</span> placed<span class="opt">,</span> firstPiece<span class="opt">,</span> mask<span class="opt">) {</span>
  <span class="kwa">var</span> currentSolution<span class="opt">: [</span>piecesDom<span class="opt">]</span> <span class="kwb">int</span><span class="opt">;</span>
  currentSolution<span class="opt">[</span><span class="num">0</span><span class="opt">] =</span> firstPiece<span class="opt">;</span>
  currentSolution<span class="opt">[</span><span class="num">1</span><span class="opt">] =</span> mask<span class="opt">;</span>
  <span class="kwc">searchLinear</span><span class="opt">(</span>board<span class="opt">,</span> pos<span class="opt">,</span> used<span class="opt">,</span> placed<span class="opt">,</span> currentSolution<span class="opt">);</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Exponential backoff spin-wait lock that yields every so many contested locks</span>
<span class="slc">// to avoid potentially starving other tasks. This results in slightly faster</span>
<span class="slc">// runtime than just using a sync var because it has lower latency.</span>
<span class="slc">//</span>
<span class="kwa">record</span> BackoffSpinLock <span class="opt">{</span>
  <span class="kwa">var</span> l<span class="opt">:</span> <span class="kwa">atomic</span> <span class="kwb">bool</span><span class="opt">,</span>
      lockAttempts <span class="opt">=</span> <span class="num">0</span><span class="opt">,</span>
      maxLockAttempts <span class="opt">= (</span><span class="num">2</span><span class="opt">**</span><span class="num">16</span><span class="opt">-</span><span class="num">1</span><span class="opt">);</span>

  <span class="kwa">inline proc</span> <span class="kwc">lock</span><span class="opt">() {</span>
    <span class="kwa">while</span> l<span class="opt">.</span><span class="kwc">testAndSet</span><span class="opt">() {</span>
      lockAttempts <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
      <span class="kwa">if</span> <span class="opt">(</span>lockAttempts <span class="opt">&amp;</span> maxLockAttempts<span class="opt">) ==</span> <span class="num">0</span> <span class="opt">{</span>
        maxLockAttempts <span class="opt">&gt;&gt;=</span> <span class="num">1</span><span class="opt">;</span>
        <span class="kwc">chpl_task_yield</span><span class="opt">();</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
  <span class="opt">}</span>

  <span class="kwa">inline proc</span> <span class="kwc">unlock</span><span class="opt">() {</span>
    l<span class="opt">.</span><span class="kwc">clear</span><span class="opt">();</span>
  <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">// Minimally contended lock that serializes calls to recordSolution()</span>
<span class="kwa">var</span> recordSolutionLock<span class="opt">:</span> BackoffSpinLock<span class="opt">;</span>


<span class="slc">//</span>
<span class="slc">// Recursively add pieces to the board, and check solution when filled</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">searchLinear</span><span class="opt">(</span><span class="kwa">in</span> board<span class="opt">,</span> <span class="kwa">in</span> pos<span class="opt">,</span> used<span class="opt">,</span> placed<span class="opt">,</span> currentSolution<span class="opt">) {</span>

  <span class="kwa">if</span> placed <span class="opt">==</span> numPieces <span class="opt">{</span>
    recordSolutionLock<span class="opt">.</span><span class="kwc">lock</span><span class="opt">();</span>
    <span class="kwc">recordSolution</span><span class="opt">(</span>currentSolution<span class="opt">);</span>
    recordSolutionLock<span class="opt">.</span><span class="kwc">unlock</span><span class="opt">();</span>
  <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
    <span class="kwa">const</span> evenRows <span class="opt">=</span> evenRowsLookup<span class="opt">[</span>pos<span class="opt">],</span>
          oddRows <span class="opt">= ~</span>evenRows<span class="opt">,</span>

          leftBorder <span class="opt">=</span> leftBorderLookup<span class="opt">[</span>pos<span class="opt">],</span>
          rightBorder <span class="opt">=</span> leftBorder <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">,</span>

          s1 <span class="opt">= (</span>board <span class="opt">&lt;&lt;</span> <span class="num">1</span><span class="opt">) |</span> leftBorder<span class="opt">,</span>
          s2 <span class="opt">= (</span>board <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">) |</span> rightBorder<span class="opt">,</span>
          s3 <span class="opt">= (</span>board <span class="opt">&lt;&lt;</span> <span class="num">4</span><span class="opt">) | ((</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">4</span><span class="opt">) -</span> <span class="num">1</span><span class="opt">) |</span> rightBorder<span class="opt">,</span>
          s4 <span class="opt">= (</span>board <span class="opt">&gt;&gt;</span> <span class="num">4</span><span class="opt">) |</span> leftBorder<span class="opt">,</span>
          s5 <span class="opt">= (</span>board <span class="opt">&lt;&lt;</span> <span class="num">5</span><span class="opt">) | ((</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">5</span><span class="opt">) -</span> <span class="num">1</span><span class="opt">),</span>
          s6 <span class="opt">= (</span>board <span class="opt">&gt;&gt;</span> <span class="num">5</span><span class="opt">),</span>
          s7 <span class="opt">= (</span>board <span class="opt">&lt;&lt;</span> <span class="num">6</span><span class="opt">) | ((</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">6</span><span class="opt">) -</span> <span class="num">1</span><span class="opt">) |</span> leftBorder<span class="opt">,</span>
          s8 <span class="opt">= (</span>board <span class="opt">&gt;&gt;</span> <span class="num">6</span><span class="opt">) |</span> rightBorder<span class="opt">;</span>

    <span class="kwa">if</span> <span class="opt">~</span>board <span class="opt">&amp;</span> s1 <span class="opt">&amp;</span> s2 <span class="opt">&amp;</span> s5 <span class="opt">&amp;</span> s6 <span class="opt">&amp;</span>
       <span class="opt">((</span>evenRows <span class="opt">&amp;</span> s4 <span class="opt">&amp;</span> s7<span class="opt">) | (</span>oddRows <span class="opt">&amp;</span> s3 <span class="opt">&amp;</span> s8<span class="opt">))</span> <span class="kwa">then return</span><span class="opt">;</span>

    <span class="kwa">const</span> count <span class="opt">=</span> <span class="kwc">ctz</span><span class="opt">(~</span>board<span class="opt">);</span>
    pos <span class="opt">+=</span> count<span class="opt">;</span>
    board <span class="opt">&gt;&gt;=</span> count<span class="opt">;</span>

    <span class="kwa">const</span> f <span class="opt">= ((</span>board <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">) &amp;</span> <span class="num">1</span><span class="opt">) |</span>
              <span class="opt">((</span>board <span class="opt">&gt;&gt; (</span><span class="num">4</span> <span class="opt">- (</span>evenRowsLookup<span class="opt">[</span>pos<span class="opt">] &amp;</span> <span class="num">1</span><span class="opt">))) &amp;</span> <span class="num">6</span><span class="opt">),</span>
          boardAndUsed <span class="opt">=</span> board <span class="opt">|</span> used<span class="opt">;</span>

    <span class="kwa">var</span> currentMask <span class="opt">=</span> maskStart<span class="opt">[</span>pos<span class="opt">][</span>f<span class="opt">];</span>

    <span class="kwa">while</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>

      <span class="kwa">while</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] &amp;</span> boardAndUsed <span class="kwa">do</span>
        currentMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>

      <span class="kwa">if</span> allMasks<span class="opt">[</span>currentMask<span class="opt">] {</span>
        <span class="kwa">const</span> mask <span class="opt">=</span> allMasks<span class="opt">[</span>currentMask<span class="opt">];</span>
        currentSolution<span class="opt">[</span>placed<span class="opt">] =</span> mask<span class="opt">;</span>
        <span class="kwc">searchLinear</span><span class="opt">(</span>board <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskBottom<span class="opt">),</span> pos<span class="opt">,</span>
                     used <span class="opt">| (</span>mask <span class="opt">&amp;</span> maskUsed<span class="opt">),</span> placed <span class="opt">+</span> <span class="num">1</span><span class="opt">,</span> currentSolution<span class="opt">);</span>
        currentMask <span class="opt">+=</span> <span class="num">1</span><span class="opt">;</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
  <span class="opt">}</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Check a given board as a solution and record it</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">recordSolution</span><span class="opt">(</span>currentSolution<span class="opt">) {</span>
  <span class="kwa">var</span> board<span class="opt">,</span> flipBoard<span class="opt">: [</span>boardDom<span class="opt">]</span> <span class="kwb">int</span><span class="opt">,</span>
      pos<span class="opt">,</span> b1<span class="opt">,</span> count <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>

  <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>numPieces <span class="opt">{</span>
    <span class="kwa">var</span> mask <span class="opt">=</span> currentSolution<span class="opt">[</span>i<span class="opt">];</span>
    <span class="kwa">const</span> piece <span class="opt">=</span> <span class="kwc">ctz</span><span class="opt">(</span>mask <span class="opt">&gt;&gt;</span> <span class="num">22</span><span class="opt">);</span>
    mask <span class="opt">&amp;=</span> maskBottom<span class="opt">;</span>
    b1 <span class="opt">|=</span> mask<span class="opt">;</span>
    <span class="kwa">while</span> mask <span class="opt">{</span>
      <span class="kwa">const</span> currentBit <span class="opt">=</span> mask <span class="opt">&amp; (-</span>mask<span class="opt">);</span>
      count <span class="opt">=</span> <span class="kwc">ctz</span><span class="opt">(</span>currentBit<span class="opt">);</span>
      board<span class="opt">[</span>count <span class="opt">+</span> pos<span class="opt">] =</span> piece<span class="opt">;</span>
      flipBoard<span class="opt">[</span><span class="num">49</span> <span class="opt">-</span> count <span class="opt">-</span> pos<span class="opt">] =</span> piece<span class="opt">;</span>
      mask <span class="opt">^=</span> currentBit<span class="opt">;</span>
    <span class="opt">}</span>
    count <span class="opt">=</span> <span class="kwc">ctz</span><span class="opt">(~</span>b1<span class="opt">);</span>
    pos <span class="opt">+=</span> count<span class="opt">;</span>
    b1 <span class="opt">&gt;&gt;=</span> count<span class="opt">;</span>
  <span class="opt">}</span>
  <span class="kwa">if</span> solutions <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span>
    minSolution <span class="opt">=</span> board<span class="opt">;</span>
    maxSolution <span class="opt">=</span> board<span class="opt">;</span>
  <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
    <span class="kwc">compareSolution</span><span class="opt">(</span>board<span class="opt">);</span>
    <span class="kwc">compareSolution</span><span class="opt">(</span>flipBoard<span class="opt">);</span>
  <span class="opt">}</span>

  solutions <span class="opt">+=</span> <span class="num">2</span><span class="opt">;</span>
<span class="opt">}</span>


<span class="slc">//</span>
<span class="slc">// Determine whether a solution is a min or max solution</span>
<span class="slc">//</span>
<span class="kwa">proc</span> <span class="kwc">compareSolution</span><span class="opt">(</span>board<span class="opt">) {</span>

  <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardCells <span class="opt">{</span>
    <span class="kwa">if</span> board<span class="opt">[</span>i<span class="opt">] &lt;</span> minSolution<span class="opt">[</span>i<span class="opt">] {</span>
      minSolution <span class="opt">=</span> board<span class="opt">;</span>
      <span class="kwa">break</span><span class="opt">;</span>
    <span class="opt">}</span> <span class="kwa">else if</span> board<span class="opt">[</span>i<span class="opt">] &gt;</span> minSolution<span class="opt">[</span>i<span class="opt">]</span> <span class="kwa">then break</span><span class="opt">;</span>
  <span class="opt">}</span>
  <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span><span class="opt">..#</span>boardCells <span class="opt">{</span>
    <span class="kwa">if</span> board<span class="opt">[</span>i<span class="opt">] &gt;</span> maxSolution<span class="opt">[</span>i<span class="opt">] {</span>
      maxSolution <span class="opt">=</span> board<span class="opt">;</span>
      <span class="kwa">break</span><span class="opt">;</span>
    <span class="opt">}</span> <span class="kwa">else if</span> board<span class="opt">[</span>i<span class="opt">] &lt;</span> maxSolution<span class="opt">[</span>i<span class="opt">]</span> <span class="kwa">then break</span><span class="opt">;</span>
  <span class="opt">}</span>
<span class="opt">}</span>

    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
chpl Version 1.16.0
Copyright (c) 2004-2017, Cray Inc.


Wed, 25 Oct 2017 17:01:17 GMT

MAKE:
mv meteor.chapel-2.chapel meteor.chapel-2.chpl
/opt/src/chapel-1.16.0/bin/linux64/chpl --fast meteor.chapel-2.chpl -o meteor.chapel-2.chapel_run
rm meteor.chapel-2.chpl

16.39s to complete and log all make actions

COMMAND LINE:
./meteor.chapel-2.chapel_run --n=2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

