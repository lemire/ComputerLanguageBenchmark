<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest C gcc program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest C gcc program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com"> * http://benchmarksgame.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * contributed by Christian Vosteen</span>
<span class="com"> */</span>

<span class="ppc">#include &lt;stdlib.h&gt;</span>
<span class="ppc">#include &lt;stdio.h&gt;</span>
<span class="ppc">#define TRUE 1</span>
<span class="ppc">#define FALSE 0</span>

<span class="com">/* The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="com"> * maximum speed the board will be implemented as     . . . . .</span>
<span class="com"> * 50 bits, which will fit into a 64 bit long long   . . . . .</span>
<span class="com"> * int.                                               . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> * I will represent 0&apos;s as empty cells and 1&apos;s        . . . . .</span>
<span class="com"> * as full cells.                                    . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> */</span>

<span class="kwb">unsigned long long</span> board <span class="opt">=</span> <span class="num">0xFFFC000000000000</span>ULL<span class="opt">;</span>

<span class="com">/* The puzzle pieces must be specified by the path followed</span>
<span class="com"> * from one end to the other along 12 hexagonal directions.</span>
<span class="com"> *</span>
<span class="com"> *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="com"> *                   </span>
<span class="com"> *  O O O O    O   O O   O O O     O O O     O   O</span>
<span class="com"> *         O    O O           O       O       O O</span>
<span class="com"> *                           O         O         O</span>
<span class="com"> *</span>
<span class="com"> *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="com"> *</span>
<span class="com"> *    O O O     O O       O O     O O        O O O O</span>
<span class="com"> *       O O       O O       O       O O O        O</span>
<span class="com"> *                  O       O O</span>
<span class="com"> *</span>
<span class="com"> * I had to make it 12 directions because I wanted all of the</span>
<span class="com"> * piece definitions to fit into the same size arrays.  It is</span>
<span class="com"> * not possible to define piece 4 in terms of the 6 cardinal</span>
<span class="com"> * directions in 4 moves.</span>
<span class="com"> */</span>

<span class="ppc">#define E     0</span>
<span class="ppc">#define ESE   1</span>
<span class="ppc">#define SE    2</span>
<span class="ppc">#define S     3</span>
<span class="ppc">#define SW    4</span>
<span class="ppc">#define WSW   5</span>
<span class="ppc">#define W     6</span>
<span class="ppc">#define WNW   7</span>
<span class="ppc">#define NW    8</span>
<span class="ppc">#define N     9</span>
<span class="ppc">#define NE    10</span>
<span class="ppc">#define ENE   11</span>
<span class="ppc">#define PIVOT 12</span>

<span class="kwb">char</span> piece_def<span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">4</span><span class="opt">] = {</span>
   <span class="opt">{</span>  E<span class="opt">,</span>  E<span class="opt">,</span>  E<span class="opt">,</span> SE<span class="opt">},</span>
   <span class="opt">{</span> SE<span class="opt">,</span>  E<span class="opt">,</span> NE<span class="opt">,</span>  E<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span>  E<span class="opt">,</span> SE<span class="opt">,</span> SW<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span>  E<span class="opt">,</span> SW<span class="opt">,</span> SE<span class="opt">},</span>
   <span class="opt">{</span> SE<span class="opt">,</span>  E<span class="opt">,</span> NE<span class="opt">,</span>  S<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span>  E<span class="opt">,</span> SW<span class="opt">,</span>  E<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span> SE<span class="opt">,</span> SE<span class="opt">,</span> NE<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span> SE<span class="opt">,</span> SE<span class="opt">,</span>  W<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span> SE<span class="opt">,</span>  E<span class="opt">,</span>  E<span class="opt">},</span>
   <span class="opt">{</span>  E<span class="opt">,</span>  E<span class="opt">,</span>  E<span class="opt">,</span> SW<span class="opt">}</span>
<span class="opt">};</span>

 
<span class="com">/* To minimize the amount of work done in the recursive solve function below,</span>
<span class="com"> * I&apos;m going to allocate enough space for all legal rotations of each piece</span>
<span class="com"> * at each position on the board. That&apos;s 10 pieces x 50 board positions x</span>
<span class="com"> * 12 rotations.  However, not all 12 rotations will fit on every cell, so</span>
<span class="com"> * I&apos;ll have to keep count of the actual number that do.</span>
<span class="com"> * The pieces are going to be unsigned long long ints just like the board so</span>
<span class="com"> * they can be bitwise-anded with the board to determine if they fit.</span>
<span class="com"> * I&apos;m also going to record the next possible open cell for each piece and</span>
<span class="com"> * location to reduce the burden on the solve function.</span>
<span class="com"> */</span>
<span class="kwb">unsigned long long</span> pieces<span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">][</span><span class="num">12</span><span class="opt">];</span>
<span class="kwb">int</span> piece_counts<span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">];</span>
<span class="kwb">char</span> next_cell<span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">][</span><span class="num">12</span><span class="opt">];</span>

<span class="com">/* Returns the direction rotated 60 degrees clockwise */</span>
<span class="kwb">char</span> <span class="kwd">rotate</span><span class="opt">(</span><span class="kwb">char</span> dir<span class="opt">) {</span>
   <span class="kwa">return</span> <span class="opt">(</span>dir <span class="opt">+</span> <span class="num">2</span><span class="opt">) %</span> PIVOT<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/* Returns the direction flipped on the horizontal axis */</span>
<span class="kwb">char</span> <span class="kwd">flip</span><span class="opt">(</span><span class="kwb">char</span> dir<span class="opt">) {</span>
   <span class="kwa">return</span> <span class="opt">(</span>PIVOT <span class="opt">-</span> dir<span class="opt">) %</span> PIVOT<span class="opt">;</span>
<span class="opt">}</span>


<span class="com">/* Returns the new cell index from the specified cell in the</span>
<span class="com"> * specified direction.  The index is only valid if the</span>
<span class="com"> * starting cell and direction have been checked by the</span>
<span class="com"> * out_of_bounds function first.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">shift</span><span class="opt">(</span><span class="kwb">char</span> cell<span class="opt">,</span> <span class="kwb">char</span> dir<span class="opt">) {</span>
   <span class="kwa">switch</span><span class="opt">(</span>dir<span class="opt">) {</span>
      <span class="kwa">case</span> E<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">1</span><span class="opt">;</span>
      <span class="kwa">case</span> ESE<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">7</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">6</span><span class="opt">;</span>
      <span class="kwa">case</span> SE<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">6</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">case</span> S<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">10</span><span class="opt">;</span>
      <span class="kwa">case</span> SW<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">5</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">4</span><span class="opt">;</span>
      <span class="kwa">case</span> WSW<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">4</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">3</span><span class="opt">;</span>
      <span class="kwa">case</span> W<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">1</span><span class="opt">;</span>
      <span class="kwa">case</span> WNW<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">6</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">7</span><span class="opt">;</span>
      <span class="kwa">case</span> NW<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">5</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">6</span><span class="opt">;</span>
      <span class="kwa">case</span> N<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">10</span><span class="opt">;</span>
      <span class="kwa">case</span> NE<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">4</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">case</span> ENE<span class="opt">:</span>
         <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">3</span><span class="opt">;</span>
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">4</span><span class="opt">;</span>
      <span class="kwa">default</span><span class="opt">:</span>
         <span class="kwa">return</span> cell<span class="opt">;</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Returns wether the specified cell and direction will land outside</span>
<span class="com"> * of the board.  Used to determine if a piece is at a legal board</span>
<span class="com"> * location or not.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">out_of_bounds</span><span class="opt">(</span><span class="kwb">char</span> cell<span class="opt">,</span> <span class="kwb">char</span> dir<span class="opt">) {</span>
   <span class="kwb">char</span> i<span class="opt">;</span>
   <span class="kwa">switch</span><span class="opt">(</span>dir<span class="opt">) {</span>
      <span class="kwa">case</span> E<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">5</span> <span class="opt">==</span> <span class="num">4</span><span class="opt">;</span>
      <span class="kwa">case</span> ESE<span class="opt">:</span>
         i <span class="opt">=</span> cell <span class="opt">%</span> <span class="num">10</span><span class="opt">;</span>   
         <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">4</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">8</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">9</span> <span class="opt">||</span> cell <span class="opt">&gt;=</span> <span class="num">45</span><span class="opt">;</span>
      <span class="kwa">case</span> SE<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">10</span> <span class="opt">==</span> <span class="num">9</span> <span class="opt">||</span> cell <span class="opt">&gt;=</span> <span class="num">45</span><span class="opt">;</span>
      <span class="kwa">case</span> S<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">&gt;=</span> <span class="num">40</span><span class="opt">;</span>
      <span class="kwa">case</span> SW<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">10</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">||</span> cell <span class="opt">&gt;=</span> <span class="num">45</span><span class="opt">;</span>
      <span class="kwa">case</span> WSW<span class="opt">:</span>
         i <span class="opt">=</span> cell <span class="opt">%</span> <span class="num">10</span><span class="opt">;</span>   
         <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">0</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">1</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">5</span> <span class="opt">||</span> cell <span class="opt">&gt;=</span> <span class="num">45</span><span class="opt">;</span>
      <span class="kwa">case</span> W<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">5</span> <span class="opt">==</span> <span class="num">0</span><span class="opt">;</span>
      <span class="kwa">case</span> WNW<span class="opt">:</span>
         i <span class="opt">=</span> cell <span class="opt">%</span> <span class="num">10</span><span class="opt">;</span>   
         <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">0</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">1</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">5</span> <span class="opt">||</span> cell <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">case</span> NW<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">10</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">||</span> cell <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">case</span> N<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span>
      <span class="kwa">case</span> NE<span class="opt">:</span>
         <span class="kwa">return</span> cell <span class="opt">%</span> <span class="num">10</span> <span class="opt">==</span> <span class="num">9</span> <span class="opt">||</span> cell <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">case</span> ENE<span class="opt">:</span>
         i <span class="opt">=</span> cell <span class="opt">%</span> <span class="num">10</span><span class="opt">;</span>   
         <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">4</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">8</span> <span class="opt">||</span> i <span class="opt">==</span> <span class="num">9</span> <span class="opt">||</span> cell <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span>
      <span class="kwa">default</span><span class="opt">:</span>
         <span class="kwa">return</span> FALSE<span class="opt">;</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Rotate a piece 60 degrees clockwise */</span>
<span class="kwb">void</span> <span class="kwd">rotate_piece</span><span class="opt">(</span><span class="kwb">int</span> piece<span class="opt">) {</span>
   <span class="kwb">int</span> i<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">;</span> i<span class="opt">++)</span>
      piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">] =</span> <span class="kwd">rotate</span><span class="opt">(</span>piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">]);</span>
<span class="opt">}</span>

<span class="com">/* Flip a piece along the horizontal axis */</span>
<span class="kwb">void</span> <span class="kwd">flip_piece</span><span class="opt">(</span><span class="kwb">int</span> piece<span class="opt">) {</span>
   <span class="kwb">int</span> i<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">;</span> i<span class="opt">++)</span>
      piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">] =</span> <span class="kwd">flip</span><span class="opt">(</span>piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">]);</span>
<span class="opt">}</span>

<span class="com">/* Convenience function to quickly calculate all of the indices for a piece */</span>
<span class="kwb">void</span> <span class="kwd">calc_cell_indices</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">,</span> <span class="kwb">int</span> piece<span class="opt">,</span> <span class="kwb">char</span> index<span class="opt">) {</span>
   cell<span class="opt">[</span><span class="num">0</span><span class="opt">] =</span> index<span class="opt">;</span>
   cell<span class="opt">[</span><span class="num">1</span><span class="opt">] =</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">0</span><span class="opt">]);</span>
   cell<span class="opt">[</span><span class="num">2</span><span class="opt">] =</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">1</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">1</span><span class="opt">]);</span>
   cell<span class="opt">[</span><span class="num">3</span><span class="opt">] =</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">2</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">2</span><span class="opt">]);</span>
   cell<span class="opt">[</span><span class="num">4</span><span class="opt">] =</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">3</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">3</span><span class="opt">]);</span>
<span class="opt">}</span>

<span class="com">/* Convenience function to quickly calculate if a piece fits on the board */</span>
<span class="kwb">int</span> <span class="kwd">cells_fit_on_board</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">,</span> <span class="kwb">int</span> piece<span class="opt">) {</span>
   <span class="kwa">return</span> <span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">0</span><span class="opt">]) &amp;&amp;</span>
         <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">1</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">1</span><span class="opt">]) &amp;&amp;</span> 
         <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">2</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">2</span><span class="opt">]) &amp;&amp;</span> 
         <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">3</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">3</span><span class="opt">]));</span>
<span class="opt">}</span>

<span class="com">/* Returns the lowest index of the cells of a piece.</span>
<span class="com"> * I use the lowest index that a piece occupies as the index for looking up</span>
<span class="com"> * the piece in the solve function.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">minimum_of_cells</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">) {</span>
   <span class="kwb">char</span> minimum <span class="opt">=</span> cell<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>
   minimum <span class="opt">=</span> cell<span class="opt">[</span><span class="num">1</span><span class="opt">] &lt;</span> minimum <span class="opt">?</span> cell<span class="opt">[</span><span class="num">1</span><span class="opt">] :</span> minimum<span class="opt">;</span>
   minimum <span class="opt">=</span> cell<span class="opt">[</span><span class="num">2</span><span class="opt">] &lt;</span> minimum <span class="opt">?</span> cell<span class="opt">[</span><span class="num">2</span><span class="opt">] :</span> minimum<span class="opt">;</span>
   minimum <span class="opt">=</span> cell<span class="opt">[</span><span class="num">3</span><span class="opt">] &lt;</span> minimum <span class="opt">?</span> cell<span class="opt">[</span><span class="num">3</span><span class="opt">] :</span> minimum<span class="opt">;</span>
   minimum <span class="opt">=</span> cell<span class="opt">[</span><span class="num">4</span><span class="opt">] &lt;</span> minimum <span class="opt">?</span> cell<span class="opt">[</span><span class="num">4</span><span class="opt">] :</span> minimum<span class="opt">;</span>
   <span class="kwa">return</span> minimum<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/* Calculate the lowest possible open cell if the piece is placed on the board.</span>
<span class="com"> * Used to later reduce the amount of time searching for open cells in the</span>
<span class="com"> * solve function.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">first_empty_cell</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">,</span> <span class="kwb">char</span> minimum<span class="opt">) {</span>
   <span class="kwb">char</span> first_empty <span class="opt">=</span> minimum<span class="opt">;</span>
   <span class="kwa">while</span><span class="opt">(</span>first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">0</span><span class="opt">] ||</span> first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">1</span><span class="opt">] ||</span>
         first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">2</span><span class="opt">] ||</span> first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">3</span><span class="opt">] ||</span>
         first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">4</span><span class="opt">])</span>
      first_empty<span class="opt">++;</span>
   <span class="kwa">return</span> first_empty<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/* Generate the unsigned long long int that will later be anded with the</span>
<span class="com"> * board to determine if it fits.</span>
<span class="com"> */</span>
<span class="kwb">unsigned long long</span> <span class="kwd">bitmask_from_cells</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">) {</span>
   <span class="kwb">unsigned long long</span> piece_mask <span class="opt">=</span> <span class="num">0ULL</span><span class="opt">;</span>
   <span class="kwb">int</span> i<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++)</span>
      piece_mask <span class="opt">|=</span> <span class="num">1ULL</span> <span class="opt">&lt;&lt;</span> cell<span class="opt">[</span>i<span class="opt">];</span>
   <span class="kwa">return</span> piece_mask<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/* Record the piece and other important information in arrays that will</span>
<span class="com"> * later be used by the solve function.</span>
<span class="com"> */</span>
<span class="kwb">void</span> <span class="kwd">record_piece</span><span class="opt">(</span><span class="kwb">int</span> piece<span class="opt">,</span> <span class="kwb">int</span> minimum<span class="opt">,</span> <span class="kwb">char</span> first_empty<span class="opt">,</span>
      <span class="kwb">unsigned long long</span> piece_mask<span class="opt">) {</span>
   pieces<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">][</span>piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]] =</span> piece_mask<span class="opt">;</span>
   next_cell<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">][</span>piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]] =</span> first_empty<span class="opt">;</span>
   piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]++;</span>         
<span class="opt">}</span>


<span class="com">/* Fill the entire board going cell by cell.  If any cells are &quot;trapped&quot;</span>
<span class="com"> * they will be left alone.</span>
<span class="com"> */</span>
<span class="kwb">void</span> <span class="kwd">fill_contiguous_space</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>board<span class="opt">,</span> <span class="kwb">int</span> index<span class="opt">) {</span>
   <span class="kwa">if</span><span class="opt">(</span>board<span class="opt">[</span>index<span class="opt">] ==</span> <span class="num">1</span><span class="opt">)</span>
      <span class="kwa">return</span><span class="opt">;</span>
   board<span class="opt">[</span>index<span class="opt">] =</span> <span class="num">1</span><span class="opt">;</span>
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> E<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> E<span class="opt">));</span>   
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> SE<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> SE<span class="opt">));</span>   
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> SW<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> SW<span class="opt">));</span>   
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> W<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> W<span class="opt">));</span>   
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> NW<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> NW<span class="opt">));</span>   
   <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> NE<span class="opt">))</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> NE<span class="opt">));</span>   
<span class="opt">}</span>


<span class="com">/* To thin the number of pieces, I calculate if any of them trap any empty</span>
<span class="com"> * cells at the edges.  There are only a handful of exceptions where the</span>
<span class="com"> * the board can be solved with the trapped cells.  For example:  piece 8 can</span>
<span class="com"> * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0</span>
<span class="com"> * can split the board in half where both halves are viable.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">has_island</span><span class="opt">(</span><span class="kwb">char</span> <span class="opt">*</span>cell<span class="opt">,</span> <span class="kwb">int</span> piece<span class="opt">) {</span>
   <span class="kwb">char</span> temp_board<span class="opt">[</span><span class="num">50</span><span class="opt">];</span>
   <span class="kwb">char</span> c<span class="opt">;</span>
   <span class="kwb">int</span> i<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> i<span class="opt">++)</span>
      temp_board<span class="opt">[</span>i<span class="opt">] =</span> <span class="num">0</span><span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++)</span>
      temp_board<span class="opt">[((</span><span class="kwb">int</span><span class="opt">)</span>cell<span class="opt">[</span>i<span class="opt">])] =</span> <span class="num">1</span><span class="opt">;</span>
   i <span class="opt">=</span> <span class="num">49</span><span class="opt">;</span>
   <span class="kwa">while</span><span class="opt">(</span>temp_board<span class="opt">[</span>i<span class="opt">] ==</span> <span class="num">1</span><span class="opt">)</span>
      i<span class="opt">--;</span>
   <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>temp_board<span class="opt">,</span> i<span class="opt">);</span>
   c <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> i<span class="opt">++)</span>
      <span class="kwa">if</span><span class="opt">(</span>temp_board<span class="opt">[</span>i<span class="opt">] ==</span> <span class="num">0</span><span class="opt">)</span>
         c<span class="opt">++;</span>
   <span class="kwa">if</span><span class="opt">(</span>c <span class="opt">==</span> <span class="num">0</span> <span class="opt">|| (</span>c <span class="opt">==</span> <span class="num">5</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">8</span><span class="opt">) || (</span>c <span class="opt">==</span> <span class="num">40</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">8</span><span class="opt">) ||</span>
         <span class="opt">(</span>c <span class="opt">%</span> <span class="num">5</span> <span class="opt">==</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">0</span><span class="opt">))</span>
      <span class="kwa">return</span> FALSE<span class="opt">;</span>
   <span class="kwa">else</span>
      <span class="kwa">return</span> TRUE<span class="opt">;</span>   
<span class="opt">}</span>


<span class="com">/* Calculate all six rotations of the specified piece at the specified index.</span>
<span class="com"> * We calculate only half of piece 3&apos;s rotations.  This is because any solution</span>
<span class="com"> * found has an identical solution rotated 180 degrees.  Thus we can reduce the</span>
<span class="com"> * number of attempted pieces in the solve algorithm by not including the 180-</span>
<span class="com"> * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave</span>
<span class="com"> * me the best time ;)</span>
<span class="com"> */</span>
 <span class="kwb">void</span> <span class="kwd">calc_six_rotations</span><span class="opt">(</span><span class="kwb">char</span> piece<span class="opt">,</span> <span class="kwb">char</span> index<span class="opt">) {</span>
   <span class="kwb">char</span> rotation<span class="opt">,</span> cell<span class="opt">[</span><span class="num">5</span><span class="opt">];</span>
   <span class="kwb">char</span> minimum<span class="opt">,</span> first_empty<span class="opt">;</span>
   <span class="kwb">unsigned long long</span> piece_mask<span class="opt">;</span>

   <span class="kwa">for</span><span class="opt">(</span>rotation <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> rotation <span class="opt">&lt;</span> <span class="num">6</span><span class="opt">;</span> rotation<span class="opt">++) {</span>
      <span class="kwa">if</span><span class="opt">(</span>piece <span class="opt">!=</span> <span class="num">3</span> <span class="opt">||</span> rotation <span class="opt">&lt;</span> <span class="num">3</span><span class="opt">) {</span> 
         <span class="kwd">calc_cell_indices</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">,</span> index<span class="opt">);</span>
         <span class="kwa">if</span><span class="opt">(</span><span class="kwd">cells_fit_on_board</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">) &amp;&amp; !</span><span class="kwd">has_island</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">)) {</span>
            minimum <span class="opt">=</span> <span class="kwd">minimum_of_cells</span><span class="opt">(</span>cell<span class="opt">);</span>
            first_empty <span class="opt">=</span> <span class="kwd">first_empty_cell</span><span class="opt">(</span>cell<span class="opt">,</span> minimum<span class="opt">);</span>
            piece_mask <span class="opt">=</span> <span class="kwd">bitmask_from_cells</span><span class="opt">(</span>cell<span class="opt">);</span>
            <span class="kwd">record_piece</span><span class="opt">(</span>piece<span class="opt">,</span> minimum<span class="opt">,</span> first_empty<span class="opt">,</span> piece_mask<span class="opt">);</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
      <span class="kwd">rotate_piece</span><span class="opt">(</span>piece<span class="opt">);</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Calculate every legal rotation for each piece at each board location. */</span>
<span class="kwb">void</span> <span class="kwd">calc_pieces</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwb">char</span> piece<span class="opt">,</span> index<span class="opt">;</span>

   <span class="kwa">for</span><span class="opt">(</span>piece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> piece <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> piece<span class="opt">++) {</span>
      <span class="kwa">for</span><span class="opt">(</span>index <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> index <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> index<span class="opt">++) {</span>
         <span class="kwd">calc_six_rotations</span><span class="opt">(</span>piece<span class="opt">,</span> index<span class="opt">);</span>
         <span class="kwd">flip_piece</span><span class="opt">(</span>piece<span class="opt">);</span>
         <span class="kwd">calc_six_rotations</span><span class="opt">(</span>piece<span class="opt">,</span> index<span class="opt">);</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>



<span class="com">/* Calculate all 32 possible states for a 5-bit row and all rows that will</span>
<span class="com"> * create islands that follow any of the 32 possible rows.  These pre-</span>
<span class="com"> * calculated 5-bit rows will be used to find islands in a partially solved</span>
<span class="com"> * board in the solve function.</span>
<span class="com"> */</span>
<span class="ppc">#define ROW_MASK 0x1F</span>
<span class="ppc">#define TRIPLE_MASK 0x7FFF</span>
<span class="kwb">char</span> all_rows<span class="opt">[</span><span class="num">32</span><span class="opt">] = {</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">,</span> <span class="num">3</span><span class="opt">,</span> <span class="num">4</span><span class="opt">,</span> <span class="num">5</span><span class="opt">,</span> <span class="num">6</span><span class="opt">,</span> <span class="num">7</span><span class="opt">,</span> <span class="num">8</span><span class="opt">,</span> <span class="num">9</span><span class="opt">,</span> <span class="num">10</span><span class="opt">,</span> <span class="num">11</span><span class="opt">,</span> <span class="num">12</span><span class="opt">,</span> <span class="num">13</span><span class="opt">,</span> <span class="num">14</span><span class="opt">,</span> <span class="num">15</span><span class="opt">,</span> <span class="num">16</span><span class="opt">,</span>
      <span class="num">17</span><span class="opt">,</span> <span class="num">18</span><span class="opt">,</span> <span class="num">19</span><span class="opt">,</span> <span class="num">20</span><span class="opt">,</span> <span class="num">21</span><span class="opt">,</span> <span class="num">22</span><span class="opt">,</span> <span class="num">23</span><span class="opt">,</span> <span class="num">24</span><span class="opt">,</span> <span class="num">25</span><span class="opt">,</span> <span class="num">26</span><span class="opt">,</span> <span class="num">27</span><span class="opt">,</span> <span class="num">28</span><span class="opt">,</span> <span class="num">29</span><span class="opt">,</span> <span class="num">30</span><span class="opt">,</span> <span class="num">31</span><span class="opt">};</span>
<span class="kwb">int</span> bad_even_rows<span class="opt">[</span><span class="num">32</span><span class="opt">][</span><span class="num">32</span><span class="opt">];</span>
<span class="kwb">int</span> bad_odd_rows<span class="opt">[</span><span class="num">32</span><span class="opt">][</span><span class="num">32</span><span class="opt">];</span>
<span class="kwb">int</span> bad_even_triple<span class="opt">[</span><span class="num">32768</span><span class="opt">];</span>
<span class="kwb">int</span> bad_odd_triple<span class="opt">[</span><span class="num">32768</span><span class="opt">];</span>

<span class="kwb">int</span> <span class="kwd">rows_bad</span><span class="opt">(</span><span class="kwb">char</span> row1<span class="opt">,</span> <span class="kwb">char</span> row2<span class="opt">,</span> <span class="kwb">int</span> even<span class="opt">) {</span>
   <span class="com">/* even is referring to row1 */</span>
   <span class="kwb">int</span> i<span class="opt">,</span> in_zeroes<span class="opt">,</span> group_okay<span class="opt">;</span>
   <span class="kwb">char</span> block<span class="opt">,</span> row2_shift<span class="opt">;</span>
   <span class="com">/* Test for blockages at same index and shifted index */</span>
   <span class="kwa">if</span><span class="opt">(</span>even<span class="opt">)</span>
      row2_shift <span class="opt">= ((</span>row2 <span class="opt">&lt;&lt;</span> <span class="num">1</span><span class="opt">) &amp;</span> ROW_MASK<span class="opt">) |</span> <span class="num">0x01</span><span class="opt">;</span>
   <span class="kwa">else</span>
      row2_shift <span class="opt">= (</span>row2 <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">) |</span> <span class="num">0x10</span><span class="opt">;</span>
   block <span class="opt">= ((</span>row1 <span class="opt">^</span> row2<span class="opt">) &amp;</span> row2<span class="opt">) &amp; ((</span>row1 <span class="opt">^</span> row2_shift<span class="opt">) &amp;</span> row2_shift<span class="opt">);</span>
   <span class="com">/* Test for groups of 0&apos;s */</span>
   in_zeroes <span class="opt">=</span> FALSE<span class="opt">;</span>
   group_okay <span class="opt">=</span> FALSE<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++) {</span>
      <span class="kwa">if</span><span class="opt">(</span>row1 <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> i<span class="opt">)) {</span>
         <span class="kwa">if</span><span class="opt">(</span>in_zeroes<span class="opt">) {</span>
            <span class="kwa">if</span><span class="opt">(!</span>group_okay<span class="opt">)</span>
               <span class="kwa">return</span> TRUE<span class="opt">;</span>
            in_zeroes <span class="opt">=</span> FALSE<span class="opt">;</span>
            group_okay <span class="opt">=</span> FALSE<span class="opt">;</span>
         <span class="opt">}</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">if</span><span class="opt">(!</span>in_zeroes<span class="opt">)</span>
            in_zeroes <span class="opt">=</span> TRUE<span class="opt">;</span>
         <span class="kwa">if</span><span class="opt">(!(</span>block <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> i<span class="opt">)))</span>
            group_okay <span class="opt">=</span> TRUE<span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">if</span><span class="opt">(</span>in_zeroes<span class="opt">)</span>
      <span class="kwa">return</span> <span class="opt">!</span>group_okay<span class="opt">;</span>
   <span class="kwa">else</span>
      <span class="kwa">return</span> FALSE<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/* Check for cases where three rows checked sequentially cause a false</span>
<span class="com"> * positive.  One scenario is when 5 cells may be surrounded where piece 5</span>
<span class="com"> * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span><span class="kwb">char</span> row1<span class="opt">,</span> <span class="kwb">char</span> row2<span class="opt">,</span> <span class="kwb">char</span> row3<span class="opt">,</span> <span class="kwb">int</span> even<span class="opt">) {</span>
   <span class="kwa">if</span><span class="opt">(</span>even<span class="opt">) {</span>
      <span class="com">/* There are four cases:</span>
<span class="com">       * row1: 00011  00001  11001  10101</span>
<span class="com">       * row2: 01011  00101  10001  10001</span>
<span class="com">       * row3: 011??  00110  ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x03</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x0B</span><span class="opt">) &amp;&amp; ((</span>row3 <span class="opt">&amp;</span> <span class="num">0x1C</span><span class="opt">) ==</span> <span class="num">0x0C</span><span class="opt">)) ||</span>
            <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x01</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x05</span><span class="opt">) &amp;&amp; (</span>row3 <span class="opt">==</span> <span class="num">0x06</span><span class="opt">)) ||</span>
            <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x19</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">)) ||</span>
            <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x15</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">));</span>
   <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
      <span class="com">/* There are two cases:</span>
<span class="com">       * row1: 10011  10101</span>
<span class="com">       * row2: 10001  10001</span>
<span class="com">       * row3: ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x13</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">)) ||</span>
            <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x15</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">));</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="kwb">void</span> <span class="kwd">calc_rows</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwb">int</span> row1<span class="opt">,</span> row2<span class="opt">,</span> row3<span class="opt">;</span>
   <span class="kwb">int</span> result1<span class="opt">,</span> result2<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>row1 <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> row1 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row1<span class="opt">++) {</span>
      <span class="kwa">for</span><span class="opt">(</span>row2 <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> row2 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row2<span class="opt">++) {</span>
         bad_even_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">] =</span> <span class="kwd">rows_bad</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> TRUE<span class="opt">);</span>
         bad_odd_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">] =</span> <span class="kwd">rows_bad</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> FALSE<span class="opt">);</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">for</span><span class="opt">(</span>row1 <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> row1 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row1<span class="opt">++) {</span>
      <span class="kwa">for</span><span class="opt">(</span>row2 <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> row2 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row2<span class="opt">++) {</span>
         <span class="kwa">for</span><span class="opt">(</span>row3 <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> row3 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row3<span class="opt">++) {</span>
            result1 <span class="opt">=</span> bad_even_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">];</span>
            result2 <span class="opt">=</span> bad_odd_rows<span class="opt">[</span>row2<span class="opt">][</span>row3<span class="opt">];</span>
            <span class="kwa">if</span><span class="opt">(</span>result1 <span class="opt">==</span> FALSE <span class="opt">&amp;&amp;</span> result2 <span class="opt">==</span> TRUE
                  <span class="opt">&amp;&amp;</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> row3<span class="opt">,</span> TRUE<span class="opt">))</span>
               bad_even_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> FALSE<span class="opt">;</span>
            <span class="kwa">else</span>
               bad_even_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> result1 <span class="opt">||</span> result2<span class="opt">;</span>

            result1 <span class="opt">=</span> bad_odd_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">];</span>
            result2 <span class="opt">=</span> bad_even_rows<span class="opt">[</span>row2<span class="opt">][</span>row3<span class="opt">];</span>
            <span class="kwa">if</span><span class="opt">(</span>result1 <span class="opt">==</span> FALSE <span class="opt">&amp;&amp;</span> result2 <span class="opt">==</span> TRUE
                  <span class="opt">&amp;&amp;</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> row3<span class="opt">,</span> FALSE<span class="opt">))</span>
               bad_odd_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> FALSE<span class="opt">;</span>
            <span class="kwa">else</span>
               bad_odd_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> result1 <span class="opt">||</span> result2<span class="opt">;</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>



<span class="com">/* Calculate islands while solving the board.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">boardHasIslands</span><span class="opt">(</span><span class="kwb">char</span> cell<span class="opt">) {</span>
   <span class="com">/* Too low on board, don&apos;t bother checking */</span>
   <span class="kwa">if</span><span class="opt">(</span>cell <span class="opt">&gt;=</span> <span class="num">40</span><span class="opt">)</span>
      <span class="kwa">return</span> FALSE<span class="opt">;</span>
   <span class="kwb">int</span> current_triple <span class="opt">= (</span>board <span class="opt">&gt;&gt; ((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) *</span> <span class="num">5</span><span class="opt">)) &amp;</span> TRIPLE_MASK<span class="opt">;</span>
   <span class="kwa">if</span><span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">)</span>
      <span class="kwa">return</span> bad_odd_triple<span class="opt">[</span>current_triple<span class="opt">];</span>
   <span class="kwa">else</span>
      <span class="kwa">return</span> bad_even_triple<span class="opt">[</span>current_triple<span class="opt">];</span>
<span class="opt">}</span>


<span class="com">/* The recursive solve algorithm.  Try to place each permutation in the upper-</span>
<span class="com"> * leftmost empty cell.  Mark off available pieces as it goes along.</span>
<span class="com"> * Because the board is a bit mask, the piece number and bit mask must be saved</span>
<span class="com"> * at each successful piece placement.  This data is used to create a 50 char</span>
<span class="com"> * array if a solution is found.</span>
<span class="com"> */</span>
<span class="kwb">short</span> avail <span class="opt">=</span> <span class="num">0x03FF</span><span class="opt">;</span>
<span class="kwb">char</span> sol_nums<span class="opt">[</span><span class="num">10</span><span class="opt">];</span>
<span class="kwb">unsigned long long</span> sol_masks<span class="opt">[</span><span class="num">10</span><span class="opt">];</span>
<span class="kwb">signed char</span> solutions<span class="opt">[</span><span class="num">2100</span><span class="opt">][</span><span class="num">50</span><span class="opt">];</span>
<span class="kwb">int</span> solution_count <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
<span class="kwb">int</span> max_solutions <span class="opt">=</span> <span class="num">2100</span><span class="opt">;</span>

<span class="kwb">void</span> <span class="kwd">record_solution</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwb">int</span> sol_no<span class="opt">,</span> index<span class="opt">;</span>
   <span class="kwb">unsigned long long</span> sol_mask<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>sol_no <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> sol_no <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> sol_no<span class="opt">++) {</span>
      sol_mask <span class="opt">=</span> sol_masks<span class="opt">[</span>sol_no<span class="opt">];</span>
      <span class="kwa">for</span><span class="opt">(</span>index <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> index <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> index<span class="opt">++) {</span>
         <span class="kwa">if</span><span class="opt">(</span>sol_mask <span class="opt">&amp;</span> <span class="num">1ULL</span><span class="opt">) {</span>
            solutions<span class="opt">[</span>solution_count<span class="opt">][</span>index<span class="opt">] =</span> sol_nums<span class="opt">[</span>sol_no<span class="opt">];</span>
            <span class="com">/* Board rotated 180 degrees is a solution too! */</span>
            solutions<span class="opt">[</span>solution_count<span class="opt">+</span><span class="num">1</span><span class="opt">][</span><span class="num">49</span><span class="opt">-</span>index<span class="opt">] =</span> sol_nums<span class="opt">[</span>sol_no<span class="opt">];</span>
         <span class="opt">}</span>
         sol_mask <span class="opt">=</span> sol_mask <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   solution_count <span class="opt">+=</span> <span class="num">2</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwd">solve</span><span class="opt">(</span><span class="kwb">int</span> depth<span class="opt">,</span> <span class="kwb">int</span> cell<span class="opt">) {</span>
   <span class="kwb">int</span> piece<span class="opt">,</span> rotation<span class="opt">,</span> max_rots<span class="opt">;</span>
   <span class="kwb">unsigned long long</span> <span class="opt">*</span>piece_mask<span class="opt">;</span>
   <span class="kwb">short</span> piece_no_mask<span class="opt">;</span>
   
   <span class="kwa">if</span><span class="opt">(</span>solution_count <span class="opt">&gt;=</span> max_solutions<span class="opt">)</span>
      <span class="kwa">return</span><span class="opt">;</span>

   <span class="kwa">while</span><span class="opt">(</span>board <span class="opt">&amp; (</span><span class="num">1ULL</span> <span class="opt">&lt;&lt;</span> cell<span class="opt">))</span>
      cell<span class="opt">++;</span>

   <span class="kwa">for</span><span class="opt">(</span>piece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> piece <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> piece<span class="opt">++) {</span>
      piece_no_mask <span class="opt">=</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> piece<span class="opt">;</span>
      <span class="kwa">if</span><span class="opt">(!(</span>avail <span class="opt">&amp;</span> piece_no_mask<span class="opt">))</span>
         <span class="kwa">continue</span><span class="opt">;</span>
      avail <span class="opt">^=</span> piece_no_mask<span class="opt">;</span>
      max_rots <span class="opt">=</span> piece_counts<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">];</span>
      piece_mask <span class="opt">=</span> pieces<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">];</span>
      <span class="kwa">for</span><span class="opt">(</span>rotation <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> rotation <span class="opt">&lt;</span> max_rots<span class="opt">;</span> rotation<span class="opt">++) {</span>
         <span class="kwa">if</span><span class="opt">(!(</span>board <span class="opt">&amp; *(</span>piece_mask <span class="opt">+</span> rotation<span class="opt">))) {</span>
            sol_nums<span class="opt">[</span>depth<span class="opt">] =</span> piece<span class="opt">;</span>
            sol_masks<span class="opt">[</span>depth<span class="opt">] = *(</span>piece_mask <span class="opt">+</span> rotation<span class="opt">);</span>
            <span class="kwa">if</span><span class="opt">(</span>depth <span class="opt">==</span> <span class="num">9</span><span class="opt">) {</span>
               <span class="com">/* Solution found!!!!!11!!ONE! */</span>
               <span class="kwd">record_solution</span><span class="opt">();</span>
               avail <span class="opt">^=</span> piece_no_mask<span class="opt">;</span>
               <span class="kwa">return</span><span class="opt">;</span>
            <span class="opt">}</span>
            board <span class="opt">|= *(</span>piece_mask <span class="opt">+</span> rotation<span class="opt">);</span>
            <span class="kwa">if</span><span class="opt">(!</span><span class="kwd">boardHasIslands</span><span class="opt">(</span>next_cell<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">][</span>rotation<span class="opt">]))</span>
               <span class="kwd">solve</span><span class="opt">(</span>depth <span class="opt">+</span> <span class="num">1</span><span class="opt">,</span> next_cell<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">][</span>rotation<span class="opt">]);</span>
            board <span class="opt">^= *(</span>piece_mask <span class="opt">+</span> rotation<span class="opt">);</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
      avail <span class="opt">^=</span> piece_no_mask<span class="opt">;</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="com">/* qsort comparator - used to find first and last solutions */</span>
<span class="kwb">int</span> <span class="kwd">solution_sort</span><span class="opt">(</span><span class="kwb">const void</span> <span class="opt">*</span>elem1<span class="opt">,</span> <span class="kwb">const void</span> <span class="opt">*</span>elem2<span class="opt">) {</span>
   <span class="kwb">signed char</span> <span class="opt">*</span>char1 <span class="opt">= (</span><span class="kwb">signed char</span> <span class="opt">*)</span> elem1<span class="opt">;</span>
   <span class="kwb">signed char</span> <span class="opt">*</span>char2 <span class="opt">= (</span><span class="kwb">signed char</span> <span class="opt">*)</span> elem2<span class="opt">;</span>
   <span class="kwb">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   <span class="kwa">while</span><span class="opt">(</span>i <span class="opt">&lt;</span> <span class="num">50</span> <span class="opt">&amp;&amp;</span> char1<span class="opt">[</span>i<span class="opt">] ==</span> char2<span class="opt">[</span>i<span class="opt">])</span>
      i<span class="opt">++;</span>
   <span class="kwa">return</span> char1<span class="opt">[</span>i<span class="opt">] -</span> char2<span class="opt">[</span>i<span class="opt">];</span>
<span class="opt">}</span>


<span class="com">/* pretty print a board in the specified hexagonal format */</span>
<span class="kwb">void</span> <span class="kwd">pretty</span><span class="opt">(</span><span class="kwb">signed char</span> <span class="opt">*</span>b<span class="opt">) {</span>
   <span class="kwb">int</span> i<span class="opt">;</span>
   <span class="kwa">for</span><span class="opt">(</span>i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> i <span class="opt">+=</span> <span class="num">10</span><span class="opt">) {</span>
      <span class="kwd">printf</span><span class="opt">(</span><span class="str">&quot;%c %c %c %c %c</span> <span class="esc">\n</span> <span class="str">%c %c %c %c %c</span> <span class="esc">\n</span><span class="str">&quot;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">1</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span>
            b<span class="opt">[</span>i<span class="opt">+</span><span class="num">2</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">3</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">4</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">5</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">6</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span>
            b<span class="opt">[</span>i<span class="opt">+</span><span class="num">7</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">8</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">9</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">);</span>
   <span class="opt">}</span>
   <span class="kwd">printf</span><span class="opt">(</span><span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">);</span>
<span class="opt">}</span>

<span class="kwb">int</span> <span class="kwd">main</span><span class="opt">(</span><span class="kwb">int</span> argc<span class="opt">,</span> <span class="kwb">char</span> <span class="opt">**</span>argv<span class="opt">) {</span>
   <span class="kwa">if</span><span class="opt">(</span>argc <span class="opt">&gt;</span> <span class="num">1</span><span class="opt">)</span>
      max_solutions <span class="opt">=</span> <span class="kwd">atoi</span><span class="opt">(</span>argv<span class="opt">[</span><span class="num">1</span><span class="opt">]);</span>
   <span class="kwd">calc_pieces</span><span class="opt">();</span>
   <span class="kwd">calc_rows</span><span class="opt">();</span>
   <span class="kwd">solve</span><span class="opt">(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
   <span class="kwd">printf</span><span class="opt">(</span><span class="str">&quot;%d solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span><span class="opt">,</span> solution_count<span class="opt">);</span>
   <span class="kwd">qsort</span><span class="opt">(</span>solutions<span class="opt">,</span> solution_count<span class="opt">,</span> <span class="num">50</span> <span class="opt">*</span> <span class="kwa">sizeof</span><span class="opt">(</span><span class="kwb">signed char</span><span class="opt">),</span> solution_sort<span class="opt">);</span>
   <span class="kwd">pretty</span><span class="opt">(</span>solutions<span class="opt">[</span><span class="num">0</span><span class="opt">]);</span>
   <span class="kwd">pretty</span><span class="opt">(</span>solutions<span class="opt">[</span>solution_count<span class="opt">-</span><span class="num">1</span><span class="opt">]);</span>
   <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
gcc (Ubuntu 7.2.0-8ubuntu3) 7.2.0


Sat, 28 Oct 2017 18:27:06 GMT

MAKE:
/usr/bin/gcc -pipe -Wall -O3 -fomit-frame-pointer -march=native  meteor.c -o meteor.gcc_run 
rm meteor.c

0.77s to complete and log all make actions

COMMAND LINE:
./meteor.gcc_run 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

