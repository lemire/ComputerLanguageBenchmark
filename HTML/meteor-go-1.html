<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Go program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Go program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com"> * http://benchmarksgame.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * contributed by The Go Authors.</span>
<span class="com"> * based on meteor-contest.c by Christian Vosteen</span>
<span class="com"> * flag.Arg hack by Isaac Gouy</span>
<span class="com"> */</span>

<span class="kwa">package</span> main

<span class="kwa">import</span> <span class="opt">(</span>
   <span class="str">&quot;flag&quot;</span>
   <span class="str">&quot;fmt&quot;</span>
   <span class="str">&quot;strconv&quot;</span>
<span class="opt">)</span>

<span class="kwa">var</span> max_solutions <span class="opt">=</span> <span class="num">0</span>


<span class="kwa">func</span> <span class="kwd">boolInt</span><span class="opt">(</span>b <span class="kwb">bool</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   <span class="kwa">if</span> b <span class="opt">{</span>
      <span class="kwa">return</span> <span class="num">1</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> <span class="num">0</span>
<span class="opt">}</span>

<span class="com">/* The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="com"> * maximum speed the board will be implemented as     . . . . .</span>
<span class="com"> * 50 bits, which will fit into a 64 bit long long   . . . . .</span>
<span class="com"> * int.                                               . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> * I will represent 0&apos;s as empty cells and 1&apos;s        . . . . .</span>
<span class="com"> * as full cells.                                    . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> */</span>

<span class="kwa">var</span> board <span class="kwb">uint64</span> <span class="opt">=</span> <span class="num">0xFFFC000000000000</span>

<span class="com">/* The puzzle pieces must be specified by the path followed</span>
<span class="com"> * from one end to the other along 12 hexagonal directions.</span>
<span class="com"> *</span>
<span class="com"> *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="com"> *</span>
<span class="com"> *  O O O O    O   O O   O O O     O O O     O   O</span>
<span class="com"> *         O    O O           O       O       O O</span>
<span class="com"> *                           O         O         O</span>
<span class="com"> *</span>
<span class="com"> *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="com"> *</span>
<span class="com"> *    O O O     O O       O O     O O        O O O O</span>
<span class="com"> *       O O       O O       O       O O O        O</span>
<span class="com"> *                  O       O O</span>
<span class="com"> *</span>
<span class="com"> * I had to make it 12 directions because I wanted all of the</span>
<span class="com"> * piece definitions to fit into the same size arrays.  It is</span>
<span class="com"> * not possible to define piece 4 in terms of the 6 cardinal</span>
<span class="com"> * directions in 4 moves.</span>
<span class="com"> */</span>

<span class="kwa">const</span> <span class="opt">(</span>
   E <span class="opt">=</span> <span class="kwb">iota</span>
   ESE
   SE
   S
   SW
   WSW
   W
   WNW
   NW
   N
   NE
   ENE
   PIVOT
<span class="opt">)</span>

<span class="kwa">var</span> piece_def <span class="opt">= [</span><span class="num">10</span><span class="opt">][</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> E<span class="opt">,</span> E<span class="opt">,</span> SE<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>SE<span class="opt">,</span> E<span class="opt">,</span> NE<span class="opt">,</span> E<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> E<span class="opt">,</span> SE<span class="opt">,</span> SW<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> E<span class="opt">,</span> SW<span class="opt">,</span> SE<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>SE<span class="opt">,</span> E<span class="opt">,</span> NE<span class="opt">,</span> S<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> E<span class="opt">,</span> SW<span class="opt">,</span> E<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> SE<span class="opt">,</span> SE<span class="opt">,</span> NE<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> SE<span class="opt">,</span> SE<span class="opt">,</span> W<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> SE<span class="opt">,</span> E<span class="opt">,</span> E<span class="opt">},</span>
   <span class="opt">[</span><span class="num">4</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span>E<span class="opt">,</span> E<span class="opt">,</span> E<span class="opt">,</span> SW<span class="opt">},</span>
<span class="opt">}</span>


<span class="com">/* To minimize the amount of work done in the recursive solve function below,</span>
<span class="com"> * I&apos;m going to allocate enough space for all legal rotations of each piece</span>
<span class="com"> * at each position on the board. That&apos;s 10 pieces x 50 board positions x</span>
<span class="com"> * 12 rotations.  However, not all 12 rotations will fit on every cell, so</span>
<span class="com"> * I&apos;ll have to keep count of the actual number that do.</span>
<span class="com"> * The pieces are going to be unsigned long long ints just like the board so</span>
<span class="com"> * they can be bitwise-anded with the board to determine if they fit.</span>
<span class="com"> * I&apos;m also going to record the next possible open cell for each piece and</span>
<span class="com"> * location to reduce the burden on the solve function.</span>
<span class="com"> */</span>
<span class="kwa">var</span> <span class="opt">(</span>
   pieces       <span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">][</span><span class="num">12</span><span class="opt">]</span><span class="kwb">uint64</span>
   piece_counts <span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">]</span><span class="kwb">int</span>
   next_cell    <span class="opt">[</span><span class="num">10</span><span class="opt">][</span><span class="num">50</span><span class="opt">][</span><span class="num">12</span><span class="opt">]</span><span class="kwb">int8</span>
<span class="opt">)</span>

<span class="com">/* Returns the direction rotated 60 degrees clockwise */</span>
<span class="kwa">func</span> <span class="kwd">rotate</span><span class="opt">(</span>dir <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span> <span class="kwa">return</span> <span class="opt">(</span>dir <span class="opt">+</span> <span class="num">2</span><span class="opt">) %</span> PIVOT <span class="opt">}</span>

<span class="com">/* Returns the direction flipped on the horizontal axis */</span>
<span class="kwa">func</span> <span class="kwd">flip</span><span class="opt">(</span>dir <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span> <span class="kwa">return</span> <span class="opt">(</span>PIVOT <span class="opt">-</span> dir<span class="opt">) %</span> PIVOT <span class="opt">}</span>


<span class="com">/* Returns the new cell index from the specified cell in the</span>
<span class="com"> * specified direction.  The index is only valid if the</span>
<span class="com"> * starting cell and direction have been checked by the</span>
<span class="com"> * out_of_bounds function first.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">,</span> dir <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   <span class="kwa">switch</span> dir <span class="opt">{</span>
   <span class="kwa">case</span> E<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">1</span>
   <span class="kwa">case</span> ESE<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">7</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">6</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> SE<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">6</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">5</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> S<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">10</span>
   <span class="kwa">case</span> SW<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">5</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">4</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> WSW<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">4</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">+</span> <span class="num">3</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> W<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">1</span>
   <span class="kwa">case</span> WNW<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">6</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">7</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> NW<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">5</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">6</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> N<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">10</span>
   <span class="kwa">case</span> NE<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">4</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">5</span>
      <span class="opt">}</span>
   <span class="kwa">case</span> ENE<span class="opt">:</span>
      <span class="kwa">if</span> <span class="opt">((</span>cell <span class="opt">/</span> <span class="num">5</span><span class="opt">) %</span> <span class="num">2</span><span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">3</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">return</span> cell <span class="opt">-</span> <span class="num">4</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> cell
<span class="opt">}</span>

<span class="com">/* Returns wether the specified cell and direction will land outside</span>
<span class="com"> * of the board.  Used to determine if a piece is at a legal board</span>
<span class="com"> * location or not.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">,</span> dir <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">bool</span> <span class="opt">{</span>
   <span class="kwa">switch</span> dir <span class="opt">{</span>
   <span class="kwa">case</span> E<span class="opt">:</span>
      <span class="kwa">return</span> cell%5 <span class="opt">==</span> <span class="num">4</span>
   <span class="kwa">case</span> ESE<span class="opt">:</span>
      i <span class="opt">:=</span> cell <span class="opt">%</span> <span class="num">10</span>
      <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">4</span> || i <span class="opt">==</span> <span class="num">8</span> || i <span class="opt">==</span> <span class="num">9</span> || cell <span class="opt">&gt;=</span> <span class="num">45</span>
   <span class="kwa">case</span> SE<span class="opt">:</span>
      <span class="kwa">return</span> cell%10 <span class="opt">==</span> <span class="num">9</span> || cell <span class="opt">&gt;=</span> <span class="num">45</span>
   <span class="kwa">case</span> S<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">&gt;=</span> <span class="num">40</span>
   <span class="kwa">case</span> SW<span class="opt">:</span>
      <span class="kwa">return</span> cell%10 <span class="opt">==</span> <span class="num">0</span> || cell <span class="opt">&gt;=</span> <span class="num">45</span>
   <span class="kwa">case</span> WSW<span class="opt">:</span>
      i <span class="opt">:=</span> cell <span class="opt">%</span> <span class="num">10</span>
      <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">0</span> || i <span class="opt">==</span> <span class="num">1</span> || i <span class="opt">==</span> <span class="num">5</span> || cell <span class="opt">&gt;=</span> <span class="num">45</span>
   <span class="kwa">case</span> W<span class="opt">:</span>
      <span class="kwa">return</span> cell%5 <span class="opt">==</span> <span class="num">0</span>
   <span class="kwa">case</span> WNW<span class="opt">:</span>
      i <span class="opt">:=</span> cell <span class="opt">%</span> <span class="num">10</span>
      <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">0</span> || i <span class="opt">==</span> <span class="num">1</span> || i <span class="opt">==</span> <span class="num">5</span> || cell <span class="opt">&lt;</span> <span class="num">5</span>
   <span class="kwa">case</span> NW<span class="opt">:</span>
      <span class="kwa">return</span> cell%10 <span class="opt">==</span> <span class="num">0</span> || cell <span class="opt">&lt;</span> <span class="num">5</span>
   <span class="kwa">case</span> N<span class="opt">:</span>
      <span class="kwa">return</span> cell <span class="opt">&lt;</span> <span class="num">10</span>
   <span class="kwa">case</span> NE<span class="opt">:</span>
      <span class="kwa">return</span> cell%10 <span class="opt">==</span> <span class="num">9</span> || cell <span class="opt">&lt;</span> <span class="num">5</span>
   <span class="kwa">case</span> ENE<span class="opt">:</span>
      i <span class="opt">:=</span> cell <span class="opt">%</span> <span class="num">10</span>
      <span class="kwa">return</span> i <span class="opt">==</span> <span class="num">4</span> || i <span class="opt">==</span> <span class="num">8</span> || i <span class="opt">==</span> <span class="num">9</span> || cell <span class="opt">&lt;</span> <span class="num">5</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> <span class="kwb">false</span>
<span class="opt">}</span>

<span class="com">/* Rotate a piece 60 degrees clockwise */</span>
<span class="kwa">func</span> <span class="kwd">rotate_piece</span><span class="opt">(</span>piece <span class="kwb">int</span><span class="opt">) {</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">;</span> i<span class="opt">++ {</span>
      piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">] =</span> <span class="kwd">rotate</span><span class="opt">(</span>piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">])</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Flip a piece along the horizontal axis */</span>
<span class="kwa">func</span> <span class="kwd">flip_piece</span><span class="opt">(</span>piece <span class="kwb">int</span><span class="opt">) {</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">;</span> i<span class="opt">++ {</span>
      piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">] =</span> <span class="kwd">flip</span><span class="opt">(</span>piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">])</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Convenience function to quickly calculate all of the indices for a piece */</span>
<span class="kwa">func</span> <span class="kwd">calc_cell_indices</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">,</span> piece <span class="kwb">int</span><span class="opt">,</span> index <span class="kwb">int8</span><span class="opt">) {</span>
   cell<span class="opt">[</span><span class="num">0</span><span class="opt">] =</span> index
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++ {</span>
      cell<span class="opt">[</span>i<span class="opt">] =</span> <span class="kwd">shift</span><span class="opt">(</span>cell<span class="opt">[</span>i<span class="opt">-</span><span class="num">1</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span>i<span class="opt">-</span><span class="num">1</span><span class="opt">])</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Convenience function to quickly calculate if a piece fits on the board */</span>
<span class="kwa">func</span> <span class="kwd">cells_fit_on_board</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">,</span> piece <span class="kwb">int</span><span class="opt">)</span> <span class="kwb">bool</span> <span class="opt">{</span>
   <span class="kwa">return</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">0</span><span class="opt">]) &amp;&amp;</span>
      <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">1</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">1</span><span class="opt">]) &amp;&amp;</span>
      <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">2</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">2</span><span class="opt">]) &amp;&amp;</span>
      <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>cell<span class="opt">[</span><span class="num">3</span><span class="opt">],</span> piece_def<span class="opt">[</span>piece<span class="opt">][</span><span class="num">3</span><span class="opt">])</span>
<span class="opt">}</span>

<span class="com">/* Returns the lowest index of the cells of a piece.</span>
<span class="com"> * I use the lowest index that a piece occupies as the index for looking up</span>
<span class="com"> * the piece in the solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">minimum_of_cells</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   minimum <span class="opt">:=</span> cell<span class="opt">[</span><span class="num">0</span><span class="opt">]</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++ {</span>
      <span class="kwa">if</span> cell<span class="opt">[</span>i<span class="opt">] &lt;</span> minimum <span class="opt">{</span>
         minimum <span class="opt">=</span> cell<span class="opt">[</span>i<span class="opt">]</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> minimum
<span class="opt">}</span>

<span class="com">/* Calculate the lowest possible open cell if the piece is placed on the board.</span>
<span class="com"> * Used to later reduce the amount of time searching for open cells in the</span>
<span class="com"> * solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">first_empty_cell</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">,</span> minimum <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   first_empty <span class="opt">:=</span> minimum
   <span class="kwa">for</span> first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">0</span><span class="opt">]</span> || first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">1</span><span class="opt">]</span> ||
      first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">2</span><span class="opt">]</span> || first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">3</span><span class="opt">]</span> ||
      first_empty <span class="opt">==</span> cell<span class="opt">[</span><span class="num">4</span><span class="opt">] {</span>
      first_empty<span class="opt">++</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> first_empty
<span class="opt">}</span>

<span class="com">/* Generate the unsigned long long int that will later be anded with the</span>
<span class="com"> * board to determine if it fits.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">bitmask_from_cells</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">uint64</span> <span class="opt">{</span>
   <span class="kwa">var</span> piece_mask <span class="kwb">uint64</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++ {</span>
      piece_mask |<span class="opt">=</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="kwb">uint</span><span class="opt">(</span>cell<span class="opt">[</span>i<span class="opt">])</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> piece_mask
<span class="opt">}</span>

<span class="com">/* Record the piece and other important information in arrays that will</span>
<span class="com"> * later be used by the solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">record_piece</span><span class="opt">(</span>piece <span class="kwb">int</span><span class="opt">,</span> minimum <span class="kwb">int8</span><span class="opt">,</span> first_empty <span class="kwb">int8</span><span class="opt">,</span> piece_mask <span class="kwb">uint64</span><span class="opt">) {</span>
   pieces<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">][</span>piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]] =</span> piece_mask
   next_cell<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">][</span>piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]] =</span> first_empty
   piece_counts<span class="opt">[</span>piece<span class="opt">][</span>minimum<span class="opt">]++</span>
<span class="opt">}</span>


<span class="com">/* Fill the entire board going cell by cell.  If any cells are &quot;trapped&quot;</span>
<span class="com"> * they will be left alone.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">,</span> index <span class="kwb">int8</span><span class="opt">) {</span>
   <span class="kwa">if</span> board<span class="opt">[</span>index<span class="opt">] ==</span> <span class="num">1</span> <span class="opt">{</span>
      <span class="kwa">return</span>
   <span class="opt">}</span>
   board<span class="opt">[</span>index<span class="opt">] =</span> <span class="num">1</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> E<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> E<span class="opt">))</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> SE<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> SE<span class="opt">))</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> SW<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> SW<span class="opt">))</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> W<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> W<span class="opt">))</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> NW<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> NW<span class="opt">))</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> <span class="opt">!</span><span class="kwd">out_of_bounds</span><span class="opt">(</span>index<span class="opt">,</span> NE<span class="opt">) {</span>
      <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>board<span class="opt">,</span> <span class="kwd">shift</span><span class="opt">(</span>index<span class="opt">,</span> NE<span class="opt">))</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="com">/* To thin the number of pieces, I calculate if any of them trap any empty</span>
<span class="com"> * cells at the edges.  There are only a handful of exceptions where the</span>
<span class="com"> * the board can be solved with the trapped cells.  For example:  piece 8 can</span>
<span class="com"> * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0</span>
<span class="com"> * can split the board in half where both halves are viable.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">has_island</span><span class="opt">(</span>cell <span class="opt">[]</span><span class="kwb">int8</span><span class="opt">,</span> piece <span class="kwb">int</span><span class="opt">)</span> <span class="kwb">bool</span> <span class="opt">{</span>
   temp_board <span class="opt">:=</span> <span class="kwb">make</span><span class="opt">([]</span><span class="kwb">int8</span><span class="opt">,</span> <span class="num">50</span><span class="opt">)</span>
   <span class="kwa">var</span> i <span class="kwb">int</span>
   <span class="kwa">for</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++ {</span>
      temp_board<span class="opt">[</span>cell<span class="opt">[</span>i<span class="opt">]] =</span> <span class="num">1</span>
   <span class="opt">}</span>
   i <span class="opt">=</span> <span class="num">49</span>
   <span class="kwa">for</span> temp_board<span class="opt">[</span>i<span class="opt">] ==</span> <span class="num">1</span> <span class="opt">{</span>
      i<span class="opt">--</span>
   <span class="opt">}</span>
   <span class="kwd">fill_contiguous_space</span><span class="opt">(</span>temp_board<span class="opt">,</span> <span class="kwb">int8</span><span class="opt">(</span>i<span class="opt">))</span>
   c <span class="opt">:=</span> <span class="num">0</span>
   <span class="kwa">for</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> i<span class="opt">++ {</span>
      <span class="kwa">if</span> temp_board<span class="opt">[</span>i<span class="opt">] ==</span> <span class="num">0</span> <span class="opt">{</span>
         c<span class="opt">++</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> c <span class="opt">==</span> <span class="num">0</span> || <span class="opt">(</span>c <span class="opt">==</span> <span class="num">5</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">8</span><span class="opt">)</span> || <span class="opt">(</span>c <span class="opt">==</span> <span class="num">40</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">8</span><span class="opt">)</span> ||
      <span class="opt">(</span>c%5 <span class="opt">==</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> piece <span class="opt">==</span> <span class="num">0</span><span class="opt">) {</span>
      <span class="kwa">return</span> <span class="kwb">false</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> <span class="kwb">true</span>
<span class="opt">}</span>


<span class="com">/* Calculate all six rotations of the specified piece at the specified index.</span>
<span class="com"> * We calculate only half of piece 3&apos;s rotations.  This is because any solution</span>
<span class="com"> * found has an identical solution rotated 180 degrees.  Thus we can reduce the</span>
<span class="com"> * number of attempted pieces in the solve algorithm by not including the 180-</span>
<span class="com"> * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave</span>
<span class="com"> * me the best time ;)</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">calc_six_rotations</span><span class="opt">(</span>piece<span class="opt">,</span> index <span class="kwb">int</span><span class="opt">) {</span>
   cell <span class="opt">:=</span> <span class="kwb">make</span><span class="opt">([]</span><span class="kwb">int8</span><span class="opt">,</span> <span class="num">5</span><span class="opt">)</span>
   <span class="kwa">for</span> rotation <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> rotation <span class="opt">&lt;</span> <span class="num">6</span><span class="opt">;</span> rotation<span class="opt">++ {</span>
      <span class="kwa">if</span> piece <span class="opt">!=</span> <span class="num">3</span> || rotation <span class="opt">&lt;</span> <span class="num">3</span> <span class="opt">{</span>
         <span class="kwd">calc_cell_indices</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">,</span> <span class="kwb">int8</span><span class="opt">(</span>index<span class="opt">))</span>
         <span class="kwa">if</span> <span class="kwd">cells_fit_on_board</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">) &amp;&amp; !</span><span class="kwd">has_island</span><span class="opt">(</span>cell<span class="opt">,</span> piece<span class="opt">) {</span>
            minimum <span class="opt">:=</span> <span class="kwd">minimum_of_cells</span><span class="opt">(</span>cell<span class="opt">)</span>
            first_empty <span class="opt">:=</span> <span class="kwd">first_empty_cell</span><span class="opt">(</span>cell<span class="opt">,</span> minimum<span class="opt">)</span>
            piece_mask <span class="opt">:=</span> <span class="kwd">bitmask_from_cells</span><span class="opt">(</span>cell<span class="opt">)</span>
            <span class="kwd">record_piece</span><span class="opt">(</span>piece<span class="opt">,</span> minimum<span class="opt">,</span> first_empty<span class="opt">,</span> piece_mask<span class="opt">)</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
      <span class="kwd">rotate_piece</span><span class="opt">(</span>piece<span class="opt">)</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* Calculate every legal rotation for each piece at each board location. */</span>
<span class="kwa">func</span> <span class="kwd">calc_pieces</span><span class="opt">() {</span>
   <span class="kwa">for</span> piece <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> piece <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> piece<span class="opt">++ {</span>
      <span class="kwa">for</span> index <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> index <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> index<span class="opt">++ {</span>
         <span class="kwd">calc_six_rotations</span><span class="opt">(</span>piece<span class="opt">,</span> index<span class="opt">)</span>
         <span class="kwd">flip_piece</span><span class="opt">(</span>piece<span class="opt">)</span>
         <span class="kwd">calc_six_rotations</span><span class="opt">(</span>piece<span class="opt">,</span> index<span class="opt">)</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="com">/* Calculate all 32 possible states for a 5-bit row and all rows that will</span>
<span class="com"> * create islands that follow any of the 32 possible rows.  These pre-</span>
<span class="com"> * calculated 5-bit rows will be used to find islands in a partially solved</span>
<span class="com"> * board in the solve function.</span>
<span class="com"> */</span>
<span class="kwa">const</span> <span class="opt">(</span>
   ROW_MASK    <span class="opt">=</span> <span class="num">0x1F</span>
   TRIPLE_MASK <span class="opt">=</span> <span class="num">0x7FFF</span>
<span class="opt">)</span>

<span class="kwa">var</span> <span class="opt">(</span>
   all_rows <span class="opt">= [</span><span class="num">32</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">{</span><span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">,</span> <span class="num">3</span><span class="opt">,</span> <span class="num">4</span><span class="opt">,</span> <span class="num">5</span><span class="opt">,</span> <span class="num">6</span><span class="opt">,</span> <span class="num">7</span><span class="opt">,</span> <span class="num">8</span><span class="opt">,</span> <span class="num">9</span><span class="opt">,</span> <span class="num">10</span><span class="opt">,</span> <span class="num">11</span><span class="opt">,</span> <span class="num">12</span><span class="opt">,</span> <span class="num">13</span><span class="opt">,</span> <span class="num">14</span><span class="opt">,</span> <span class="num">15</span><span class="opt">,</span> <span class="num">16</span><span class="opt">,</span>
      <span class="num">17</span><span class="opt">,</span> <span class="num">18</span><span class="opt">,</span> <span class="num">19</span><span class="opt">,</span> <span class="num">20</span><span class="opt">,</span> <span class="num">21</span><span class="opt">,</span> <span class="num">22</span><span class="opt">,</span> <span class="num">23</span><span class="opt">,</span> <span class="num">24</span><span class="opt">,</span> <span class="num">25</span><span class="opt">,</span> <span class="num">26</span><span class="opt">,</span> <span class="num">27</span><span class="opt">,</span> <span class="num">28</span><span class="opt">,</span> <span class="num">29</span><span class="opt">,</span> <span class="num">30</span><span class="opt">,</span> <span class="num">31</span><span class="opt">,</span>
   <span class="opt">}</span>
   bad_even_rows   <span class="opt">[</span><span class="num">32</span><span class="opt">][</span><span class="num">32</span><span class="opt">]</span><span class="kwb">int8</span>
   bad_odd_rows    <span class="opt">[</span><span class="num">32</span><span class="opt">][</span><span class="num">32</span><span class="opt">]</span><span class="kwb">int8</span>
   bad_even_triple <span class="opt">[</span><span class="num">32768</span><span class="opt">]</span><span class="kwb">int8</span>
   bad_odd_triple  <span class="opt">[</span><span class="num">32768</span><span class="opt">]</span><span class="kwb">int8</span>
<span class="opt">)</span>

<span class="kwa">func</span> <span class="kwd">rows_bad</span><span class="opt">(</span>row1<span class="opt">,</span> row2 <span class="kwb">int8</span><span class="opt">,</span> even <span class="kwb">bool</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   <span class="com">/* even is referring to row1 */</span>
   <span class="kwa">var</span> row2_shift <span class="kwb">int8</span>
   <span class="com">/* Test for blockages at same index and shifted index */</span>
   <span class="kwa">if</span> even <span class="opt">{</span>
      row2_shift <span class="opt">= ((</span>row2 <span class="opt">&lt;&lt;</span> <span class="num">1</span><span class="opt">) &amp;</span> ROW_MASK<span class="opt">)</span> | <span class="num">0x01</span>
   <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
      row2_shift <span class="opt">= (</span>row2 <span class="opt">&gt;&gt;</span> <span class="num">1</span><span class="opt">)</span> | <span class="num">0x10</span>
   <span class="opt">}</span>
   block <span class="opt">:= ((</span>row1 <span class="opt">^</span> row2<span class="opt">) &amp;</span> row2<span class="opt">) &amp; ((</span>row1 <span class="opt">^</span> row2_shift<span class="opt">) &amp;</span> row2_shift<span class="opt">)</span>
   <span class="com">/* Test for groups of 0&apos;s */</span>
   in_zeroes <span class="opt">:=</span> <span class="kwb">false</span>
   group_okay <span class="opt">:=</span> <span class="kwb">false</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="kwb">uint8</span><span class="opt">(</span><span class="num">0</span><span class="opt">);</span> i <span class="opt">&lt;</span> <span class="num">5</span><span class="opt">;</span> i<span class="opt">++ {</span>
      <span class="kwa">if</span> row1<span class="opt">&amp;(</span><span class="num">1</span><span class="opt">&lt;&lt;</span>i<span class="opt">) !=</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">if</span> in_zeroes <span class="opt">{</span>
            <span class="kwa">if</span> <span class="opt">!</span>group_okay <span class="opt">{</span>
               <span class="kwa">return</span> <span class="num">1</span>
            <span class="opt">}</span>
            in_zeroes <span class="opt">=</span> <span class="kwb">false</span>
            group_okay <span class="opt">=</span> <span class="kwb">false</span>
         <span class="opt">}</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
         <span class="kwa">if</span> <span class="opt">!</span>in_zeroes <span class="opt">{</span>
            in_zeroes <span class="opt">=</span> <span class="kwb">true</span>
         <span class="opt">}</span>
         <span class="kwa">if</span> <span class="opt">(</span>block <span class="opt">&amp; (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> i<span class="opt">)) ==</span> <span class="num">0</span> <span class="opt">{</span>
            group_okay <span class="opt">=</span> <span class="kwb">true</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">if</span> in_zeroes <span class="opt">{</span>
      <span class="kwa">return</span> <span class="kwd">boolInt</span><span class="opt">(!</span>group_okay<span class="opt">)</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> <span class="num">0</span>
<span class="opt">}</span>

<span class="com">/* Check for cases where three rows checked sequentially cause a false</span>
<span class="com"> * positive.  One scenario is when 5 cells may be surrounded where piece 5</span>
<span class="com"> * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> row3 <span class="kwb">int</span><span class="opt">,</span> even <span class="kwb">bool</span><span class="opt">)</span> <span class="kwb">bool</span> <span class="opt">{</span>
   <span class="kwa">if</span> even <span class="opt">{</span>
      <span class="com">/* There are four cases:</span>
<span class="com">       * row1: 00011  00001  11001  10101</span>
<span class="com">       * row2: 01011  00101  10001  10001</span>
<span class="com">       * row3: 011??  00110  ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x03</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x0B</span><span class="opt">) &amp;&amp; ((</span>row3 <span class="opt">&amp;</span> <span class="num">0x1C</span><span class="opt">) ==</span> <span class="num">0x0C</span><span class="opt">))</span> ||
         <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x01</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x05</span><span class="opt">) &amp;&amp; (</span>row3 <span class="opt">==</span> <span class="num">0x06</span><span class="opt">))</span> ||
         <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x19</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">))</span> ||
         <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x15</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">))</span>
   <span class="opt">}</span>
   <span class="com">/* There are two cases:</span>
<span class="com">    * row1: 10011  10101</span>
<span class="com">    * row2: 10001  10001</span>
<span class="com">    * row3: ?????  ?????</span>
<span class="com">    */</span>
   <span class="kwa">return</span> <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x13</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">))</span> ||
      <span class="opt">((</span>row1 <span class="opt">==</span> <span class="num">0x15</span><span class="opt">) &amp;&amp; (</span>row2 <span class="opt">==</span> <span class="num">0x11</span><span class="opt">))</span>
<span class="opt">}</span>

<span class="kwa">func</span> <span class="kwd">calc_rows</span><span class="opt">() {</span>
   <span class="kwa">for</span> row1 <span class="opt">:=</span> <span class="kwb">int8</span><span class="opt">(</span><span class="num">0</span><span class="opt">);</span> row1 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row1<span class="opt">++ {</span>
      <span class="kwa">for</span> row2 <span class="opt">:=</span> <span class="kwb">int8</span><span class="opt">(</span><span class="num">0</span><span class="opt">);</span> row2 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row2<span class="opt">++ {</span>
         bad_even_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">] =</span> <span class="kwd">rows_bad</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> <span class="kwb">true</span><span class="opt">)</span>
         bad_odd_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">] =</span> <span class="kwd">rows_bad</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> <span class="kwb">false</span><span class="opt">)</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">for</span> row1 <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> row1 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row1<span class="opt">++ {</span>
      <span class="kwa">for</span> row2 <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> row2 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row2<span class="opt">++ {</span>
         <span class="kwa">for</span> row3 <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> row3 <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> row3<span class="opt">++ {</span>
            result1 <span class="opt">:=</span> bad_even_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">]</span>
            result2 <span class="opt">:=</span> bad_odd_rows<span class="opt">[</span>row2<span class="opt">][</span>row3<span class="opt">]</span>
            <span class="kwa">if</span> result1 <span class="opt">==</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> result2 <span class="opt">!=</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> row3<span class="opt">,</span> <span class="kwb">true</span><span class="opt">) {</span>
               bad_even_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> <span class="num">0</span>
            <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
               bad_even_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> <span class="kwd">boolInt</span><span class="opt">(</span>result1 <span class="opt">!=</span> <span class="num">0</span> || result2 <span class="opt">!=</span> <span class="num">0</span><span class="opt">)</span>
            <span class="opt">}</span>

            result1 <span class="opt">=</span> bad_odd_rows<span class="opt">[</span>row1<span class="opt">][</span>row2<span class="opt">]</span>
            result2 <span class="opt">=</span> bad_even_rows<span class="opt">[</span>row2<span class="opt">][</span>row3<span class="opt">]</span>
            <span class="kwa">if</span> result1 <span class="opt">==</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> result2 <span class="opt">!=</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> <span class="kwd">triple_is_okay</span><span class="opt">(</span>row1<span class="opt">,</span> row2<span class="opt">,</span> row3<span class="opt">,</span> <span class="kwb">false</span><span class="opt">) {</span>
               bad_odd_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> <span class="num">0</span>
            <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
               bad_odd_triple<span class="opt">[</span>row1<span class="opt">+(</span>row2<span class="opt">*</span><span class="num">32</span><span class="opt">)+(</span>row3<span class="opt">*</span><span class="num">1024</span><span class="opt">)] =</span> <span class="kwd">boolInt</span><span class="opt">(</span>result1 <span class="opt">!=</span> <span class="num">0</span> || result2 <span class="opt">!=</span> <span class="num">0</span><span class="opt">)</span>
            <span class="opt">}</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="com">/* Calculate islands while solving the board.</span>
<span class="com">*/</span>
<span class="kwa">func</span> <span class="kwd">boardHasIslands</span><span class="opt">(</span>cell <span class="kwb">int8</span><span class="opt">)</span> <span class="kwb">int8</span> <span class="opt">{</span>
   <span class="com">/* Too low on board, don&apos;t bother checking */</span>
   <span class="kwa">if</span> cell <span class="opt">&gt;=</span> <span class="num">40</span> <span class="opt">{</span>
      <span class="kwa">return</span> <span class="num">0</span>
   <span class="opt">}</span>
   current_triple <span class="opt">:= (</span>board <span class="opt">&gt;&gt;</span> <span class="kwb">uint</span><span class="opt">((</span>cell<span class="opt">/</span><span class="num">5</span><span class="opt">)*</span><span class="num">5</span><span class="opt">)) &amp;</span> TRIPLE_MASK
   <span class="kwa">if</span> <span class="opt">(</span>cell<span class="opt">/</span><span class="num">5</span><span class="opt">)</span>%2 <span class="opt">!=</span> <span class="num">0</span> <span class="opt">{</span>
      <span class="kwa">return</span> bad_odd_triple<span class="opt">[</span>current_triple<span class="opt">]</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> bad_even_triple<span class="opt">[</span>current_triple<span class="opt">]</span>
<span class="opt">}</span>


<span class="com">/* The recursive solve algorithm.  Try to place each permutation in the upper-</span>
<span class="com"> * leftmost empty cell.  Mark off available pieces as it goes along.</span>
<span class="com"> * Because the board is a bit mask, the piece number and bit mask must be saved</span>
<span class="com"> * at each successful piece placement.  This data is used to create a 50 char</span>
<span class="com"> * array if a solution is found.</span>
<span class="com"> */</span>
<span class="kwa">var</span> <span class="opt">(</span>
   avail          <span class="kwb">uint16</span> <span class="opt">=</span> <span class="num">0x03FF</span>
   sol_nums       <span class="opt">[</span><span class="num">10</span><span class="opt">]</span><span class="kwb">int8</span>
   sol_masks      <span class="opt">[</span><span class="num">10</span><span class="opt">]</span><span class="kwb">uint64</span>
   solutions      <span class="opt">[</span><span class="num">2100</span><span class="opt">][</span><span class="num">50</span><span class="opt">]</span><span class="kwb">int8</span>
   solution_count <span class="opt">=</span> <span class="num">0</span>
<span class="opt">)</span>

<span class="kwa">func</span> <span class="kwd">record_solution</span><span class="opt">() {</span>
   <span class="kwa">for</span> sol_no <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> sol_no <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> sol_no<span class="opt">++ {</span>
      sol_mask <span class="opt">:=</span> sol_masks<span class="opt">[</span>sol_no<span class="opt">]</span>
      <span class="kwa">for</span> index <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> index <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> index<span class="opt">++ {</span>
         <span class="kwa">if</span> sol_mask<span class="opt">&amp;</span><span class="num">1</span> <span class="opt">==</span> <span class="num">1</span> <span class="opt">{</span>
            solutions<span class="opt">[</span>solution_count<span class="opt">][</span>index<span class="opt">] =</span> sol_nums<span class="opt">[</span>sol_no<span class="opt">]</span>
            <span class="com">/* Board rotated 180 degrees is a solution too! */</span>
            solutions<span class="opt">[</span>solution_count<span class="opt">+</span><span class="num">1</span><span class="opt">][</span><span class="num">49</span><span class="opt">-</span>index<span class="opt">] =</span> sol_nums<span class="opt">[</span>sol_no<span class="opt">]</span>
         <span class="opt">}</span>
         sol_mask <span class="opt">=</span> sol_mask <span class="opt">&gt;&gt;</span> <span class="num">1</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   solution_count <span class="opt">+=</span> <span class="num">2</span>
<span class="opt">}</span>

<span class="kwa">func</span> <span class="kwd">solve</span><span class="opt">(</span>depth<span class="opt">,</span> cell <span class="kwb">int8</span><span class="opt">) {</span>
   <span class="kwa">if</span> solution_count <span class="opt">&gt;=</span> max_solutions <span class="opt">{</span>
      <span class="kwa">return</span>
   <span class="opt">}</span>

   <span class="kwa">for</span> board<span class="opt">&amp;(</span><span class="num">1</span><span class="opt">&lt;&lt;</span><span class="kwb">uint</span><span class="opt">(</span>cell<span class="opt">)) !=</span> <span class="num">0</span> <span class="opt">{</span>
      cell<span class="opt">++</span>
   <span class="opt">}</span>

   <span class="kwa">for</span> piece <span class="opt">:=</span> <span class="kwb">int8</span><span class="opt">(</span><span class="num">0</span><span class="opt">);</span> piece <span class="opt">&lt;</span> <span class="num">10</span><span class="opt">;</span> piece<span class="opt">++ {</span>
      <span class="kwa">var</span> piece_no_mask <span class="kwb">uint16</span> <span class="opt">=</span> <span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="kwb">uint</span><span class="opt">(</span>piece<span class="opt">)</span>
      <span class="kwa">if</span> avail<span class="opt">&amp;</span>piece_no_mask <span class="opt">==</span> <span class="num">0</span> <span class="opt">{</span>
         <span class="kwa">continue</span>
      <span class="opt">}</span>
      avail <span class="opt">^=</span> piece_no_mask
      max_rots <span class="opt">:=</span> piece_counts<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">]</span>
      piece_mask <span class="opt">:=</span> pieces<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">]</span>
      <span class="kwa">for</span> rotation <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> rotation <span class="opt">&lt;</span> max_rots<span class="opt">;</span> rotation<span class="opt">++ {</span>
         <span class="kwa">if</span> board<span class="opt">&amp;</span>piece_mask<span class="opt">[</span>rotation<span class="opt">] ==</span> <span class="num">0</span> <span class="opt">{</span>
            sol_nums<span class="opt">[</span>depth<span class="opt">] =</span> piece
            sol_masks<span class="opt">[</span>depth<span class="opt">] =</span> piece_mask<span class="opt">[</span>rotation<span class="opt">]</span>
            <span class="kwa">if</span> depth <span class="opt">==</span> <span class="num">9</span> <span class="opt">{</span>
               <span class="com">/* Solution found!!!!!11!!ONE! */</span>
               <span class="kwd">record_solution</span><span class="opt">()</span>
               avail <span class="opt">^=</span> piece_no_mask
               <span class="kwa">return</span>
            <span class="opt">}</span>
            board |<span class="opt">=</span> piece_mask<span class="opt">[</span>rotation<span class="opt">]</span>
            <span class="kwa">if</span> <span class="kwd">boardHasIslands</span><span class="opt">(</span>next_cell<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">][</span>rotation<span class="opt">]) ==</span> <span class="num">0</span> <span class="opt">{</span>
               <span class="kwd">solve</span><span class="opt">(</span>depth<span class="opt">+</span><span class="num">1</span><span class="opt">,</span> next_cell<span class="opt">[</span>piece<span class="opt">][</span>cell<span class="opt">][</span>rotation<span class="opt">])</span>
            <span class="opt">}</span>
            board <span class="opt">^=</span> piece_mask<span class="opt">[</span>rotation<span class="opt">]</span>
         <span class="opt">}</span>
      <span class="opt">}</span>
      avail <span class="opt">^=</span> piece_no_mask
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/* pretty print a board in the specified hexagonal format */</span>
<span class="kwa">func</span> <span class="kwd">pretty</span><span class="opt">(</span>b <span class="opt">*[</span><span class="num">50</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">) {</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">50</span><span class="opt">;</span> i <span class="opt">+=</span> <span class="num">10</span> <span class="opt">{</span>
      fmt<span class="opt">.</span><span class="kwd">Printf</span><span class="opt">(</span><span class="str">&quot;</span><span class="ipl">%c %c %c %c %c</span> <span class="str"></span><span class="esc">\n</span> <span class="str"></span><span class="ipl">%c %c %c %c %c</span> <span class="str"></span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">1</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span>
         b<span class="opt">[</span>i<span class="opt">+</span><span class="num">2</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">3</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">4</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">5</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">6</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span>
         b<span class="opt">[</span>i<span class="opt">+</span><span class="num">7</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">8</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">,</span> b<span class="opt">[</span>i<span class="opt">+</span><span class="num">9</span><span class="opt">]+</span><span class="str">&apos;0&apos;</span><span class="opt">)</span>
   <span class="opt">}</span>
   fmt<span class="opt">.</span><span class="kwd">Printf</span><span class="opt">(</span><span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">)</span>
<span class="opt">}</span>

<span class="com">/* Find smallest and largest solutions */</span>
<span class="kwa">func</span> <span class="kwd">smallest_largest</span><span class="opt">() (</span>smallest<span class="opt">,</span> largest <span class="opt">*[</span><span class="num">50</span><span class="opt">]</span><span class="kwb">int8</span><span class="opt">) {</span>
   smallest <span class="opt">= &amp;</span>solutions<span class="opt">[</span><span class="num">0</span><span class="opt">]</span>
   largest <span class="opt">= &amp;</span>solutions<span class="opt">[</span><span class="num">0</span><span class="opt">]</span>
   <span class="kwa">for</span> i <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span> i <span class="opt">&lt;</span> solution_count<span class="opt">;</span> i<span class="opt">++ {</span>
      candidate <span class="opt">:= &amp;</span>solutions<span class="opt">[</span>i<span class="opt">]</span>
      <span class="kwa">for</span> j<span class="opt">,</span> s <span class="opt">:=</span> <span class="kwa">range</span> <span class="opt">*</span>smallest <span class="opt">{</span>
         c <span class="opt">:=</span> candidate<span class="opt">[</span>j<span class="opt">]</span>
         <span class="kwa">if</span> c <span class="opt">==</span> s <span class="opt">{</span>
            <span class="kwa">continue</span>
         <span class="opt">}</span>
         <span class="kwa">if</span> c <span class="opt">&lt;</span> s <span class="opt">{</span>
            smallest <span class="opt">=</span> candidate
         <span class="opt">}</span>
         <span class="kwa">break</span>
      <span class="opt">}</span>
      <span class="kwa">for</span> j<span class="opt">,</span> s <span class="opt">:=</span> <span class="kwa">range</span> <span class="opt">*</span>largest <span class="opt">{</span>
         c <span class="opt">:=</span> candidate<span class="opt">[</span>j<span class="opt">]</span>
         <span class="kwa">if</span> c <span class="opt">==</span> s <span class="opt">{</span>
            <span class="kwa">continue</span>
         <span class="opt">}</span>
         <span class="kwa">if</span> c <span class="opt">&gt;</span> s <span class="opt">{</span>
            largest <span class="opt">=</span> candidate
         <span class="opt">}</span>
         <span class="kwa">break</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   <span class="kwa">return</span>
<span class="opt">}</span>

<span class="kwa">func</span> <span class="kwd">main</span><span class="opt">() {</span>
   flag<span class="opt">.</span><span class="kwd">Parse</span><span class="opt">()</span>
   <span class="kwa">if</span> flag<span class="opt">.</span><span class="kwd">NArg</span><span class="opt">() &gt;</span> <span class="num">0</span> <span class="opt">{</span> max_solutions<span class="opt">,</span>_ <span class="opt">=</span> strconv<span class="opt">.</span><span class="kwd">Atoi</span><span class="opt">(</span> flag<span class="opt">.</span><span class="kwd">Arg</span><span class="opt">(</span><span class="num">0</span><span class="opt">) ) }</span>

   <span class="kwd">calc_pieces</span><span class="opt">()</span>
   <span class="kwd">calc_rows</span><span class="opt">()</span>
   <span class="kwd">solve</span><span class="opt">(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">)</span>
   fmt<span class="opt">.</span><span class="kwd">Printf</span><span class="opt">(</span><span class="str">&quot;</span><span class="ipl">%d</span> <span class="str">solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span><span class="opt">,</span> solution_count<span class="opt">)</span>
   smallest<span class="opt">,</span> largest <span class="opt">:=</span> <span class="kwd">smallest_largest</span><span class="opt">()</span>
   <span class="kwd">pretty</span><span class="opt">(</span>smallest<span class="opt">)</span>
   <span class="kwd">pretty</span><span class="opt">(</span>largest<span class="opt">)</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
go version go1.10 linux/amd64


Sat, 17 Feb 2018 19:02:50 GMT

MAKE:
/opt/src/go1.10.linux-amd64/go/bin/go build -o meteor.go_run

0.42s to complete and log all make actions

COMMAND LINE:
./meteor.go_run 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

