<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>k-nucleotide Lisp SBCL program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>k-nucleotide Lisp SBCL program</h2>
    <aside>
      <p><a href="./knucleotide-description.html#knucleotide">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="slc">;;   The Computer Language Benchmarks Game</span>
<span class="slc">;;   http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">;;   contributed by Currell Berry based on Java submission #1</span>
<span class="slc">;;</span>
<span class="slc">;; Note I think you could probably get further performance gains by rebasing the </span>
<span class="slc">;; implementation on Java #6, which is similar to java #1 but does not rely on </span>
<span class="slc">;; the external library it.unimi.dsi.fastutil my testing (once I had already translated</span>
<span class="slc">;; Java #1 to lisp) shows that a great deal of Java #1&apos;s performance comes from it</span>
<span class="slc">;; relying on a specialized hash table fastutil.longs.Long2IntOpenHashMap. </span>

<span class="slc">;(require :alexandria)</span>
<span class="opt">(</span><span class="kwa">defpackage</span> <span class="opt">:</span>knucleotide
  <span class="opt">(:</span>use <span class="opt">:</span>cl<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">in-package</span> <span class="opt">:</span>knucleotide<span class="opt">)</span>

<span class="opt">(</span><span class="kwa">declaim</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">space</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>

<span class="slc">;; simple thread runner implementation</span>
<span class="slc">;; we have a semaphore</span>
<span class="opt">(</span><span class="kwa">defparameter</span> <span class="opt">*</span>my-tr-available-thread-semaphore<span class="opt">*</span> nil<span class="opt">)</span>
<span class="slc">;; each time a thread finishes up, we increment this semaphore</span>
<span class="slc">;; the main thread waits on the semaphore, whenever it goes above 0 it finds</span>
<span class="slc">;; another task if one is available and starts it up</span>

<span class="opt">(</span><span class="kwa">defparameter</span> <span class="opt">*</span>my-tr-task-remaining-count<span class="opt">*</span> <span class="num">0</span><span class="opt">)</span>
<span class="opt">(</span><span class="kwa">declaim</span> <span class="opt">(</span><span class="kwa">type</span> fixnum <span class="opt">*</span>my-tr-task-remaining-count<span class="opt">*))</span>
<span class="opt">(</span><span class="kwa">defparameter</span> <span class="opt">*</span>my-tr-completed-task-mutex<span class="opt">*</span> nil<span class="opt">)</span>
<span class="opt">(</span><span class="kwa">defparameter</span> <span class="opt">*</span>my-tr-task-completed-cv<span class="opt">*</span> nil<span class="opt">)</span>

<span class="slc">;;writing to status and result should only be done in my-tr-run</span>
<span class="opt">(</span><span class="kwa">defstruct</span> my-task
  <span class="opt">(</span><span class="kwa">mylambda</span><span class="opt">)</span> <span class="slc">; the thing to run</span>
  <span class="opt">(</span><span class="kwa">status</span> nil<span class="opt">)</span> <span class="slc">; nil or t</span>
  <span class="opt">(</span><span class="kwa">result</span> nil<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defparameter</span> <span class="opt">*</span>my-task-list<span class="opt">* #())</span>
<span class="opt">(</span><span class="kwa">declaim</span> <span class="opt">(</span><span class="kwa">type</span> vector <span class="opt">*</span>my-task-list<span class="opt">*))</span>

<span class="slc">;; must have set up populated *my-task-list* first</span>
<span class="slc">;; each time a thread becomes available, then we run the next task</span>
<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">my-tr-run</span> <span class="opt">(</span><span class="kwa">threadcount</span><span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> fixnum threadcount<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">*</span>my-tr-available-thread-semaphore<span class="opt">* (</span><span class="kwa">sb-thread</span><span class="opt">:</span>make-semaphore <span class="opt">:</span>count threadcount<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">*</span>my-tr-completed-task-mutex<span class="opt">* (</span><span class="kwa">sb-thread</span><span class="opt">:</span>make-mutex<span class="opt">))</span> 
  <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">*</span>my-tr-task-remaining-count<span class="opt">* (</span><span class="kwa">length</span> <span class="opt">*</span>my-task-list<span class="opt">*))</span> 
  <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">*</span>my-tr-task-completed-cv<span class="opt">* (</span><span class="kwa">sb-thread</span><span class="opt">:</span>make-waitqueue<span class="opt">))</span> 
  <span class="opt">(</span><span class="kwa">loop</span> for taskindex from <span class="num">0</span> below <span class="opt">(</span><span class="kwa">length</span> <span class="opt">*</span>my-task-list<span class="opt">*)</span> do
       <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>wait-on-semaphore <span class="opt">*</span>my-tr-available-thread-semaphore<span class="opt">*)</span>
       <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">thetask</span> <span class="opt">(</span><span class="kwa">elt</span> <span class="opt">*</span>my-task-list<span class="opt">*</span> taskindex<span class="opt">)))</span>
         <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>make-thread <span class="opt">(</span><span class="kwa">lambda</span> <span class="opt">() (</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">results</span>
                                                  <span class="opt">(</span><span class="kwa">funcall</span> <span class="opt">(</span><span class="kwa">my-task-mylambda</span> thetask<span class="opt">))))</span>
                                             <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">my-task-result</span> thetask<span class="opt">)</span> results<span class="opt">)</span>
                                             <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">my-task-status</span> thetask<span class="opt">)</span> t<span class="opt">)</span>
                                             <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>signal-semaphore <span class="opt">*</span>my-tr-available-thread-semaphore<span class="opt">*)</span>
                                             <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>with-mutex <span class="opt">(*</span>my-tr-completed-task-mutex<span class="opt">*)</span>
                                               <span class="opt">(</span><span class="kwa">decf</span> <span class="opt">*</span>my-tr-task-remaining-count<span class="opt">*)</span>
                                               <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>condition-notify <span class="opt">*</span>my-tr-task-completed-cv<span class="opt">*)</span>
                                               <span class="opt">)</span>
                                             <span class="opt">)))))</span>
  <span class="opt">(</span><span class="kwa">loop</span>
     <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>with-mutex <span class="opt">(*</span>my-tr-completed-task-mutex<span class="opt">*)</span>
       <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">eql</span> <span class="opt">*</span>my-tr-task-remaining-count<span class="opt">*</span> <span class="num">0</span><span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">return</span><span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">sb-thread</span><span class="opt">:</span>condition-wait <span class="opt">*</span>my-tr-task-completed-cv<span class="opt">* *</span>my-tr-completed-task-mutex<span class="opt">*)))))</span>

<span class="opt">(</span><span class="kwa">defconstant</span> CODES  <span class="opt">#(</span><span class="kwa">-1</span> <span class="num">0</span> -<span class="num">1 1 3</span> -<span class="num">1</span> -<span class="num">1 2</span><span class="opt">))</span> 
<span class="opt">(</span><span class="kwa">defconstant</span> NUCLEOTIDES <span class="opt">#(#</span>\A <span class="opt">#</span>\C <span class="opt">#</span>\G <span class="opt">#</span>\T<span class="opt">))</span> 

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">hash-function</span> <span class="opt">(</span><span class="kwa">x</span><span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">64</span><span class="opt">)</span> x<span class="opt">))</span>
  x<span class="opt">)</span>

<span class="opt">(</span><span class="kwa">defstruct</span> result
  <span class="opt">(</span><span class="kwa">outmap</span> <span class="opt">(</span><span class="kwa">make-hash-table</span>
           <span class="opt">:</span>test <span class="opt">&apos;</span>eql
           <span class="opt">:</span>hash-function <span class="opt">#&apos;</span>hash-function
           <span class="opt">:</span>rehash-size <span class="num">2.0</span>
           <span class="opt">:</span>rehash-threshold <span class="num">0.7</span><span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">keylength</span> <span class="num">0</span><span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">create-fragment-tasks</span> <span class="opt">(</span><span class="kwa">sequence</span> mfragment-lengths<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">simple-array</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">) (*))</span> sequence<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">tasks</span> <span class="opt">(</span><span class="kwa">make-array</span> <span class="num">46</span> <span class="opt">:</span>fill-pointer <span class="num">0</span><span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for fragmentLength in mfragment-lengths do
         <span class="opt">(</span><span class="kwa">loop</span> for i of-type <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> from <span class="num">0</span> below fragmentLength do
              <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">offset</span> i<span class="opt">)</span>
                    <span class="opt">(</span><span class="kwa">mfragmentlength</span> fragmentLength<span class="opt">))</span>
                <span class="slc">;;(format t &quot;fragmentLength: ~a~%&quot; fragmentLength)</span>
                <span class="opt">(</span><span class="kwa">vector-push-extend</span>
                 <span class="opt">(</span><span class="kwa">make-my-task</span> <span class="opt">:</span>mylambda
                               <span class="opt">(</span><span class="kwa">lambda</span> <span class="opt">()</span>
                                 <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> mfragmentlength<span class="opt">)</span>
                                          <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> offset<span class="opt">))</span>
                                 <span class="slc">;(format t &quot;offset: ~a, fragmentLength: ~a~%&quot; offset mfragmentlength)</span>
                                 <span class="opt">(</span><span class="kwa">create-fragment-map</span> sequence offset mfragmentlength<span class="opt">)</span>
                                 <span class="opt">))</span>
                 tasks<span class="opt">))))</span>
    tasks<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">create-fragment-map</span> <span class="opt">(</span><span class="kwa">sequence</span> offset fragmentLength<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">simple-array</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">) (*))</span> sequence<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> offset<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> fragmentLength<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">let</span><span class="opt">* ((</span><span class="kwa">res</span> <span class="opt">(</span><span class="kwa">make-result</span> <span class="opt">:</span>keylength fragmentLength<span class="opt">))</span>
         <span class="opt">(</span><span class="kwa">mymap</span> <span class="opt">(</span><span class="kwa">result-outmap</span> res<span class="opt">))</span>
         <span class="opt">(</span><span class="kwa">lastIndex</span> <span class="opt">(+ (</span><span class="kwa">-</span> <span class="opt">(</span><span class="kwa">length</span> sequence<span class="opt">)</span> fragmentLength<span class="opt">)</span> <span class="num">1</span><span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> lastIndex<span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">loop</span>
       for index of-type <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> from offset below lastIndex by fragmentLength
       do
         <span class="opt">(</span><span class="kwa">let</span><span class="opt">* ((</span><span class="kwa">key</span> <span class="opt">(</span><span class="kwa">get-key</span> sequence index fragmentLength<span class="opt">))</span>
                <span class="opt">(</span><span class="kwa">value</span> <span class="opt">(</span><span class="kwa">gethash</span> key mymap <span class="num">0</span><span class="opt">)))</span>
           <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">64</span><span class="opt">)</span> key<span class="opt">)</span>
                    <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> value<span class="opt">))</span>
           <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">gethash</span> key mymap <span class="num">0</span><span class="opt">) (</span><span class="kwa">the</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">) (+</span> value <span class="num">1</span><span class="opt">)))))</span>
    res<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">sum-two-maps</span> <span class="opt">(</span><span class="kwa">result1</span> result2<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">loop</span> for key2 of-type <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">64</span><span class="opt">)</span> being the hash-keys  of <span class="opt">(</span><span class="kwa">result-outmap</span> result2<span class="opt">)</span>
     using <span class="opt">(</span><span class="kwa">hash-value</span> value2<span class="opt">)</span> do
       <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">gethash</span> key2 <span class="opt">(</span><span class="kwa">result-outmap</span> result1<span class="opt">)) (+ (</span><span class="kwa">the</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">) (</span><span class="kwa">gethash</span> key2 <span class="opt">(</span><span class="kwa">result-outmap</span> result1<span class="opt">)</span> <span class="num">0</span><span class="opt">)) (</span><span class="kwa">the</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> value2<span class="opt">))))</span>
  result1
  <span class="opt">)</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">write-frequencies</span> <span class="opt">(</span><span class="kwa">totalCount</span> frequencies<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">freq</span> <span class="opt">(</span><span class="kwa">make-array</span> <span class="opt">(</span><span class="kwa">hash-table-count</span> <span class="opt">(</span><span class="kwa">result-outmap</span> frequencies<span class="opt">)) :</span>fill-pointer <span class="num">0</span> <span class="opt">:</span>element-type <span class="opt">&apos;</span>cons<span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for key being the hash-keys of <span class="opt">(</span><span class="kwa">result-outmap</span> frequencies<span class="opt">)</span>
       using <span class="opt">(</span><span class="kwa">hash-value</span> cnt<span class="opt">)</span> do
         <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">nentry</span> <span class="opt">(</span><span class="kwa">cons</span> <span class="opt">(</span><span class="kwa">key-to-string</span> key <span class="opt">(</span><span class="kwa">result-keylength</span> frequencies<span class="opt">))</span> cnt<span class="opt">)))</span>
           <span class="opt">(</span><span class="kwa">vector-push-extend</span> nentry freq<span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">sort</span> freq <span class="opt">(</span><span class="kwa">lambda</span> <span class="opt">(</span><span class="kwa">x</span> y<span class="opt">) (&gt; (</span><span class="kwa">cdr</span> x<span class="opt">) (</span><span class="kwa">cdr</span> y<span class="opt">))))</span>
    <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">outstr</span>
           <span class="opt">(</span><span class="kwa">apply</span> <span class="opt">#&apos;</span>concatenate 
                  <span class="opt">(</span><span class="kwa">append</span> <span class="opt">(</span><span class="kwa">list</span> <span class="opt">&apos;</span>string<span class="opt">)</span>
                          <span class="opt">(</span><span class="kwa">loop</span> for index from <span class="num">0</span> below <span class="opt">(</span><span class="kwa">length</span> freq<span class="opt">)</span>
                                           for <span class="opt">(</span><span class="kwa">key</span> . value<span class="opt">) = (</span><span class="kwa">elt</span> freq index<span class="opt">)</span>
                                           collect 
                                             <span class="opt">(</span><span class="kwa">format</span> nil <span class="str">&quot;~a ~,3f~%&quot;</span> key <span class="opt">(/ (*</span> value <span class="num">100.0</span><span class="opt">)</span> totalCount<span class="opt">)))))))</span>
      outstr<span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">write-count</span> <span class="opt">(</span><span class="kwa">tasks</span> nucleotideFragment<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">let</span><span class="opt">* ((</span><span class="kwa">key</span> <span class="opt">(</span><span class="kwa">to-codes-new</span> <span class="opt">(</span><span class="kwa">map</span> <span class="opt">&apos;(</span><span class="kwa">vector</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">)) #&apos;</span>char-code nucleotideFragment<span class="opt">) (</span><span class="kwa">length</span> nucleotideFragment<span class="opt">)) )</span>
         <span class="opt">(</span><span class="kwa">k</span> <span class="opt">(</span><span class="kwa">get-key</span> key <span class="num">0</span> <span class="opt">(</span><span class="kwa">length</span> nucleotideFragment<span class="opt">)))</span>
         <span class="opt">(</span><span class="kwa">count</span> <span class="num">0</span><span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for task across tasks 
       for result <span class="opt">= (</span><span class="kwa">my-task-result</span> task<span class="opt">)</span> do
         <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(</span><span class="kwa">eql</span> <span class="opt">(</span><span class="kwa">result-keylength</span> result<span class="opt">) (</span><span class="kwa">length</span> nucleotideFragment<span class="opt">))</span>
             <span class="opt">(</span><span class="kwa">setf</span> count <span class="opt">(+</span> count <span class="opt">(</span><span class="kwa">gethash</span> k <span class="opt">(</span><span class="kwa">result-outmap</span> result<span class="opt">)</span> <span class="num">0</span><span class="opt">)))))</span>
    <span class="opt">(</span><span class="kwa">format</span> nil <span class="str">&quot;~a~c~a~%&quot;</span> count <span class="opt">#</span><span class="esc">\t</span>ab nucleotideFragment<span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">key-to-string</span> <span class="opt">(</span><span class="kwa">key</span> length<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">64</span><span class="opt">)</span> key<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> length<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">res</span> <span class="opt">(</span><span class="kwa">make-string</span> length<span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for i from <span class="num">0</span> below length do
         <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">elt</span> res <span class="opt">(</span><span class="kwa">-</span> length i <span class="num">1</span><span class="opt">)) (</span><span class="kwa">elt</span> NUCLEOTIDES <span class="opt">(</span><span class="kwa">logand</span> key <span class="opt">#</span>x3<span class="opt">)))</span>
         <span class="opt">(</span><span class="kwa">setf</span> key <span class="opt">(</span><span class="kwa">ash</span> key -<span class="num">2</span><span class="opt">)))</span>
    res<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">get-key</span> <span class="opt">(</span><span class="kwa">arr</span> offset length<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">simple-array</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">))</span> arr<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> offset<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> length<span class="opt">))</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">key</span> <span class="num">0</span><span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">64</span><span class="opt">)</span> key<span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for i of-type <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> from offset below <span class="opt">(+</span> offset length<span class="opt">)</span> do
         <span class="opt">(</span><span class="kwa">setf</span> key <span class="opt">(</span><span class="kwa">the</span> fixnum <span class="opt">(+ (</span><span class="kwa">the</span> fixnum <span class="opt">(*</span> key <span class="num">4</span><span class="opt">)) (</span><span class="kwa">the</span> fixnum <span class="opt">(</span><span class="kwa">elt</span> arr i<span class="opt">))))))</span>
    key<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">to-codes-new</span> <span class="opt">(</span><span class="kwa">sequence</span> length<span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">simple-array</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">))</span> sequence<span class="opt">)</span>
           <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> length<span class="opt">)</span>
           <span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">result</span> <span class="opt">(</span><span class="kwa">make-array</span> length <span class="opt">:</span>element-type <span class="opt">&apos;(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">))))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for i of-type <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> from <span class="num">0</span> below length do
         <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">elt</span> result i<span class="opt">) (</span><span class="kwa">elt</span> CODES <span class="opt">(</span><span class="kwa">logand</span> <span class="opt">(</span><span class="kwa">elt</span> sequence i<span class="opt">) #</span>x7<span class="opt">))))</span>
    result<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">read-in-data-new</span> <span class="opt">(</span><span class="kwa">pistream</span><span class="opt">)</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">bytes</span> <span class="opt">(</span><span class="kwa">make-array</span> <span class="num">1048576</span> <span class="opt">:</span>element-type <span class="opt">&apos;(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">)))</span>
        <span class="opt">(</span><span class="kwa">position</span> <span class="num">0</span><span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">simple-array</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">))</span> bytes<span class="opt">)</span>
             <span class="opt">(</span><span class="kwa">type</span> <span class="opt">(</span><span class="kwa">unsigned-byte</span> <span class="num">32</span><span class="opt">)</span> position<span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">with-open-stream</span>  <span class="opt">(</span><span class="kwa">istream</span> pistream<span class="opt">)</span>
      <span class="opt">(</span><span class="kwa">loop</span> for line <span class="opt">= (</span><span class="kwa">read-line</span> istream nil <span class="opt">:</span>eof<span class="opt">)</span> <span class="slc">;first, get to dna sequence three</span>
         until <span class="opt">(</span><span class="kwa">or</span> <span class="opt">(</span><span class="kwa">string-equal</span> <span class="str">&quot;&gt;THREE&quot;</span> <span class="opt">(</span><span class="kwa">subseq</span> line <span class="num">0 6</span><span class="opt">))  (</span><span class="kwa">eql</span> line <span class="opt">:</span>eof<span class="opt">)))</span>

      <span class="opt">(</span><span class="kwa">loop</span> for line <span class="opt">= (</span><span class="kwa">read-line</span> istream nil <span class="opt">:</span>eof<span class="opt">)</span>
         while <span class="opt">(</span><span class="kwa">not</span> <span class="opt">(</span><span class="kwa">or</span> <span class="opt">(</span><span class="kwa">eql</span> line <span class="opt">:</span>eof<span class="opt">) (</span><span class="kwa">eql</span> <span class="opt">(</span><span class="kwa">elt</span> line <span class="num">0</span><span class="opt">) #</span>\<span class="opt">&gt;)))</span> do
           <span class="opt">(</span><span class="kwa">if</span> <span class="opt">(&gt; (+</span> position <span class="opt">(</span><span class="kwa">length</span> line<span class="opt">)) (</span><span class="kwa">length</span> bytes<span class="opt">))</span> <span class="slc">;;then we need to grow the array</span>
               <span class="opt">(</span><span class="kwa">let</span> <span class="opt">((</span><span class="kwa">newbytes</span> <span class="opt">(</span><span class="kwa">make-array</span> <span class="opt">(*</span> <span class="num">2</span> <span class="opt">(</span><span class="kwa">length</span> bytes<span class="opt">)) :</span>element-type <span class="opt">&apos;(</span><span class="kwa">unsigned-byte</span> <span class="num">8</span><span class="opt">))))</span>
                 <span class="opt">(</span><span class="kwa">loop</span> for i from <span class="num">0</span> below <span class="opt">(</span><span class="kwa">length</span> bytes<span class="opt">)</span> do
                      <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">elt</span> newbytes i<span class="opt">) (</span><span class="kwa">elt</span> bytes i<span class="opt">)))</span>
                 <span class="opt">(</span><span class="kwa">setf</span> bytes newbytes<span class="opt">)))</span>
           <span class="opt">(</span><span class="kwa">loop</span> for i from <span class="num">0</span> below <span class="opt">(</span><span class="kwa">length</span> line<span class="opt">)</span> do
                <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">(</span><span class="kwa">elt</span> bytes position<span class="opt">) (</span><span class="kwa">char-code</span> <span class="opt">(</span><span class="kwa">elt</span> line i<span class="opt">)))</span>
                <span class="opt">(</span><span class="kwa">incf</span> position<span class="opt">))))</span>
           <span class="opt">(</span><span class="kwa">to-codes-new</span> bytes position<span class="opt">)))</span>

<span class="opt">(</span><span class="kwa">defconstant</span> FRAGMENT-LENGTHS <span class="opt">(</span><span class="kwa">list</span> <span class="num">1 2 3 4 6 12 18</span><span class="opt">))</span>
<span class="opt">(</span><span class="kwa">defconstant</span> NUCLEOTIDE-FRAGMENTS <span class="opt">(</span><span class="kwa">list</span> <span class="str">&quot;GGT&quot;</span> <span class="str">&quot;GGTA&quot;</span> <span class="str">&quot;GGTATT&quot;</span> <span class="str">&quot;GGTATTTTAATT&quot;</span>
                                           <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span> <span class="opt">))</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">get-input-stream</span> <span class="opt">()</span>
 <span class="opt">(</span><span class="kwa">open</span> <span class="opt">#</span>p<span class="str">&quot;/dev/stdin&quot;</span> <span class="opt">:</span>external-format <span class="opt">:</span>iso-8859-1<span class="opt">)</span>
<span class="slc">;(open &quot;knucleotide-input-example.txt&quot;)</span>
<span class="slc">;(open &quot;fasta-small.txt&quot;  :external-format :iso-8859-1)</span>
<span class="slc">;(open &quot;fasta.txt&quot;  :external-format :iso-8859-1)</span>
<span class="opt">)</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">main</span> <span class="opt">()</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">let</span><span class="opt">* ((</span><span class="kwa">pistream</span> <span class="opt">(</span><span class="kwa">get-input-stream</span><span class="opt">))</span>
         <span class="opt">(</span><span class="kwa">msequence</span> <span class="opt">(</span><span class="kwa">read-in-data-new</span> pistream<span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">setf</span> <span class="opt">*</span>my-task-list<span class="opt">* (</span><span class="kwa">create-fragment-tasks</span> msequence FRAGMENT-LENGTHS<span class="opt">))</span>
    <span class="opt">(</span><span class="kwa">my-tr-run</span> <span class="num">4</span><span class="opt">)</span>
    <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> <span class="opt">(</span><span class="kwa">write-frequencies</span> <span class="opt">(</span><span class="kwa">length</span> msequence<span class="opt">) (</span><span class="kwa">my-task-result</span> <span class="opt">(</span><span class="kwa">elt</span> <span class="opt">*</span>my-task-list<span class="opt">*</span> <span class="num">0</span><span class="opt">))))</span>
    
    <span class="opt">(</span><span class="kwa">format</span> t <span class="str">&quot;~a~%&quot;</span> <span class="opt">(</span><span class="kwa">write-frequencies</span> <span class="opt">(</span><span class="kwa">-</span> <span class="opt">(</span><span class="kwa">length</span> msequence<span class="opt">)</span> <span class="num">1</span><span class="opt">) (</span><span class="kwa">sum-two-maps</span>
                                                       <span class="opt">(</span><span class="kwa">my-task-result</span> <span class="opt">(</span><span class="kwa">elt</span> <span class="opt">*</span>my-task-list<span class="opt">*</span> <span class="num">1</span><span class="opt">))</span>
                                                       <span class="opt">(</span><span class="kwa">my-task-result</span> <span class="opt">(</span><span class="kwa">elt</span> <span class="opt">*</span>my-task-list<span class="opt">*</span> <span class="num">2</span><span class="opt">))</span>
                                                                  <span class="opt">)))</span>
    <span class="opt">(</span><span class="kwa">loop</span> for nucleotide-fragment in NUCLEOTIDE-FRAGMENTS do
         <span class="opt">(</span><span class="kwa">princ</span> <span class="opt">(</span><span class="kwa">write-count</span> <span class="opt">*</span>my-task-list<span class="opt">*</span>  nucleotide-fragment<span class="opt">)))</span>
<span class="opt">))</span>

<span class="opt">(</span><span class="kwa">in-package</span> <span class="opt">:</span>cl-user<span class="opt">)</span>

<span class="opt">(</span><span class="kwa">defun</span> <span class="kwb">main</span> <span class="opt">()</span>
  <span class="opt">(</span><span class="kwa">declare</span> <span class="opt">(</span><span class="kwa">optimize</span> <span class="opt">(</span><span class="kwa">speed</span> <span class="num">3</span><span class="opt">) (</span><span class="kwa">safety</span> <span class="num">0</span><span class="opt">) (</span><span class="kwa">debug</span> <span class="num">0</span><span class="opt">)))</span>
  <span class="opt">(</span><span class="kwa">knucleotide</span><span class="opt">::</span>main<span class="opt">))</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
SBCL 1.4.0


Thu, 26 Oct 2017 17:11:40 GMT

MAKE:
cp: 'knucleotide.sbcl' and './knucleotide.sbcl' are the same file
SBCL built with: /opt/src/sbcl-1.4.0/bin/sbcl --userinit /dev/null --batch --eval '(load &quot;knucleotide.sbcl_compile&quot;)'
### START knucleotide.sbcl_compile
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file &quot;knucleotide.sbcl&quot; ))) (save-lisp-and-die &quot;sbcl.core&quot; :purify t)
### END knucleotide.sbcl_compile

; compiling file &quot;/home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl&quot; (written 15 APR 2017 07:23:50 PM):
; compiling (DEFPACKAGE :KNUCLEOTIDE ...)
; compiling (IN-PACKAGE :KNUCLEOTIDE)
; compiling (DECLAIM (OPTIMIZE # ...))
; compiling (DEFPARAMETER *MY-TR-AVAILABLE-THREAD-SEMAPHORE* ...)
; compiling (DEFPARAMETER *MY-TR-TASK-REMAINING-COUNT* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFPARAMETER *MY-TR-COMPLETED-TASK-MUTEX* ...)
; compiling (DEFPARAMETER *MY-TR-TASK-COMPLETED-CV* ...)
; compiling (DEFSTRUCT MY-TASK ...)
; compiling (DEFPARAMETER *MY-TASK-LIST* ...)
; compiling (DECLAIM (TYPE VECTOR ...))
; compiling (DEFUN MY-TR-RUN ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl
; in: DEFUN MY-TR-RUN
;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* KNUCLEOTIDE::TASKINDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (FUNCALL (KNUCLEOTIDE::MY-TASK-MYLAMBDA KNUCLEOTIDE::THETASK))
; --&gt; SB-C::%FUNCALL THE 
; ==&gt;
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (KNUCLEOTIDE::MY-TASK-MYLAMBDA KNUCLEOTIDE::THETASK))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   callable expression is not known to be a function

; compiling (DEFCONSTANT CODES ...)
; compiling (DEFCONSTANT NUCLEOTIDES ...)
; compiling (DEFUN HASH-FUNCTION ...)
; compiling (DEFSTRUCT RESULT ...)
; compiling (DEFUN CREATE-FRAGMENT-TASKS ...)
; compiling (DEFUN CREATE-FRAGMENT-MAP ...)
; compiling (DEFUN SUM-TWO-MAPS ...)
; compiling (DEFUN WRITE-FREQUENCIES ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl
; in: DEFUN WRITE-FREQUENCIES
;     (MAKE-ARRAY
;      (HASH-TABLE-COUNT (KNUCLEOTIDE::RESULT-OUTMAP KNUCLEOTIDE::FREQUENCIES))
;      :FILL-POINTER 0 :ELEMENT-TYPE 'CONS)
; 
; caught STYLE-WARNING:
;   The default initial element 0 is not a CONS.

;     (/ (* KNUCLEOTIDE::VALUE 100.0) KNUCLEOTIDE::TOTALCOUNT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a SINGLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a DOUBLE-FLOAT.
;   The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   convert x/2^k to shift
; due to type uncertainty:
;   The first argument is a NUMBER, not a INTEGER.
;   The second argument is a NUMBER, not a INTEGER.

;     (* KNUCLEOTIDE::VALUE 100.0)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).

;     (/ (* KNUCLEOTIDE::VALUE 100.0) KNUCLEOTIDE::TOTALCOUNT)
; 
; note: forced to do full call
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES
;                                                         (COMPLEX SINGLE-FLOAT)
;                                                         &amp;REST T).
;       etc.

;     (&gt; (CDR KNUCLEOTIDE::X) (CDR KNUCLEOTIDE::Y))
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
;   The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-&gt; (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN WRITE-COUNT ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl
; in: DEFUN WRITE-COUNT
;     (MAP '(VECTOR (UNSIGNED-BYTE 8)) #'CHAR-CODE KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; --&gt; TRULY-THE SB-KERNEL:%MAP MAP-INTO MAKE-SEQUENCE MIN LET 
; ==&gt;
;   (LENGTH #:G26)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LOOP KNUCLEOTIDE::FOR KNUCLEOTIDE::TASK KNUCLEOTIDE::ACROSS KNUCLEOTIDE::TASKS
;           KNUCLEOTIDE::FOR KNUCLEOTIDE::RESULT = (KNUCLEOTIDE::MY-TASK-RESULT
;                                                   KNUCLEOTIDE::TASK)
;           DO (IF (EQL (KNUCLEOTIDE::RESULT-KEYLENGTH KNUCLEOTIDE::RESULT)
;                       (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT))
;                  (SETF COUNT (+ COUNT #))))
; --&gt; BLOCK LET LET TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF 
; ==&gt;
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (LENGTH KNUCLEOTIDE::NUCLEOTIDEFRAGMENT)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (+ COUNT
;        (GETHASH KNUCLEOTIDE::K (KNUCLEOTIDE::RESULT-OUTMAP KNUCLEOTIDE::RESULT)
;                 0))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES DOUBLE-FLOAT
;                                                                &amp;REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES SINGLE-FLOAT
;                                                                &amp;REST T).
;       etc.

; compiling (DEFUN KEY-TO-STRING ...)
; compiling (DEFUN GET-KEY ...)
; compiling (DEFUN TO-CODES-NEW ...)
; compiling (DEFUN READ-IN-DATA-NEW ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl
; in: DEFUN READ-IN-DATA-NEW
;     (SUBSEQ KNUCLEOTIDE::LINE 0 6)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (ELT KNUCLEOTIDE::LINE 0)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (LENGTH KNUCLEOTIDE::LINE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::LINE KNUCLEOTIDE::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

; compiling (DEFCONSTANT FRAGMENT-LENGTHS ...)
; compiling (DEFCONSTANT NUCLEOTIDE-FRAGMENTS ...)
; compiling (DEFUN GET-INPUT-STREAM ...)
; compiling (DEFUN MAIN ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl
; in: DEFUN MAIN
;     (LENGTH KNUCLEOTIDE::MSEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 0)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (LENGTH KNUCLEOTIDE::MSEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

;     (ELT KNUCLEOTIDE::*MY-TASK-LIST* 2)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).

; compiling (IN-PACKAGE :CL-USER)
; compiling (DEFUN MAIN ...); 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
;   printed 40 notes


; /home/dunham/benchmarksgame_quadcore/knucleotide/tmp/knucleotide.fasl written
; compilation finished in 0:00:00.142
### START knucleotide.sbcl_run
(main) (quit)
### END knucleotide.sbcl_run


3.64s to complete and log all make actions

COMMAND LINE:
/opt/src/sbcl-1.4.0/bin/sbcl  --noinform --core sbcl.core --userinit /dev/null --load knucleotide.sbcl_run 0 &lt; knucleotide-input25000000.txt

PROGRAM OUTPUT:
A 30.295
T 30.151
C 19.800
G 19.754

AA 9.177
TA 9.132
AT 9.131
TT 9.091
CA 6.002
AC 6.001
AG 5.987
GA 5.984
CT 5.971
TC 5.971
GT 5.957
TG 5.956
CC 3.917
GC 3.911
CG 3.909
GG 3.902

1471758	GGT
446535	GGTA
47336	GGTATT
893	GGTATTTTAATT
893	GGTATTTTAATTTATAGT
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

