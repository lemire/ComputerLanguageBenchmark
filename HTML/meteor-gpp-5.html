<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest C++ g++&nbsp;#5 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest C++ g++&nbsp;#5 program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">// contributed by Ben St. John</span>
<span class="slc">// some ideas taken from Kevin Barnes&apos; implementation</span>

<span class="com">/* A few key optimizations:</span>
<span class="com">- pre-calcing of all possible orientations of each piece</span>
<span class="com">- pre-calcing of which orientations are possible in each board position</span>
<span class="com">- fast calculation of boards with bad islands (which are unsolveable)</span>
<span class="com">- pre-calc of some boards (by top three lines) which *always* have bad islands</span>
<span class="com">- using only 32-bit boards representations (plus row offset)</span>
<span class="com">- improvement since #4 -- no caching of top three lines for other reasons</span>
<span class="com">- not using STL vector -- it noticeably slow things down</span>
<span class="com">- rotating each found solution, so only half need to be calculated -- done by removing</span>
<span class="com">half the rotations of one piece (SKIP_PIECE) chosen as the one with the most valid positions</span>
<span class="com">on the board, so only half the solution space is searched</span>
<span class="com"></span>
<span class="com">For size, most seems to come from the standard libs.</span>
<span class="com">I&apos;m tempted to get rid of string, and maybe use cstdio.</span>
<span class="com">*/</span>

<span class="ppc">#include &lt;cstdio&gt;</span>
<span class="ppc">#include &lt;cstdlib&gt;</span>
<span class="ppc">#include &lt;iostream&gt;</span>
<span class="ppc">#include &lt;string&gt;</span>
<span class="ppc">#include &lt;memory.h&gt;</span>

<span class="kwa">using namespace</span> std<span class="opt">;</span>

<span class="ppc">#define getMask(iPos) (1 &lt;&lt; (iPos))</span>

<span class="kwb">enum</span> <span class="opt">{</span>X<span class="opt">,</span> Y<span class="opt">,</span> N_DIM<span class="opt">};</span>
<span class="kwb">enum</span> <span class="opt">{</span>EVEN<span class="opt">,</span> ODD<span class="opt">,</span> N_PARITY<span class="opt">};</span>
<span class="kwb">enum</span> <span class="opt">{</span>GOOD<span class="opt">,</span> BAD<span class="opt">,</span> ALWAYS_BAD<span class="opt">};</span>

<span class="kwc">typedef</span> <span class="kwb">unsigned int</span> TUInt32<span class="opt">;</span>
<span class="kwc">typedef</span> <span class="kwb">unsigned long long</span> TUInt64<span class="opt">;</span>
<span class="kwc">typedef</span> <span class="kwb">signed char</span> TInt8<span class="opt">;</span>
<span class="kwc">typedef</span> TUInt32 BitVec<span class="opt">;</span>

<span class="kwb">static const int</span> N_COL <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>
<span class="kwb">static const int</span> N_ROW <span class="opt">=</span> <span class="num">10</span><span class="opt">;</span>
<span class="kwb">static const int</span> N_CELL <span class="opt">=</span> N_COL <span class="opt">*</span> N_ROW<span class="opt">;</span>
<span class="kwb">static const int</span> N_PIECE_TYPE <span class="opt">=</span> <span class="num">10</span><span class="opt">;</span>

<span class="kwb">struct</span> Piece<span class="opt">;</span>

<span class="kwb">struct</span> Soln <span class="opt">{</span>
   <span class="kwb">static const int</span> NO_PIECE <span class="opt">= -</span><span class="num">1</span><span class="opt">;</span>

   <span class="kwb">void</span> <span class="kwd">setCells</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">);</span>
   <span class="kwb">bool</span> <span class="kwd">lessThan</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> r<span class="opt">);</span>
   string <span class="kwd">toString</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">)</span> <span class="kwb">const</span><span class="opt">;</span>
   <span class="kwb">void</span> <span class="kwd">fill</span><span class="opt">(</span><span class="kwb">int</span> val<span class="opt">);</span>
   <span class="kwb">void</span> <span class="kwd">spin</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> spun<span class="opt">);</span>

   <span class="kwb">bool</span> <span class="kwd">isEmpty</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span><span class="kwa">return</span> <span class="opt">(</span>m_nPiece <span class="opt">==</span> <span class="num">0</span><span class="opt">);}</span>
   <span class="kwb">void</span> <span class="kwd">popPiece</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>m_nPiece<span class="opt">--;</span> m_synched <span class="opt">=</span> <span class="kwa">false</span><span class="opt">;}</span>
   <span class="kwb">void</span> <span class="kwd">pushPiece</span><span class="opt">(</span>BitVec vec<span class="opt">,</span> <span class="kwb">int</span> iPiece<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">) {</span>
      SPiece <span class="opt">&amp;</span> p <span class="opt">=</span> m_pieces<span class="opt">[</span>m_nPiece<span class="opt">++];</span>
      p<span class="opt">.</span>vec <span class="opt">=</span> vec<span class="opt">;</span>
      p<span class="opt">.</span>iPiece <span class="opt">= (</span><span class="kwb">short</span><span class="opt">)</span>iPiece<span class="opt">;</span>
      p<span class="opt">.</span>row <span class="opt">= (</span><span class="kwb">short</span><span class="opt">)</span>row<span class="opt">;</span>
   <span class="opt">}</span>

   <span class="kwd">Soln</span><span class="opt">(</span><span class="kwb">int</span> fillVal<span class="opt">);</span>
   <span class="kwd">Soln</span><span class="opt">() :</span> <span class="kwd">m_synched</span><span class="opt">(</span><span class="kwa">false</span><span class="opt">),</span> <span class="kwd">m_nPiece</span><span class="opt">(</span><span class="num">0</span><span class="opt">) {}</span>

   <span class="kwb">struct</span> SPiece <span class="opt">{</span>
      BitVec vec<span class="opt">;</span>
      <span class="kwb">short</span> iPiece<span class="opt">;</span>
      <span class="kwb">short</span> row<span class="opt">;</span>
      <span class="kwd">SPiece</span><span class="opt">() {}</span>
      <span class="kwd">SPiece</span><span class="opt">(</span>BitVec avec<span class="opt">,</span> TUInt32 apiece<span class="opt">,</span> TUInt32 arow<span class="opt">) :</span>
      <span class="kwd">vec</span><span class="opt">(</span>avec<span class="opt">),</span> <span class="kwd">iPiece</span><span class="opt">(</span><span class="kwb">short</span><span class="opt">(</span>apiece<span class="opt">)),</span> <span class="kwd">row</span><span class="opt">(</span><span class="kwb">short</span><span class="opt">(</span>arow<span class="opt">))</span>
      <span class="opt">{}</span>
   <span class="opt">};</span>
   SPiece m_pieces<span class="opt">[</span>N_PIECE_TYPE<span class="opt">];</span>
   TUInt32 m_nPiece<span class="opt">;</span>
   TInt8 m_cells<span class="opt">[</span>N_ROW<span class="opt">][</span>N_COL<span class="opt">];</span>
   <span class="kwb">bool</span> m_synched<span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">//------------------------------------</span>
<span class="kwb">struct</span> Board <span class="opt">{</span>
   <span class="kwb">static const</span> BitVec L_EDGE_MASK <span class="opt">=</span>
      <span class="opt">(</span><span class="num">1</span> <span class="opt">&lt;&lt;</span>  <span class="num">0</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span>  <span class="num">5</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">10</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">15</span><span class="opt">) |</span>
      <span class="opt">(</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">20</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">25</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">);</span>
   <span class="kwb">static const</span> BitVec R_EDGE_MASK <span class="opt">=</span> L_EDGE_MASK <span class="opt">&lt;&lt;</span> <span class="num">4</span><span class="opt">;</span>
   <span class="kwb">static const</span> BitVec TOP_ROW <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> N_COL<span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>
   <span class="kwb">static const</span> TUInt32 TWO_ROWS <span class="opt">=</span> <span class="num">2</span> <span class="opt">*</span> N_COL<span class="opt">;</span>
   <span class="kwb">static const</span> BitVec TOP_2_ROWS <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> TWO_ROWS<span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>

   <span class="kwb">static const</span> BitVec ROW_0_MASK <span class="opt">=</span>
      TOP_ROW <span class="opt">| (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">10</span><span class="opt">) | (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">20</span><span class="opt">) | (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">);</span>
   <span class="kwb">static const</span> BitVec ROW_1_MASK <span class="opt">=</span> ROW_0_MASK <span class="opt">&lt;&lt;</span> <span class="num">5</span><span class="opt">;</span>
   <span class="kwb">static const</span> BitVec BOARD_MASK <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>

   <span class="kwd">Board</span><span class="opt">();</span>

   <span class="kwb">static</span> TUInt32 <span class="kwd">getIndex</span><span class="opt">(</span>TUInt32 x<span class="opt">,</span> TUInt32 y<span class="opt">) {</span> <span class="kwa">return</span> y <span class="opt">*</span> N_COL <span class="opt">+</span> x<span class="opt">; }</span>
   <span class="kwb">static bool</span> <span class="kwd">badRegion</span><span class="opt">(</span>BitVec <span class="opt">&amp;</span> toFill<span class="opt">,</span> BitVec rNew<span class="opt">);</span>
   <span class="kwb">static int</span> <span class="kwd">hasBadIslands</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">);</span>
   <span class="kwb">static int</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">);</span>
   <span class="kwb">static bool</span> <span class="kwd">hasBadIslandsSingle</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">);</span>
   <span class="kwb">static void</span> <span class="kwd">calcAlwaysBad</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">);</span>

   <span class="kwb">void</span> <span class="kwd">genAllSolutions</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> TUInt32 placedPieces<span class="opt">,</span> TUInt32 iNextFill<span class="opt">);</span>
   <span class="kwb">void</span> <span class="kwd">recordSolution</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> s<span class="opt">);</span>

   Soln m_curSoln<span class="opt">;</span>
   Soln m_minSoln<span class="opt">;</span>
   Soln m_maxSoln<span class="opt">;</span>
   TUInt32 m_nSoln<span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">//------------------------------------</span>

<span class="kwb">struct</span> Piece <span class="opt">{</span>
   <span class="kwb">struct</span> Instance <span class="opt">{</span>
      TUInt64 m_allowed<span class="opt">;</span>
      BitVec m_vec<span class="opt">;</span>
      <span class="kwb">int</span> m_offset<span class="opt">;</span>
   <span class="opt">};</span>

   <span class="kwb">static const int</span> N_ELEM <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>
   <span class="kwb">static const int</span> N_ORIENT <span class="opt">=</span> <span class="num">12</span><span class="opt">;</span>
   <span class="kwb">static const int</span> ALL_PIECE_MASK <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> N_PIECE_TYPE<span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>
   <span class="kwb">static const</span> TUInt32 SKIP_PIECE <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span> <span class="slc">// it&apos;s magic!</span>

   <span class="kwc">typedef</span> <span class="kwb">int</span> TPts<span class="opt">[</span>N_ELEM<span class="opt">][</span>N_DIM<span class="opt">];</span>

   <span class="kwb">static const</span> BitVec BaseVecs<span class="opt">[</span>N_PIECE_TYPE<span class="opt">];</span>
   <span class="kwb">static</span> Piece s_basePiece<span class="opt">[</span>N_PIECE_TYPE<span class="opt">][</span>N_ORIENT<span class="opt">];</span>

   <span class="kwb">static const</span> Instance <span class="opt">&amp;</span> <span class="kwd">getPiece</span><span class="opt">(</span>TUInt32 iPiece<span class="opt">,</span> TUInt32 iOrient<span class="opt">,</span> TUInt32 iParity<span class="opt">);</span>
   <span class="kwb">static</span> BitVec <span class="kwd">toBitVector</span><span class="opt">(</span><span class="kwb">const</span> TPts <span class="opt">&amp;</span> pts<span class="opt">);</span>
   <span class="kwb">static void</span> <span class="kwd">genOrientation</span><span class="opt">(</span>BitVec vec<span class="opt">,</span> TUInt32 iOrient<span class="opt">,</span> Piece <span class="opt">&amp;</span> target<span class="opt">);</span>
   <span class="kwb">static void</span> <span class="kwd">setCoordList</span><span class="opt">(</span>BitVec vec<span class="opt">,</span> TPts <span class="opt">&amp;</span> pts<span class="opt">);</span>
   <span class="kwb">static void</span> <span class="kwd">shiftUpLines</span><span class="opt">(</span>TPts <span class="opt">&amp;</span> pts<span class="opt">,</span> <span class="kwb">int</span> shift<span class="opt">);</span>
   <span class="kwb">static int</span> <span class="kwd">shiftToX0</span><span class="opt">(</span>TPts <span class="opt">&amp;</span> pts<span class="opt">,</span> Instance <span class="opt">&amp;</span> instance<span class="opt">,</span> <span class="kwb">int</span> offsetRow<span class="opt">);</span>
   <span class="kwb">void</span> <span class="kwd">setOkPos</span><span class="opt">(</span>TUInt32 isOdd<span class="opt">,</span> <span class="kwb">int</span> w<span class="opt">,</span> <span class="kwb">int</span> h<span class="opt">);</span>
   <span class="kwb">static void</span> <span class="kwd">genAllOrientations</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">);</span>

   Instance m_instance<span class="opt">[</span>N_PARITY<span class="opt">];</span>
<span class="opt">};</span>

<span class="kwb">struct</span> OkPieces <span class="opt">{</span>
   TInt8 nPieces<span class="opt">[</span>N_PIECE_TYPE<span class="opt">];</span>
   TUInt32 pieceVec<span class="opt">[</span>N_PIECE_TYPE<span class="opt">][</span><span class="kwc">Piece</span><span class="opt">::</span>N_ORIENT<span class="opt">];</span>
<span class="opt">};</span>

<span class="kwb">static</span> OkPieces g_okPieces<span class="opt">[</span>N_ROW<span class="opt">][</span>N_COL<span class="opt">] = {{</span><span class="num">0</span><span class="opt">}};</span>

<span class="ppc">#define MAX_ISLAND_OFFSET 1024</span>
<span class="kwb">struct</span> IslandInfo <span class="opt">{</span>
   TUInt32 alwaysBad<span class="opt">[</span>N_PARITY<span class="opt">];</span>
<span class="opt">};</span>

<span class="kwb">static</span> IslandInfo g_islandInfo<span class="opt">[</span>MAX_ISLAND_OFFSET<span class="opt">] = {</span><span class="num">0</span><span class="opt">};</span>

<span class="slc">//------------------------------------</span>
<span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">Soln</span><span class="opt">(</span><span class="kwb">int</span> fillVal<span class="opt">) :</span>
<span class="kwd">m_nPiece</span><span class="opt">(</span><span class="num">0</span><span class="opt">) {</span>
   <span class="kwd">fill</span><span class="opt">(</span>fillVal<span class="opt">);</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">fill</span><span class="opt">(</span><span class="kwb">int</span> val<span class="opt">) {</span>
   m_synched <span class="opt">=</span> <span class="kwa">false</span><span class="opt">;</span>
   <span class="kwd">memset</span><span class="opt">(</span>m_cells<span class="opt">,</span> val<span class="opt">,</span> N_CELL<span class="opt">);</span>
<span class="opt">}</span>

string <span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">toString</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
   string result<span class="opt">;</span>
   result<span class="opt">.</span><span class="kwd">reserve</span><span class="opt">(</span>N_CELL <span class="opt">*</span> <span class="num">2</span><span class="opt">);</span>

   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
         <span class="kwb">int</span> val <span class="opt">=</span> m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>
         result <span class="opt">+= ((</span>val <span class="opt">==</span> NO_PIECE<span class="opt">) ?</span> <span class="str">&apos;.&apos;</span> <span class="opt">:</span> <span class="kwb">char</span><span class="opt">(</span><span class="str">&apos;0&apos;</span> <span class="opt">+</span> val<span class="opt">));</span>
         result <span class="opt">+=</span> <span class="str">&apos; &apos;</span><span class="opt">;</span>
      <span class="opt">}</span>
      result <span class="opt">+=</span> <span class="str">&apos;</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">;</span>

      <span class="slc">// indent every second line</span>
      <span class="kwa">if</span> <span class="opt">(</span>y <span class="opt">%</span> <span class="num">2</span> <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
         result <span class="opt">+=</span> <span class="str">&quot; &quot;</span><span class="opt">;</span>
   <span class="opt">}</span>
   <span class="kwa">return</span> result<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">setCells</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwa">if</span> <span class="opt">(</span>m_synched<span class="opt">)</span>
      <span class="kwa">return</span><span class="opt">;</span>

   <span class="kwa">for</span> <span class="opt">(</span>TUInt32 iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> m_nPiece<span class="opt">;</span> iPiece<span class="opt">++) {</span>
      <span class="kwb">const</span> SPiece <span class="opt">&amp;</span> p <span class="opt">=</span> m_pieces<span class="opt">[</span>iPiece<span class="opt">];</span>
      BitVec vec <span class="opt">=</span> p<span class="opt">.</span>vec<span class="opt">;</span>
      TInt8 pID <span class="opt">= (</span>TInt8<span class="opt">)</span>p<span class="opt">.</span>iPiece<span class="opt">;</span>
      <span class="kwb">int</span> rowOffset <span class="opt">=</span> p<span class="opt">.</span>row<span class="opt">;</span>

      <span class="kwb">int</span> nNewCells <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> rowOffset<span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
         <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
            <span class="kwa">if</span> <span class="opt">(</span>vec <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) {</span>
               m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">] =</span> pID<span class="opt">;</span>
               nNewCells<span class="opt">++;</span>
            <span class="opt">}</span>
            vec <span class="opt">&gt;&gt;=</span> <span class="num">1</span><span class="opt">;</span>
       <span class="opt">}</span>
         <span class="kwa">if</span> <span class="opt">(</span>nNewCells <span class="opt">==</span> <span class="kwc">Piece</span><span class="opt">::</span>N_ELEM<span class="opt">)</span>
            <span class="kwa">break</span><span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
   m_synched <span class="opt">=</span> <span class="kwa">true</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">bool</span> <span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">lessThan</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> r<span class="opt">) {</span>
   <span class="kwa">if</span> <span class="opt">(</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">!=</span> r<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece<span class="opt">) {</span>
      <span class="kwa">return</span> m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">&lt;</span> r<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece<span class="opt">;</span>
   <span class="opt">}</span>

   <span class="kwd">setCells</span><span class="opt">();</span>
   r<span class="opt">.</span><span class="kwd">setCells</span><span class="opt">();</span>

   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
         <span class="kwb">int</span> lval <span class="opt">=</span> m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>
         <span class="kwb">int</span> rval <span class="opt">=</span> r<span class="opt">.</span>m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>

         <span class="kwa">if</span> <span class="opt">(</span>lval <span class="opt">!=</span> rval<span class="opt">)</span>
            <span class="kwa">return</span> <span class="opt">(</span>lval <span class="opt">&lt;</span> rval<span class="opt">);</span>
      <span class="opt">}</span>
   <span class="opt">}</span>

   <span class="kwa">return false</span><span class="opt">;</span> <span class="slc">// solutions are equal</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Soln</span><span class="opt">::</span><span class="kwd">spin</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> spun<span class="opt">) {</span>
   <span class="kwd">setCells</span><span class="opt">();</span>

   <span class="slc">// swap cells</span>
   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
         TInt8 flipped <span class="opt">=</span> m_cells<span class="opt">[</span>N_ROW <span class="opt">-</span> y <span class="opt">-</span> <span class="num">1</span><span class="opt">][</span>N_COL <span class="opt">-</span> x <span class="opt">-</span> <span class="num">1</span><span class="opt">];</span>
         spun<span class="opt">.</span>m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">] =</span> flipped<span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>

   <span class="slc">// swap first and last pieces (the rest aren&apos;t used)</span>
   spun<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">=</span> m_pieces<span class="opt">[</span>N_PIECE_TYPE <span class="opt">-</span> <span class="num">1</span><span class="opt">].</span>iPiece<span class="opt">;</span>
   spun<span class="opt">.</span>m_synched <span class="opt">=</span> <span class="kwa">true</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="slc">//------------------------------------</span>

Piece <span class="kwc">Piece</span><span class="opt">::</span>s_basePiece<span class="opt">[</span>N_PIECE_TYPE<span class="opt">][</span>N_ORIENT<span class="opt">];</span>

<span class="kwb">const</span> BitVec <span class="kwc">Piece</span><span class="opt">::</span>BaseVecs<span class="opt">[] = {</span>
   <span class="num">0x10f</span><span class="opt">,</span> <span class="num">0x0cb</span><span class="opt">,</span> <span class="num">0x1087</span><span class="opt">,</span> <span class="num">0x427</span><span class="opt">,</span> <span class="num">0x465</span><span class="opt">,</span>
   <span class="num">0x0c7</span><span class="opt">,</span> <span class="num">0x8423</span><span class="opt">,</span> <span class="num">0x0a7</span><span class="opt">,</span> <span class="num">0x187</span><span class="opt">,</span> <span class="num">0x08f</span>
<span class="opt">};</span>

<span class="kwb">int</span> <span class="kwd">floor</span><span class="opt">(</span><span class="kwb">int</span> top<span class="opt">,</span> <span class="kwb">int</span> bot<span class="opt">) {</span>
   <span class="kwb">int</span> toZero <span class="opt">=</span> top <span class="opt">/</span> bot<span class="opt">;</span>
   <span class="slc">// negative numbers should be rounded down, not towards zero</span>
   <span class="kwa">if</span> <span class="opt">((</span>toZero <span class="opt">*</span> bot <span class="opt">!=</span> top<span class="opt">) &amp;&amp; ((</span>top <span class="opt">&lt;</span> <span class="num">0</span><span class="opt">) != (</span>bot <span class="opt">&lt;=</span> <span class="num">0</span><span class="opt">)))</span>
      toZero<span class="opt">--;</span>

   <span class="kwa">return</span> toZero<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">const</span> TUInt32 s_firstOne<span class="opt">[</span><span class="num">32</span><span class="opt">] = {</span>
   <span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
   <span class="num">3</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>

   <span class="num">4</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
   <span class="num">3</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
<span class="opt">};</span>

TUInt32 <span class="kwd">getFirstOne</span><span class="opt">(</span>BitVec v<span class="opt">,</span> TUInt32 startPos <span class="opt">=</span> <span class="num">0</span><span class="opt">) {</span>
   <span class="kwa">if</span> <span class="opt">(</span>v <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
      <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>

   TUInt32 iPos <span class="opt">=</span> startPos<span class="opt">;</span>
   BitVec mask <span class="opt">=</span> <span class="num">0xff</span> <span class="opt">&lt;&lt;</span> startPos<span class="opt">;</span>
   <span class="kwa">if</span> <span class="opt">((</span>mask <span class="opt">&amp;</span> v<span class="opt">) ==</span> <span class="num">0</span><span class="opt">) {</span>
      mask <span class="opt">&lt;&lt;=</span> <span class="num">8</span><span class="opt">;</span> iPos <span class="opt">+=</span> <span class="num">8</span><span class="opt">;</span>
      <span class="kwa">if</span> <span class="opt">((</span>mask <span class="opt">&amp;</span> v<span class="opt">) ==</span> <span class="num">0</span><span class="opt">) {</span>
         mask <span class="opt">&lt;&lt;=</span> <span class="num">8</span><span class="opt">;</span> iPos <span class="opt">+=</span> <span class="num">8</span><span class="opt">;</span>
         <span class="kwa">if</span> <span class="opt">((</span>mask <span class="opt">&amp;</span> v<span class="opt">) ==</span> <span class="num">0</span><span class="opt">) {</span>
            mask <span class="opt">&lt;&lt;=</span> <span class="num">8</span><span class="opt">;</span> iPos <span class="opt">+=</span> <span class="num">8</span><span class="opt">;</span>
       <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>

   TUInt32 result <span class="opt">=</span> <span class="kwd">TUInt32</span><span class="opt">((</span>mask <span class="opt">&amp;</span> v<span class="opt">) &gt;&gt;</span> iPos<span class="opt">);</span>
   TUInt32 resultLow <span class="opt">=</span> result <span class="opt">&amp;</span> <span class="num">0x0f</span><span class="opt">;</span>
   <span class="kwa">if</span> <span class="opt">(</span>resultLow <span class="opt">!=</span> <span class="num">0</span><span class="opt">)</span>
      iPos <span class="opt">+=</span> s_firstOne<span class="opt">[</span>resultLow<span class="opt">];</span>
   <span class="kwa">else</span>
      iPos <span class="opt">+=</span> <span class="num">4</span> <span class="opt">+</span> s_firstOne<span class="opt">[</span>result <span class="opt">&gt;&gt;</span> <span class="num">4</span><span class="opt">];</span>

   <span class="kwa">return</span> iPos<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">setCoordList</span><span class="opt">(</span>BitVec vec<span class="opt">,</span> TPts <span class="opt">&amp;</span> pts<span class="opt">) {</span>
   <span class="kwb">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   BitVec mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
         <span class="kwa">if</span> <span class="opt">(</span>mask <span class="opt">&amp;</span> vec<span class="opt">) {</span>
            pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] =</span> x<span class="opt">;</span>
            pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] =</span> y<span class="opt">;</span>

            iPt<span class="opt">++;</span>
       <span class="opt">}</span>
         mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>

BitVec <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">toBitVector</span><span class="opt">(</span><span class="kwb">const</span> TPts <span class="opt">&amp;</span> pts<span class="opt">) {</span>
   <span class="kwb">int</span> y<span class="opt">,</span> x<span class="opt">;</span>
   BitVec result <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
      x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
      y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

      <span class="kwb">int</span> pos <span class="opt">=</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">getIndex</span><span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">);</span>
      result <span class="opt">|= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> pos<span class="opt">);</span>
   <span class="opt">}</span>

   <span class="kwa">return</span> result<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">shiftUpLines</span><span class="opt">(</span>TPts <span class="opt">&amp;</span> pts<span class="opt">,</span> <span class="kwb">int</span> shift<span class="opt">) {</span>
   <span class="slc">// vertical shifts have a twist</span>
   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
      <span class="kwb">int</span> <span class="opt">&amp;</span> rx <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
      <span class="kwb">int</span> <span class="opt">&amp;</span> ry <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

      <span class="kwa">if</span> <span class="opt">(</span>ry <span class="opt">&amp;</span> shift <span class="opt">&amp;</span> <span class="num">0x1</span><span class="opt">)</span>
         rx<span class="opt">++;</span>
      ry <span class="opt">-=</span> shift<span class="opt">;</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="kwb">int</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">shiftToX0</span><span class="opt">(</span>TPts <span class="opt">&amp;</span> pts<span class="opt">,</span> Instance <span class="opt">&amp;</span> instance<span class="opt">,</span> <span class="kwb">int</span> offsetRow<span class="opt">)</span>
<span class="opt">{</span>
   <span class="slc">// .. determine shift</span>
   <span class="kwb">int</span> x<span class="opt">,</span> y<span class="opt">,</span> iPt<span class="opt">;</span>
   <span class="kwb">int</span> xMin <span class="opt">=</span> pts<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>X<span class="opt">];</span>
   <span class="kwb">int</span> xMax <span class="opt">=</span> xMin<span class="opt">;</span>
   <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
      x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
      y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

      <span class="kwa">if</span> <span class="opt">(</span>x <span class="opt">&lt;</span> xMin<span class="opt">)</span>
         xMin <span class="opt">=</span> x<span class="opt">;</span>
      <span class="kwa">else if</span> <span class="opt">(</span>x <span class="opt">&gt;</span> xMax<span class="opt">)</span>
         xMax <span class="opt">=</span> x<span class="opt">;</span>
   <span class="opt">}</span>

   <span class="slc">// I&apos;m dying for a &apos;foreach&apos; here</span>
   <span class="kwb">int</span> offset <span class="opt">=</span> N_ELEM<span class="opt">;</span>
   <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
      <span class="kwb">int</span> <span class="opt">&amp;</span> rx <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
      <span class="kwb">int</span> <span class="opt">&amp;</span> ry <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

      rx <span class="opt">-=</span> xMin<span class="opt">;</span>

      <span class="slc">// check offset -- leftmost cell on top line</span>
      <span class="kwa">if</span> <span class="opt">((</span>ry <span class="opt">==</span> offsetRow<span class="opt">) &amp;&amp; (</span>rx <span class="opt">&lt;</span> offset<span class="opt">))</span>
         offset <span class="opt">=</span> rx<span class="opt">;</span>
   <span class="opt">}</span>

   instance<span class="opt">.</span>m_offset <span class="opt">=</span> offset<span class="opt">;</span>
   instance<span class="opt">.</span>m_vec <span class="opt">=</span> <span class="kwd">toBitVector</span><span class="opt">(</span>pts<span class="opt">);</span>
   <span class="kwa">return</span> xMax <span class="opt">-</span> xMin<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">setOkPos</span><span class="opt">(</span>TUInt32 isOdd<span class="opt">,</span> <span class="kwb">int</span> w<span class="opt">,</span> <span class="kwb">int</span> h<span class="opt">) {</span>
   Instance <span class="opt">&amp;</span> p <span class="opt">=</span> m_instance<span class="opt">[</span>isOdd<span class="opt">];</span>
   TUInt64 <span class="opt">&amp;</span> allowed <span class="opt">=</span> p<span class="opt">.</span>m_allowed <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   TUInt64 posMask <span class="opt">=</span> <span class="num">1LL</span> <span class="opt">&lt;&lt; (</span>isOdd <span class="opt">*</span> N_COL<span class="opt">);</span>

   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> y <span class="opt">=</span> isOdd<span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW <span class="opt">-</span> h<span class="opt">;</span> y<span class="opt">+=</span><span class="num">2</span><span class="opt">,</span> posMask <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">) {</span>
      <span class="kwa">if</span> <span class="opt">(</span>p<span class="opt">.</span>m_offset<span class="opt">)</span>
         posMask <span class="opt">&lt;&lt;=</span> p<span class="opt">.</span>m_offset<span class="opt">;</span>

      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> xPos <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> xPos <span class="opt">&lt;</span> N_COL <span class="opt">-</span> p<span class="opt">.</span>m_offset<span class="opt">;</span> xPos<span class="opt">++,</span> posMask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">) {</span>
         <span class="slc">// check if the new position is on the board</span>
         <span class="kwa">if</span> <span class="opt">(</span>xPos <span class="opt">&gt;=</span> N_COL <span class="opt">-</span> w<span class="opt">)</span>
            <span class="kwa">continue</span><span class="opt">;</span>

         <span class="slc">// move it to the desired location</span>
         BitVec pieceVec <span class="opt">=</span> p<span class="opt">.</span>m_vec <span class="opt">&lt;&lt;</span> xPos<span class="opt">;</span>

         <span class="kwa">if</span> <span class="opt">(</span><span class="kwc">Board</span><span class="opt">::</span><span class="kwd">hasBadIslandsSingle</span><span class="opt">(</span>pieceVec<span class="opt">,</span> y<span class="opt">))</span>
            <span class="kwa">continue</span><span class="opt">;</span>

         <span class="slc">// position is allowed</span>
         allowed <span class="opt">|=</span> posMask<span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">genOrientation</span><span class="opt">(</span>BitVec vec<span class="opt">,</span> TUInt32 iOrient<span class="opt">,</span> Piece <span class="opt">&amp;</span> target<span class="opt">)</span>
<span class="opt">{</span>
   <span class="slc">// get (x,y) coordinates</span>
   TPts pts<span class="opt">;</span>
   <span class="kwd">setCoordList</span><span class="opt">(</span>vec<span class="opt">,</span> pts<span class="opt">);</span>

   <span class="kwb">int</span> y<span class="opt">,</span> x<span class="opt">,</span> iPt<span class="opt">;</span>
   <span class="kwb">int</span> rot <span class="opt">=</span> iOrient <span class="opt">%</span> <span class="num">6</span><span class="opt">;</span>
   <span class="kwb">int</span> flip <span class="opt">=</span> iOrient <span class="opt">&gt;=</span> <span class="num">6</span><span class="opt">;</span>
   <span class="kwa">if</span> <span class="opt">(</span>flip<span class="opt">) {</span>
      <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++)</span>
         pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] = -</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>
   <span class="opt">}</span>

   <span class="slc">// rotate as necessary</span>
   <span class="kwa">while</span> <span class="opt">(</span>rot<span class="opt">--) {</span>
      <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
         x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
         y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

         <span class="slc">// I just worked this out by hand. Took a while.</span>
         <span class="kwb">int</span> xNew <span class="opt">=</span> <span class="kwd">floor</span><span class="opt">((</span><span class="num">2</span> <span class="opt">*</span> x <span class="opt">-</span> <span class="num">3</span> <span class="opt">*</span> y <span class="opt">+</span> <span class="num">1</span><span class="opt">),</span> <span class="num">4</span><span class="opt">);</span>
         <span class="kwb">int</span> yNew <span class="opt">=</span> <span class="kwd">floor</span><span class="opt">((</span><span class="num">2</span> <span class="opt">*</span> x <span class="opt">+</span> y <span class="opt">+</span> <span class="num">1</span><span class="opt">),</span> <span class="num">2</span><span class="opt">);</span>
         pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] =</span> xNew<span class="opt">;</span>
         pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] =</span> yNew<span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>

   <span class="slc">// determine vertical shift</span>
   <span class="kwb">int</span> yMin <span class="opt">=</span> pts<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>Y<span class="opt">];</span>
   <span class="kwb">int</span> yMax <span class="opt">=</span> yMin<span class="opt">;</span>
   <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
      y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

      <span class="kwa">if</span> <span class="opt">(</span>y <span class="opt">&lt;</span> yMin<span class="opt">)</span>
         yMin <span class="opt">=</span> y<span class="opt">;</span>
      <span class="kwa">else if</span> <span class="opt">(</span>y <span class="opt">&gt;</span> yMax<span class="opt">)</span>
         yMax <span class="opt">=</span> y<span class="opt">;</span>
   <span class="opt">}</span>
   <span class="kwb">int</span> h <span class="opt">=</span> yMax <span class="opt">-</span> yMin<span class="opt">;</span>
   Instance <span class="opt">&amp;</span> even <span class="opt">=</span> target<span class="opt">.</span>m_instance<span class="opt">[</span>EVEN<span class="opt">];</span>
   Instance <span class="opt">&amp;</span> odd <span class="opt">=</span> target<span class="opt">.</span>m_instance<span class="opt">[</span>ODD<span class="opt">];</span>

   <span class="kwd">shiftUpLines</span><span class="opt">(</span>pts<span class="opt">,</span> yMin<span class="opt">);</span>
   <span class="kwb">int</span> w <span class="opt">=</span> <span class="kwd">shiftToX0</span><span class="opt">(</span>pts<span class="opt">,</span> even<span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
   target<span class="opt">.</span><span class="kwd">setOkPos</span><span class="opt">(</span>EVEN<span class="opt">,</span> w<span class="opt">,</span> h<span class="opt">);</span>
   even<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> even<span class="opt">.</span>m_offset<span class="opt">;</span>

   <span class="slc">// shift down one line</span>
   <span class="kwd">shiftUpLines</span><span class="opt">(</span>pts<span class="opt">, -</span><span class="num">1</span><span class="opt">);</span>
   w <span class="opt">=</span> <span class="kwd">shiftToX0</span><span class="opt">(</span>pts<span class="opt">,</span> odd<span class="opt">,</span> <span class="num">1</span><span class="opt">);</span>
   <span class="slc">// shift the bitmask back one line</span>
   odd<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
   target<span class="opt">.</span><span class="kwd">setOkPos</span><span class="opt">(</span>ODD<span class="opt">,</span> w<span class="opt">,</span> h<span class="opt">);</span>
   odd<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> odd<span class="opt">.</span>m_offset<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">genAllOrientations</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++) {</span>
      BitVec refPiece <span class="opt">=</span> BaseVecs<span class="opt">[</span>iPiece<span class="opt">];</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> N_ORIENT<span class="opt">;</span> iOrient<span class="opt">++) {</span>
         Piece <span class="opt">&amp;</span> p <span class="opt">=</span> s_basePiece<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">];</span>
         <span class="kwd">genOrientation</span><span class="opt">(</span>refPiece<span class="opt">,</span> iOrient<span class="opt">,</span> p<span class="opt">);</span>
         <span class="kwa">if</span> <span class="opt">((</span>iPiece <span class="opt">==</span> SKIP_PIECE<span class="opt">) &amp;&amp; ((</span>iOrient <span class="opt">/</span> <span class="num">3</span><span class="opt">) &amp;</span> <span class="num">1</span><span class="opt">))</span>
            p<span class="opt">.</span>m_instance<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>m_allowed <span class="opt">=</span> p<span class="opt">.</span>m_instance<span class="opt">[</span><span class="num">1</span><span class="opt">].</span>m_allowed <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
      <span class="opt">}</span>
   <span class="opt">}</span>

   <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++) {</span>
      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> N_ORIENT<span class="opt">;</span> iOrient<span class="opt">++) {</span>
         TUInt64 mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
         <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iRow <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iRow <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> iRow<span class="opt">++) {</span>
            <span class="kwb">const</span> Instance <span class="opt">&amp;</span> p <span class="opt">=</span> <span class="kwd">getPiece</span><span class="opt">(</span>iPiece<span class="opt">,</span> iOrient<span class="opt">, (</span>iRow <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">));</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iCol <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iCol <span class="opt">&lt;</span> N_COL<span class="opt">;</span> iCol<span class="opt">++) {</span>
               OkPieces <span class="opt">&amp;</span> allowed <span class="opt">=</span> g_okPieces<span class="opt">[</span>iRow<span class="opt">][</span>iCol<span class="opt">];</span>
               <span class="kwa">if</span> <span class="opt">(</span>p<span class="opt">.</span>m_allowed <span class="opt">&amp;</span> mask<span class="opt">) {</span>
                  TInt8 <span class="opt">&amp;</span> nPiece <span class="opt">=</span> allowed<span class="opt">.</span>nPieces<span class="opt">[</span>iPiece<span class="opt">];</span>
                  allowed<span class="opt">.</span>pieceVec<span class="opt">[</span>iPiece<span class="opt">][</span>nPiece<span class="opt">] =</span> p<span class="opt">.</span>m_vec <span class="opt">&lt;&lt;</span> iCol<span class="opt">;</span>
                  nPiece<span class="opt">++;</span>
               <span class="opt">}</span>

               mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">;</span>
            <span class="opt">}</span>
       <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>


<span class="kwc">inline</span> <span class="kwb">const</span> <span class="kwc">Piece</span><span class="opt">::</span>Instance <span class="opt">&amp;</span> <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">getPiece</span><span class="opt">(</span>TUInt32 iPiece<span class="opt">,</span> TUInt32 iOrient<span class="opt">,</span> TUInt32 iParity<span class="opt">) {</span>
   <span class="kwa">return</span> s_basePiece<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">].</span>m_instance<span class="opt">[</span>iParity<span class="opt">];</span>
<span class="opt">}</span>

<span class="slc">// ------------------------------------</span>

<span class="kwc">Board</span><span class="opt">::</span><span class="kwd">Board</span><span class="opt">() :</span>
<span class="kwd">m_curSoln</span><span class="opt">(</span><span class="kwc">Soln</span><span class="opt">::</span>NO_PIECE<span class="opt">),</span> <span class="kwd">m_minSoln</span><span class="opt">(</span>N_PIECE_TYPE<span class="opt">),</span>
<span class="kwd">m_maxSoln</span><span class="opt">(</span><span class="kwc">Soln</span><span class="opt">::</span>NO_PIECE<span class="opt">),</span> <span class="kwd">m_nSoln</span><span class="opt">(</span><span class="num">0</span><span class="opt">)</span>
<span class="opt">{}</span>

TUInt32 g_flip<span class="opt">[] = {</span>
   <span class="num">0x00</span><span class="opt">,</span> <span class="num">0x10</span><span class="opt">,</span> <span class="num">0x08</span><span class="opt">,</span> <span class="num">0x18</span><span class="opt">,</span> <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x14</span><span class="opt">,</span> <span class="num">0x0c</span><span class="opt">,</span> <span class="num">0x1c</span><span class="opt">,</span>
   <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x12</span><span class="opt">,</span> <span class="num">0x0a</span><span class="opt">,</span> <span class="num">0x1a</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x16</span><span class="opt">,</span> <span class="num">0x0e</span><span class="opt">,</span> <span class="num">0x1e</span><span class="opt">,</span>

   <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x11</span><span class="opt">,</span> <span class="num">0x09</span><span class="opt">,</span> <span class="num">0x19</span><span class="opt">,</span> <span class="num">0x05</span><span class="opt">,</span> <span class="num">0x15</span><span class="opt">,</span> <span class="num">0x0d</span><span class="opt">,</span> <span class="num">0x1d</span><span class="opt">,</span>
   <span class="num">0x03</span><span class="opt">,</span> <span class="num">0x13</span><span class="opt">,</span> <span class="num">0x0b</span><span class="opt">,</span> <span class="num">0x1b</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span> <span class="num">0x17</span><span class="opt">,</span> <span class="num">0x0f</span><span class="opt">,</span> <span class="num">0x1f</span><span class="opt">,</span>
<span class="opt">};</span>

<span class="kwc">inline</span> TUInt32 <span class="kwd">flipTwoRows</span><span class="opt">(</span>TUInt32 bits<span class="opt">) {</span>
   TUInt32 flipped <span class="opt">=</span> g_flip<span class="opt">[</span>bits <span class="opt">&gt;&gt;</span> N_COL<span class="opt">] &lt;&lt;</span> N_COL<span class="opt">;</span>
   <span class="kwa">return</span> <span class="opt">(</span>flipped <span class="opt">|</span> g_flip<span class="opt">[</span>bits <span class="opt">&amp;</span> <span class="kwc">Board</span><span class="opt">::</span>TOP_ROW<span class="opt">]);</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">calcAlwaysBad</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">) {</span>
   <span class="kwa">for</span> <span class="opt">(</span>TUInt32 iWord <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iWord <span class="opt">&lt;</span> MAX_ISLAND_OFFSET<span class="opt">;</span> iWord<span class="opt">++) {</span>
      IslandInfo <span class="opt">&amp;</span> isleInfo <span class="opt">=</span> g_islandInfo<span class="opt">[</span>iWord<span class="opt">];</span>
      IslandInfo <span class="opt">&amp;</span> flipped <span class="opt">=</span> g_islandInfo<span class="opt">[</span><span class="kwd">flipTwoRows</span><span class="opt">(</span>iWord<span class="opt">)];</span>

      <span class="kwa">for</span> <span class="opt">(</span>TUInt32 i <span class="opt">=</span> <span class="num">0</span><span class="opt">,</span> mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> i<span class="opt">++,</span> mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">) {</span>
         TUInt32 boardVec <span class="opt">= (</span>i <span class="opt">&lt;&lt;</span> TWO_ROWS<span class="opt">) |</span> iWord<span class="opt">;</span>

         <span class="kwb">int</span> hasBad <span class="opt">=</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
         <span class="kwa">if</span> <span class="opt">(</span>hasBad <span class="opt">==</span> ALWAYS_BAD<span class="opt">) {</span>
            isleInfo<span class="opt">.</span>alwaysBad<span class="opt">[</span>EVEN<span class="opt">] |=</span> mask<span class="opt">;</span>

            TUInt32 flipMask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>g_flip<span class="opt">[</span>i<span class="opt">]);</span>
            flipped<span class="opt">.</span>alwaysBad<span class="opt">[</span>ODD<span class="opt">] |=</span> flipMask<span class="opt">;</span>
       <span class="opt">}</span>
      <span class="opt">}</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="kwb">bool</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">hasBadIslandsSingle</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">)</span>
<span class="opt">{</span>
   BitVec toFill <span class="opt">= ~</span>boardVec<span class="opt">;</span>
   <span class="kwb">bool</span> isOdd <span class="opt">= (</span>row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">);</span>
   <span class="kwa">if</span> <span class="opt">(</span>isOdd<span class="opt">) {</span>
      row<span class="opt">--;</span>
      toFill <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">;</span> <span class="slc">// shift to even aligned</span>
      toFill <span class="opt">|=</span> TOP_ROW<span class="opt">;</span>
   <span class="opt">}</span>

   BitVec startRegion <span class="opt">=</span> TOP_ROW<span class="opt">;</span>
   BitVec lastRow <span class="opt">=</span> TOP_ROW <span class="opt">&lt;&lt; (</span><span class="num">5</span> <span class="opt">*</span> N_COL<span class="opt">);</span>
   BitVec boardMask <span class="opt">=</span> BOARD_MASK<span class="opt">;</span> <span class="slc">// all but the first two bits</span>
   <span class="kwa">if</span> <span class="opt">(</span>row <span class="opt">&gt;=</span> <span class="num">4</span><span class="opt">)</span>
      boardMask <span class="opt">&gt;&gt;= ((</span>row <span class="opt">-</span> <span class="num">4</span><span class="opt">) *</span> N_COL<span class="opt">);</span>
   <span class="kwa">else if</span> <span class="opt">(</span>isOdd <span class="opt">|| (</span>row <span class="opt">==</span> <span class="num">0</span><span class="opt">))</span>
      startRegion <span class="opt">=</span> lastRow<span class="opt">;</span>

   toFill <span class="opt">&amp;=</span> boardMask<span class="opt">;</span>
   startRegion <span class="opt">&amp;=</span> toFill<span class="opt">;</span>

   <span class="kwa">while</span> <span class="opt">(</span>toFill<span class="opt">)    {</span>
      <span class="kwa">if</span> <span class="opt">(</span><span class="kwd">badRegion</span><span class="opt">(</span>toFill<span class="opt">,</span> startRegion<span class="opt">))</span>
         <span class="kwa">return true</span><span class="opt">;</span>
      <span class="kwb">int</span> iPos <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(</span>toFill<span class="opt">);</span>
      startRegion <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPos<span class="opt">);</span>
   <span class="opt">}</span>

   <span class="kwa">return false</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">recordSolution</span><span class="opt">(</span>Soln <span class="opt">&amp;</span> s<span class="opt">) {</span>
   m_nSoln <span class="opt">+=</span> <span class="num">2</span><span class="opt">;</span> <span class="slc">// add solution and its rotation</span>

   <span class="kwa">if</span> <span class="opt">(</span>m_minSoln<span class="opt">.</span><span class="kwd">isEmpty</span><span class="opt">()) {</span>
      m_minSoln <span class="opt">=</span> m_maxSoln <span class="opt">=</span> s<span class="opt">;</span>
      <span class="kwa">return</span><span class="opt">;</span>
   <span class="opt">}</span>

   <span class="kwa">if</span> <span class="opt">(</span>s<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>m_minSoln<span class="opt">))</span>
      m_minSoln <span class="opt">=</span> s<span class="opt">;</span>
   <span class="kwa">else if</span> <span class="opt">(</span>m_maxSoln<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>s<span class="opt">))</span>
      m_maxSoln <span class="opt">=</span> s<span class="opt">;</span>

   Soln spun<span class="opt">;</span>
   s<span class="opt">.</span><span class="kwd">spin</span><span class="opt">(</span>spun<span class="opt">);</span>
   <span class="kwa">if</span> <span class="opt">(</span>spun<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>m_minSoln<span class="opt">))</span>
      m_minSoln <span class="opt">=</span> spun<span class="opt">;</span>
   <span class="kwa">else if</span> <span class="opt">(</span>m_maxSoln<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>spun<span class="opt">))</span>
      m_maxSoln <span class="opt">=</span> spun<span class="opt">;</span>
<span class="opt">}</span>

TUInt32 <span class="kwd">countOnes</span><span class="opt">(</span>BitVec v<span class="opt">) {</span>
   TUInt32 n <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
   <span class="kwa">while</span> <span class="opt">(</span>v<span class="opt">) {</span>
      n<span class="opt">++;</span>
      v <span class="opt">=</span> v <span class="opt">&amp; (</span>v <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
   <span class="opt">}</span>

   <span class="kwa">return</span> n<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">bool</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">badRegion</span><span class="opt">(</span>BitVec <span class="opt">&amp;</span> toFill<span class="opt">,</span> BitVec rNew<span class="opt">)</span>
<span class="opt">{</span>
   <span class="slc">// grow empty region, until it doesn&apos;t change any more</span>
   BitVec region<span class="opt">;</span>
   <span class="kwa">do</span> <span class="opt">{</span>
      region <span class="opt">=</span> rNew<span class="opt">;</span>

      <span class="slc">// simple grow up/down</span>
      rNew <span class="opt">|= (</span>region <span class="opt">&gt;&gt;</span> N_COL<span class="opt">);</span>
      rNew <span class="opt">|= (</span>region <span class="opt">&lt;&lt;</span> N_COL<span class="opt">);</span>

      <span class="slc">// grow right/left</span>
      rNew <span class="opt">|= (</span>region <span class="opt">&amp; ~</span>L_EDGE_MASK<span class="opt">) &gt;&gt;</span> <span class="num">1</span><span class="opt">;</span>
      rNew <span class="opt">|= (</span>region <span class="opt">&amp; ~</span>R_EDGE_MASK<span class="opt">) &lt;&lt;</span> <span class="num">1</span><span class="opt">;</span>

      <span class="slc">// tricky growth</span>
      BitVec evenRegion <span class="opt">=</span> region <span class="opt">&amp; (</span>ROW_0_MASK <span class="opt">&amp; ~</span>L_EDGE_MASK<span class="opt">);</span>
      rNew <span class="opt">|=</span> evenRegion <span class="opt">&gt;&gt; (</span>N_COL <span class="opt">+</span> <span class="num">1</span><span class="opt">);</span>
      rNew <span class="opt">|=</span> evenRegion <span class="opt">&lt;&lt; (</span>N_COL <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
      BitVec oddRegion <span class="opt">=</span> region <span class="opt">&amp; (</span>ROW_1_MASK <span class="opt">&amp; ~</span>R_EDGE_MASK<span class="opt">);</span>
      rNew <span class="opt">|=</span> oddRegion <span class="opt">&gt;&gt; (</span>N_COL <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
      rNew <span class="opt">|=</span> oddRegion <span class="opt">&lt;&lt; (</span>N_COL <span class="opt">+</span> <span class="num">1</span><span class="opt">);</span>

      <span class="slc">// clamp against existing pieces</span>
      rNew <span class="opt">&amp;=</span> toFill<span class="opt">;</span>
   <span class="opt">}</span>
   <span class="kwa">while</span> <span class="opt">((</span>rNew <span class="opt">!=</span> toFill<span class="opt">) &amp;&amp; (</span>rNew <span class="opt">!=</span> region<span class="opt">));</span>

   <span class="slc">// subtract empty region from board</span>
   toFill <span class="opt">^=</span> rNew<span class="opt">;</span>

   TUInt32 nCells <span class="opt">=</span> <span class="kwd">countOnes</span><span class="opt">(</span>toFill<span class="opt">);</span>
   <span class="kwa">return</span> <span class="opt">(</span>nCells <span class="opt">%</span> <span class="kwc">Piece</span><span class="opt">::</span>N_ELEM <span class="opt">!=</span> <span class="num">0</span><span class="opt">);</span>
<span class="opt">}</span>

<span class="kwb">static</span> TUInt32 g_firstRegion<span class="opt">[] = {</span>
   <span class="num">0x00</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span>
   <span class="num">0x08</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x0c</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x0e</span><span class="opt">,</span> <span class="num">0x0f</span><span class="opt">,</span>

   <span class="num">0x10</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span>
   <span class="num">0x18</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x1c</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x1e</span><span class="opt">,</span> <span class="num">0x1f</span>
<span class="opt">};</span>

<span class="kwb">int</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">calcBadIslands</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">)</span>
<span class="opt">{</span>
   BitVec toFill <span class="opt">= ~</span>boardVec<span class="opt">;</span>
   <span class="kwa">if</span> <span class="opt">(</span>row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) {</span>
      row<span class="opt">--;</span>
      toFill <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">;</span>
   <span class="opt">}</span>

   BitVec boardMask <span class="opt">=</span> BOARD_MASK<span class="opt">;</span> <span class="slc">// all but the first two bits</span>
   <span class="kwa">if</span> <span class="opt">(</span>row <span class="opt">&gt;</span> <span class="num">4</span><span class="opt">) {</span>
      <span class="kwb">int</span> boardMaskShift <span class="opt">= (</span>row <span class="opt">-</span> <span class="num">4</span><span class="opt">) *</span> N_COL<span class="opt">;</span>
      boardMask <span class="opt">&gt;&gt;=</span> boardMaskShift<span class="opt">;</span>
   <span class="opt">}</span>
   toFill <span class="opt">&amp;=</span> boardMask<span class="opt">;</span>

   <span class="slc">// a little pre-work to speed things up</span>
   BitVec bottom <span class="opt">= (</span>TOP_ROW <span class="opt">&lt;&lt; (</span><span class="num">5</span> <span class="opt">*</span> N_COL<span class="opt">));</span>
   <span class="kwb">bool</span> filled <span class="opt">= ((</span>bottom <span class="opt">&amp;</span> toFill<span class="opt">) ==</span> bottom<span class="opt">);</span>
   <span class="kwa">while</span> <span class="opt">((</span>bottom <span class="opt">&amp;</span> toFill<span class="opt">) ==</span> bottom<span class="opt">) {</span>
      toFill <span class="opt">^=</span> bottom<span class="opt">;</span>
      bottom <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
   <span class="opt">}</span>

   BitVec startRegion<span class="opt">;</span>
   <span class="kwa">if</span> <span class="opt">(</span>filled <span class="opt">|| (</span>row <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">))</span>
      startRegion <span class="opt">=</span> bottom <span class="opt">&amp;</span> toFill<span class="opt">;</span>
   <span class="kwa">else</span> <span class="opt">{</span>
      startRegion <span class="opt">=</span> g_firstRegion<span class="opt">[</span>toFill <span class="opt">&amp;</span> TOP_ROW<span class="opt">];</span>
      <span class="kwa">if</span> <span class="opt">(</span>startRegion <span class="opt">==</span> <span class="num">0</span><span class="opt">)  {</span>
         startRegion <span class="opt">= (</span>toFill <span class="opt">&gt;&gt;</span> N_COL<span class="opt">) &amp;</span> TOP_ROW<span class="opt">;</span>
         startRegion <span class="opt">=</span> g_firstRegion<span class="opt">[</span>startRegion<span class="opt">];</span>
         startRegion <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">;</span>
      <span class="opt">}</span>
      startRegion <span class="opt">|= (</span>startRegion <span class="opt">&lt;&lt;</span> N_COL<span class="opt">) &amp;</span> toFill<span class="opt">;</span>
   <span class="opt">}</span>

   <span class="kwa">do</span> <span class="opt">{</span>
      <span class="kwa">if</span> <span class="opt">(</span><span class="kwd">badRegion</span><span class="opt">(</span>toFill<span class="opt">,</span> startRegion<span class="opt">))</span>
         <span class="kwa">return</span> ALWAYS_BAD<span class="opt">;</span>
      <span class="kwb">int</span> iPos <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(</span>toFill<span class="opt">);</span>
      startRegion <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPos<span class="opt">);</span>
   <span class="opt">}</span> <span class="kwa">while</span> <span class="opt">(</span>toFill<span class="opt">);</span>

   <span class="kwa">return</span> GOOD<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">int</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">hasBadIslands</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> <span class="kwb">int</span> row<span class="opt">)</span>
<span class="opt">{</span>
   <span class="slc">// skip over any filled rows</span>
   <span class="kwa">while</span> <span class="opt">((</span>boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">) ==</span> TOP_ROW<span class="opt">) {</span>
      boardVec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
      row<span class="opt">++;</span>
   <span class="opt">}</span>

   TUInt32 iInfo <span class="opt">=</span> boardVec <span class="opt">&amp;</span> TOP_2_ROWS<span class="opt">;</span>
   IslandInfo <span class="opt">&amp;</span> info <span class="opt">=</span> g_islandInfo<span class="opt">[</span>iInfo<span class="opt">];</span>

   TUInt32 thirdRow <span class="opt">= (</span>boardVec <span class="opt">&gt;&gt;</span> TWO_ROWS<span class="opt">) &amp;</span> TOP_ROW<span class="opt">;</span>
   TUInt32 mask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>thirdRow<span class="opt">);</span>
   TUInt32 isOdd <span class="opt">=</span> row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">;</span>
   TUInt32 <span class="opt">&amp;</span> alwaysBad <span class="opt">=</span> info<span class="opt">.</span>alwaysBad<span class="opt">[</span>isOdd<span class="opt">];</span>

   <span class="kwa">if</span> <span class="opt">(</span>alwaysBad <span class="opt">&amp;</span> mask<span class="opt">)</span>
      <span class="kwa">return</span> ALWAYS_BAD<span class="opt">;</span>

   <span class="kwa">if</span> <span class="opt">(</span>boardVec <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
      <span class="kwa">return</span> GOOD<span class="opt">;</span>

   <span class="kwa">return</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> row<span class="opt">);</span>
<span class="opt">}</span>

<span class="kwb">void</span> <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">genAllSolutions</span><span class="opt">(</span>BitVec boardVec<span class="opt">,</span> TUInt32 placedPieces<span class="opt">,</span> TUInt32 row<span class="opt">)</span>
<span class="opt">{</span>
   <span class="kwa">while</span> <span class="opt">((</span>boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">) ==</span> TOP_ROW<span class="opt">) {</span>
      boardVec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
      row<span class="opt">++;</span>
   <span class="opt">}</span>
   TUInt32 iNextFill <span class="opt">=</span> s_firstOne<span class="opt">[~</span>boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">];</span>
   <span class="kwb">const</span> OkPieces <span class="opt">&amp;</span> allowed <span class="opt">=</span> g_okPieces<span class="opt">[</span>row<span class="opt">][</span>iNextFill<span class="opt">];</span>

   <span class="kwb">int</span> iPiece <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(~</span>placedPieces<span class="opt">);</span>
   <span class="kwb">int</span> pieceMask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPiece<span class="opt">);</span>

   <span class="kwa">for</span> <span class="opt">(;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++,</span> pieceMask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">)</span>
   <span class="opt">{</span>
      <span class="slc">// skip if we&apos;ve already used this piece</span>
      <span class="kwa">if</span> <span class="opt">(</span>pieceMask <span class="opt">&amp;</span> placedPieces<span class="opt">)</span>
         <span class="kwa">continue</span><span class="opt">;</span>

      placedPieces <span class="opt">|=</span> pieceMask<span class="opt">;</span>

      <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> allowed<span class="opt">.</span>nPieces<span class="opt">[</span>iPiece<span class="opt">];</span> iOrient<span class="opt">++) {</span>
         BitVec pieceVec <span class="opt">=</span> allowed<span class="opt">.</span>pieceVec<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">];</span>

         <span class="slc">// check if piece conflicts with other pieces</span>
         <span class="kwa">if</span> <span class="opt">((</span>pieceVec <span class="opt">&amp;</span> boardVec<span class="opt">) ||</span> <span class="kwd">hasBadIslands</span><span class="opt">(</span>boardVec <span class="opt">|</span> pieceVec<span class="opt">,</span> row<span class="opt">))</span>
            <span class="kwa">continue</span><span class="opt">;</span>

         m_curSoln<span class="opt">.</span><span class="kwd">pushPiece</span><span class="opt">(</span>pieceVec<span class="opt">,</span> iPiece<span class="opt">,</span> row<span class="opt">);</span>

         <span class="slc">// recur or record solution</span>
         <span class="kwa">if</span> <span class="opt">(</span>placedPieces <span class="opt">!=</span> <span class="kwc">Piece</span><span class="opt">::</span>ALL_PIECE_MASK<span class="opt">)</span>
            <span class="kwd">genAllSolutions</span><span class="opt">(</span>boardVec <span class="opt">|</span> pieceVec<span class="opt">,</span> placedPieces<span class="opt">,</span> row<span class="opt">);</span>
         <span class="kwa">else</span>
            <span class="kwd">recordSolution</span><span class="opt">(</span>m_curSoln<span class="opt">);</span>

         <span class="slc">// remove the piece before continuing with a new piece</span>
         m_curSoln<span class="opt">.</span><span class="kwd">popPiece</span><span class="opt">();</span>
      <span class="opt">}</span>

      placedPieces <span class="opt">^=</span> pieceMask<span class="opt">;</span>
   <span class="opt">}</span>
<span class="opt">}</span>

<span class="kwb">int</span> <span class="kwd">main</span><span class="opt">(</span><span class="kwb">int</span> argc<span class="opt">,</span> <span class="kwb">char</span> <span class="opt">* []) {</span>
   <span class="kwa">if</span> <span class="opt">(</span>argc <span class="opt">&gt;</span> <span class="num">2</span><span class="opt">)</span>
      <span class="kwa">return</span> <span class="num">1</span><span class="opt">;</span> <span class="slc">// spec says this is an error</span>

   Board b<span class="opt">;</span>
   <span class="kwc">Piece</span><span class="opt">::</span><span class="kwd">genAllOrientations</span><span class="opt">();</span>
   <span class="kwc">Board</span><span class="opt">::</span><span class="kwd">calcAlwaysBad</span><span class="opt">();</span>
   b<span class="opt">.</span><span class="kwd">genAllSolutions</span><span class="opt">(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
   cout <span class="opt">&lt;&lt;</span> b<span class="opt">.</span>m_nSoln <span class="opt">&lt;&lt;</span> <span class="str">&quot; solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span><span class="opt">;</span>
   cout <span class="opt">&lt;&lt;</span> b<span class="opt">.</span>m_minSoln<span class="opt">.</span><span class="kwd">toString</span><span class="opt">() &lt;&lt;</span> <span class="str">&apos;</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">;</span>
   cout <span class="opt">&lt;&lt;</span> b<span class="opt">.</span>m_maxSoln<span class="opt">.</span><span class="kwd">toString</span><span class="opt">() &lt;&lt;</span> endl<span class="opt">;</span>

   <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>
<span class="opt">}</span>

    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
g++ (Ubuntu 7.2.0-8ubuntu3) 7.2.0


Mon, 30 Oct 2017 21:58:19 GMT

MAKE:
/usr/bin/g++ -c -pipe -O3 -fomit-frame-pointer -march=native   meteor.gpp-5.c++ -o meteor.gpp-5.c++.o &amp;&amp;  \
        /usr/bin/g++ meteor.gpp-5.c++.o -o meteor.gpp-5.gpp_run  
rm meteor.gpp-5.c++

1.29s to complete and log all make actions

COMMAND LINE:
./meteor.gpp-5.gpp_run 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

