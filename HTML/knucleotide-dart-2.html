<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>k-nucleotide Dart&nbsp;#2 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>k-nucleotide Dart&nbsp;#2 program</h2>
    <aside>
      <p><a href="./knucleotide-description.html#knucleotide">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">/**</span>
<span class="com"> * The Computer Language Benchmarks Game</span>
<span class="com"> *</span>
<span class="com"> * http://benchmarksgame.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * Contributed by Dwayne Slater</span>
<span class="com"> * Based on a Java implementation by James McIlree and Tagir Valeev</span>
<span class="com"> */</span>

library knucleotide<span class="opt">;</span>

import <span class="str">&apos;dart:async&apos;</span><span class="opt">;</span>
import <span class="str">&apos;dart:collection&apos;</span><span class="opt">;</span>
import <span class="str">&apos;dart:convert&apos;</span><span class="opt">;</span>
import <span class="str">&apos;dart:io&apos;</span><span class="opt">;</span>
import <span class="str">&apos;dart:isolate&apos;</span><span class="opt">;</span>

<span class="kwa">const</span> codes <span class="opt">=</span> <span class="kwa">const</span> <span class="opt">[-</span><span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">, -</span><span class="num">1</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">3</span><span class="opt">, -</span><span class="num">1</span><span class="opt">, -</span><span class="num">1</span><span class="opt">,</span> <span class="num">2</span><span class="opt">];</span>
<span class="kwa">const</span> nucleotides <span class="opt">=</span> <span class="str">&apos;ACGT&apos;</span><span class="opt">;</span>

<span class="com">/**</span>
<span class="com"> * Contains a map from keys to occurrence count.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">Result</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">Map</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">,</span> <span class="kwb">int</span><span class="opt">&gt;</span> map <span class="opt">= {};</span>
  <span class="kwb">Result</span><span class="opt">();</span>

  &#64;override
  <span class="kwb">String</span> <span class="kwd">toString</span><span class="opt">() =&gt;</span> <span class="str">&quot;$map&quot;</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * A pair of keys to counts.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">KeyPair</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">String</span> key<span class="opt">;</span>
  <span class="kwa">final</span> <span class="kwb">int</span> count<span class="opt">;</span>
  <span class="kwb">KeyPair</span><span class="opt">(</span><span class="kwa">this</span><span class="opt">.</span>key<span class="opt">,</span> <span class="kwa">this</span><span class="opt">.</span>count<span class="opt">);</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Converts a slice of the sequence into a key.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">getKey</span><span class="opt">(</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;</span> arr<span class="opt">,</span> <span class="kwb">int</span> offset<span class="opt">,</span> <span class="kwb">int</span> length<span class="opt">) {</span>
  <span class="kwb">int</span> key <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
  <span class="kwb">int</span> lastOffset <span class="opt">=</span> offset <span class="opt">+</span> length<span class="opt">;</span>
  <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> i <span class="opt">=</span> offset<span class="opt">;</span> i <span class="opt">&lt;</span> lastOffset<span class="opt">;</span> i<span class="opt">++) {</span>
    key <span class="opt">= (</span>key <span class="opt">&lt;&lt;</span> <span class="num">2</span><span class="opt">) +</span> arr<span class="opt">[</span>i<span class="opt">];</span>
  <span class="opt">}</span>
  <span class="kwa">return</span> key<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Creates a map of all the times any key occurs in the sequence.</span>
<span class="com"> */</span>
<span class="kwb">Result</span> <span class="kwd">createFragmentMap</span><span class="opt">(</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;</span> sequence<span class="opt">,</span> <span class="kwb">int</span> offset<span class="opt">,</span> <span class="kwb">int</span> fragmentLength<span class="opt">) {</span>
  <span class="kwa">var</span> res <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">Result</span><span class="opt">();</span>
  <span class="kwb">int</span> lastIndex <span class="opt">=</span> sequence<span class="opt">.</span>length<span class="opt">-</span>fragmentLength<span class="opt">+</span><span class="num">1</span><span class="opt">;</span>
  <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> index <span class="opt">=</span> offset<span class="opt">;</span> index <span class="opt">&lt;</span> lastIndex<span class="opt">;</span> index <span class="opt">+=</span> fragmentLength<span class="opt">) {</span>
    <span class="kwa">var</span> key <span class="opt">=</span> <span class="kwd">getKey</span><span class="opt">(</span>sequence<span class="opt">,</span> index<span class="opt">,</span> fragmentLength<span class="opt">);</span>
    res<span class="opt">.</span>map<span class="opt">[</span>key<span class="opt">] = (</span>res<span class="opt">.</span>map<span class="opt">[</span>key<span class="opt">]</span> ?? <span class="num">0</span><span class="opt">)+</span><span class="num">1</span><span class="opt">;</span>
  <span class="opt">}</span>
  <span class="kwa">return</span> res<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Combines two [Result]s together.</span>
<span class="com"> */</span>
<span class="kwb">Result</span> <span class="kwd">sumTwoMaps</span><span class="opt">(</span><span class="kwb">Result</span> map1<span class="opt">,</span> <span class="kwb">Result</span> map2<span class="opt">) {</span>
  map2<span class="opt">.</span>map<span class="opt">.</span><span class="kwd">forEach</span><span class="opt">((</span>key<span class="opt">,</span> value<span class="opt">) =&gt;</span> map1<span class="opt">.</span>map<span class="opt">[</span>key<span class="opt">] +=</span> value<span class="opt">);</span>
  <span class="kwa">return</span> map1<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Converts a key to a string.</span>
<span class="com"> */</span>
<span class="kwb">String</span> <span class="kwd">keyToString</span><span class="opt">(</span><span class="kwb">int</span> key<span class="opt">,</span> <span class="kwb">int</span> length<span class="opt">) {</span>
  <span class="kwa">var</span> res <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">String</span><span class="opt">&gt;(</span>length<span class="opt">);</span>
  <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> length<span class="opt">;</span> i<span class="opt">++) {</span>
    res<span class="opt">[</span>length <span class="opt">-</span> i <span class="opt">-</span> <span class="num">1</span><span class="opt">] =</span> nucleotides<span class="opt">[</span>key <span class="opt">&amp;</span> <span class="num">0x3</span><span class="opt">];</span>
    key <span class="opt">&gt;&gt;=</span> <span class="num">2</span><span class="opt">;</span>
  <span class="opt">}</span>
  <span class="kwa">return</span> res<span class="opt">.</span><span class="kwd">join</span><span class="opt">();</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Write out the frequencies for each key that appears in the given [Result].</span>
<span class="com"> */</span>
<span class="kwb">String</span> <span class="kwd">writeFrequencies</span><span class="opt">(</span><span class="kwb">double</span> totalCount<span class="opt">,</span> <span class="kwb">int</span> keyLength<span class="opt">,</span> <span class="kwb">Result</span> frequencies<span class="opt">) {</span>
  <span class="kwa">var</span> freq <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">KeyPair</span><span class="opt">&gt;(</span>frequencies<span class="opt">.</span>map<span class="opt">.</span>length<span class="opt">);</span>
  <span class="kwa">var</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
  frequencies<span class="opt">.</span>map<span class="opt">.</span><span class="kwd">forEach</span><span class="opt">((</span>key<span class="opt">,</span> cnt<span class="opt">) =&gt;</span> freq<span class="opt">[</span>i<span class="opt">++] =</span> <span class="kwa">new</span> <span class="kwb">KeyPair</span><span class="opt">(</span><span class="kwd">keyToString</span><span class="opt">(</span>key<span class="opt">,</span> keyLength<span class="opt">),</span> cnt<span class="opt">));</span>
  freq<span class="opt">.</span><span class="kwd">sort</span><span class="opt">((</span>a<span class="opt">,</span> b<span class="opt">) =&gt;</span> b<span class="opt">.</span>count<span class="opt">.</span><span class="kwd">compareTo</span><span class="opt">(</span>a<span class="opt">.</span>count<span class="opt">));</span>
  <span class="kwa">var</span> sb <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">StringBuffer</span><span class="opt">();</span>
  freq<span class="opt">.</span><span class="kwd">forEach</span><span class="opt">((</span>entry<span class="opt">) {</span>
    sb<span class="opt">.</span><span class="kwd">write</span><span class="opt">(</span><span class="str">&quot;${entry.key} ${(entry.count * 100.0/totalCount).toStringAsFixed(3)}</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">);</span>
  <span class="opt">});</span>
  <span class="kwa">return</span> <span class="opt">(</span>sb<span class="opt">..</span><span class="kwd">write</span><span class="opt">(</span><span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">)).</span><span class="kwd">toString</span><span class="opt">();</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Converts a character list into a list of codes.</span>
<span class="com"> */</span>
<span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;</span> <span class="kwd">toCodes</span><span class="opt">(</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;</span> sequence<span class="opt">) {</span>
  <span class="kwa">var</span> l <span class="opt">=</span> sequence<span class="opt">.</span>length<span class="opt">;</span>
  <span class="kwa">var</span> result <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;(</span>l<span class="opt">);</span>
  <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> l<span class="opt">;</span> i<span class="opt">++) {</span>
    result<span class="opt">[</span>i<span class="opt">] =</span> codes<span class="opt">[</span>sequence<span class="opt">[</span>i<span class="opt">] &amp;</span> <span class="num">0x7</span><span class="opt">];</span>
  <span class="opt">}</span>
  <span class="kwa">return</span> result<span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Write out the occurrences of the given nucleotideFragment in the list of</span>
<span class="com"> * pending results.</span>
<span class="com"> */</span>
<span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">String</span><span class="opt">&gt;</span> <span class="kwd">writeCount</span><span class="opt">(</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">Result</span><span class="opt">&gt;&gt;</span> futureResults<span class="opt">,</span> <span class="kwb">String</span> nucleotideFragment<span class="opt">)</span> async <span class="opt">{</span>
  <span class="kwa">var</span> key <span class="opt">=</span> <span class="kwd">toCodes</span><span class="opt">(</span>nucleotideFragment<span class="opt">.</span>codeUnits<span class="opt">);</span>
  <span class="kwa">var</span> k <span class="opt">=</span> <span class="kwd">getKey</span><span class="opt">(</span>key<span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> key<span class="opt">.</span>length<span class="opt">);</span>
  <span class="kwa">var</span> count <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
  await <span class="kwb">Future</span><span class="opt">.</span><span class="kwd">wait</span><span class="opt">(</span>futureResults<span class="opt">.</span><span class="kwd">map</span><span class="opt">((</span>future<span class="opt">) {</span>
    <span class="kwa">return</span> future<span class="opt">.</span><span class="kwd">then</span><span class="opt">((</span>f<span class="opt">) {</span>
      count <span class="opt">+=</span> f<span class="opt">.</span>map<span class="opt">[</span>k<span class="opt">]</span> ?? <span class="num">0</span><span class="opt">;</span>
    <span class="opt">});</span>
  <span class="opt">}).</span><span class="kwd">toList</span><span class="opt">());</span>
  <span class="kwa">return</span> <span class="str">&quot;$count</span><span class="esc">\t</span><span class="str">$nucleotideFragment</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">;</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Reads sequence data from stdin.</span>
<span class="com"> */</span>
<span class="kwb">FutureOr</span><span class="opt">&lt;</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;&gt;</span> <span class="kwd">read</span><span class="opt">({</span><span class="kwb">bool</span> sync<span class="opt">:</span> <span class="kwa">false</span><span class="opt">})</span> async <span class="opt">{</span>
  <span class="kwa">if</span> <span class="opt">(!</span>sync<span class="opt">) {</span>
    <span class="slc">// The old Dart k-nucleotide benchmark used stdin.readLineSync, which is</span>
    <span class="slc">// way slower than doing async stream transforms.</span>
    <span class="kwa">var</span> three <span class="opt">=</span> <span class="kwa">false</span><span class="opt">;</span>
    <span class="kwa">var</span> builder <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">BytesBuilder</span><span class="opt">(</span>copy<span class="opt">:</span> <span class="kwa">false</span><span class="opt">);</span>
    <span class="kwb">StreamSubscription</span><span class="opt">&lt;</span><span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;&gt;</span> sub<span class="opt">;</span>
    sub <span class="opt">=</span> stdin
      <span class="opt">.</span><span class="kwd">transform</span><span class="opt">(</span><span class="kwa">const</span> <span class="kwb">Latin</span><span class="num">1</span><span class="kwb">Decoder</span><span class="opt">())</span>
      <span class="opt">.</span><span class="kwd">transform</span><span class="opt">(</span><span class="kwa">const</span> <span class="kwb">LineSplitter</span><span class="opt">())</span>
      <span class="opt">.</span><span class="kwd">listen</span><span class="opt">((</span>line<span class="opt">) {</span>
        <span class="kwa">if</span> <span class="opt">(</span>three<span class="opt">) {</span>
          <span class="kwa">if</span> <span class="opt">(</span>line<span class="opt">[</span><span class="num">0</span><span class="opt">] !=</span> <span class="str">&apos;&gt;&apos;</span><span class="opt">) {</span>
            builder<span class="opt">.</span><span class="kwd">add</span><span class="opt">(</span>line<span class="opt">.</span>codeUnits<span class="opt">);</span>
          <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
            sub<span class="opt">.</span><span class="kwd">cancel</span><span class="opt">();</span>
          <span class="opt">}</span>
        <span class="opt">}</span> <span class="kwa">else if</span> <span class="opt">(</span>line<span class="opt">.</span><span class="kwd">startsWith</span><span class="opt">(</span><span class="str">&apos;&gt;THREE&apos;</span><span class="opt">)) {</span>
          three <span class="opt">=</span> <span class="kwa">true</span><span class="opt">;</span>
        <span class="opt">}</span>
      <span class="opt">});</span>
    await sub<span class="opt">.</span><span class="kwd">asFuture</span><span class="opt">();</span>
    <span class="kwa">var</span> bytes <span class="opt">=</span> builder<span class="opt">.</span><span class="kwd">takeBytes</span><span class="opt">();</span>
    <span class="kwa">return</span> <span class="kwd">toCodes</span><span class="opt">(</span>bytes<span class="opt">);</span>
  <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
    <span class="kwa">var</span> encoding <span class="opt">=</span> <span class="kwb">Encoding</span><span class="opt">.</span><span class="kwd">getByName</span><span class="opt">(</span><span class="str">&quot;ISO_8859-1:1987&quot;</span><span class="opt">);</span>
    <span class="kwb">String</span> line<span class="opt">;</span>
    <span class="kwa">while</span> <span class="opt">(</span>stdin<span class="opt">.</span><span class="kwd">readLineSync</span><span class="opt">().</span><span class="kwd">substring</span><span class="opt">(</span><span class="num">0</span><span class="opt">,</span> <span class="num">6</span><span class="opt">) !=</span> <span class="str">&apos;&gt;THREE&apos;</span><span class="opt">);</span>

    <span class="kwa">var</span> builder <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">BytesBuilder</span><span class="opt">(</span>copy<span class="opt">:</span> <span class="kwa">false</span><span class="opt">);</span>
    <span class="kwa">while</span> <span class="opt">((</span>line <span class="opt">=</span> stdin<span class="opt">.</span><span class="kwd">readLineSync</span><span class="opt">(</span>encoding<span class="opt">:</span> encoding<span class="opt">)) !=</span> <span class="kwa">null</span> <span class="opt">&amp;&amp;</span> line<span class="opt">[</span><span class="num">0</span><span class="opt">] !=</span> <span class="str">&apos;&gt;&apos;</span><span class="opt">) {</span>
      builder<span class="opt">.</span><span class="kwd">add</span><span class="opt">(</span>line<span class="opt">.</span>codeUnits<span class="opt">);</span>
    <span class="opt">}</span>

    <span class="kwa">var</span> bytes <span class="opt">=</span> builder<span class="opt">.</span><span class="kwd">takeBytes</span><span class="opt">();</span>
    <span class="kwa">return</span> <span class="kwd">toCodes</span><span class="opt">(</span>bytes<span class="opt">);</span>
  <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * An object that runs on an Isolate.</span>
<span class="com"> */</span>
abstract <span class="kwa">class</span> <span class="kwb">Task</span> <span class="opt">{</span>
  <span class="kwd">run</span><span class="opt">();</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * The sequence data for the current Isolate.</span>
<span class="com"> */</span>
<span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">int</span><span class="opt">&gt;</span> isolateSequence<span class="opt">;</span>

<span class="com">/**</span>
<span class="com"> * Initializes the per-isolate sequence data.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">InitIsolateSequenceTask</span> <span class="kwa">extends</span> <span class="kwb">Task</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">String</span> sequence<span class="opt">;</span>

  <span class="kwb">InitIsolateSequenceTask</span><span class="opt">(</span><span class="kwa">this</span><span class="opt">.</span>sequence<span class="opt">);</span>

  <span class="kwa">void</span> <span class="kwd">run</span><span class="opt">() {</span>
    isolateSequence <span class="opt">=</span> sequence<span class="opt">.</span>codeUnits<span class="opt">;</span>
  <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Creates a FragmentMap using the sequence data and the given parameters.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">CreateFragmentMapTask</span> <span class="kwa">extends</span> <span class="kwb">Task</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">int</span> index<span class="opt">,</span> fragmentLength<span class="opt">;</span>
  <span class="kwb">CreateFragmentMapTask</span><span class="opt">(</span><span class="kwa">this</span><span class="opt">.</span>index<span class="opt">,</span> <span class="kwa">this</span><span class="opt">.</span>fragmentLength<span class="opt">);</span>

  <span class="kwd">run</span><span class="opt">() =&gt;</span> <span class="kwd">createFragmentMap</span><span class="opt">(</span>isolateSequence<span class="opt">,</span> index<span class="opt">,</span> fragmentLength<span class="opt">);</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Handles the submission and completion of tasks sent to an Isolate.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">IsolateHandler</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">Isolate</span> _isolate<span class="opt">;</span>
  <span class="kwa">final</span> <span class="kwb">SendPort</span> _taskport<span class="opt">;</span>
  <span class="kwa">final</span> <span class="kwb">RawReceivePort</span> _port<span class="opt">;</span>
  <span class="kwa">final</span> <span class="kwb">Queue</span><span class="opt">&lt;</span><span class="kwb">Completer</span><span class="opt">&gt;</span> _completers <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">Queue</span><span class="opt">&lt;</span><span class="kwb">Completer</span><span class="opt">&gt;();</span>
  <span class="kwb">IsolateHandler</span><span class="opt">.</span><span class="kwd">_</span><span class="opt">(</span><span class="kwa">this</span><span class="opt">.</span>_isolate<span class="opt">,</span> <span class="kwa">this</span><span class="opt">.</span>_taskport<span class="opt">,</span> <span class="kwa">this</span><span class="opt">.</span>_port<span class="opt">);</span>

  <span class="com">/**</span>
<span class="com">   * Creates an IsolateHandler.</span>
<span class="com">   */</span>
  <span class="kwa">static</span> <span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">IsolateHandler</span><span class="opt">&gt;</span> <span class="kwd">create</span><span class="opt">()</span> async <span class="opt">{</span>
    <span class="kwb">IsolateHandler</span> handler<span class="opt">;</span>
    <span class="kwa">var</span> completer <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">Completer</span><span class="opt">&lt;</span><span class="kwb">SendPort</span><span class="opt">&gt;.</span><span class="kwd">sync</span><span class="opt">();</span>
    <span class="kwa">var</span> port <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">RawReceivePort</span><span class="opt">((</span>data<span class="opt">) {</span>
      <span class="kwa">if</span> <span class="opt">(!</span>completer<span class="opt">.</span>isCompleted<span class="opt">) {</span>
        completer<span class="opt">.</span><span class="kwd">complete</span><span class="opt">(</span>data<span class="opt">);</span>
      <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
        handler<span class="opt">.</span><span class="kwd">_finish</span><span class="opt">(</span>data<span class="opt">);</span>
      <span class="opt">}</span>
    <span class="opt">});</span>
    <span class="kwa">var</span> isolate <span class="opt">=</span> await <span class="kwb">Isolate</span><span class="opt">.</span><span class="kwd">spawn</span><span class="opt">(</span>_runner<span class="opt">,</span> port<span class="opt">.</span>sendPort<span class="opt">);</span>
    <span class="kwa">var</span> taskport <span class="opt">=</span> await completer<span class="opt">.</span>future<span class="opt">;</span>
    <span class="kwa">return</span> handler <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">IsolateHandler</span><span class="opt">.</span><span class="kwd">_</span><span class="opt">(</span>isolate<span class="opt">,</span> taskport<span class="opt">,</span> port<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Main &quot;loop&quot; of the task running Isolate.</span>
<span class="com">   */</span>
  <span class="kwa">static void</span> <span class="kwd">_runner</span><span class="opt">(</span><span class="kwb">SendPort</span> inport<span class="opt">) {</span>
    <span class="kwa">var</span> port <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">RawReceivePort</span><span class="opt">((</span><span class="kwb">Task</span> task<span class="opt">) {</span>
      inport<span class="opt">.</span><span class="kwd">send</span><span class="opt">(</span>task<span class="opt">.</span><span class="kwd">run</span><span class="opt">());</span>
    <span class="opt">});</span>
    inport<span class="opt">.</span><span class="kwd">send</span><span class="opt">(</span>port<span class="opt">.</span>sendPort<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="kwa">void</span> <span class="kwd">_finish</span><span class="opt">(</span>data<span class="opt">) {</span>
    _completers<span class="opt">.</span><span class="kwd">removeFirst</span><span class="opt">().</span><span class="kwd">complete</span><span class="opt">(</span>data<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Schedules a task to the underlying Isolate.</span>
<span class="com">   */</span>
  <span class="kwb">Future</span><span class="opt">&lt;</span>T<span class="opt">&gt;</span> schedule<span class="opt">&lt;</span>T<span class="opt">&gt;(</span><span class="kwb">Task</span> task<span class="opt">) {</span>
    <span class="kwa">var</span> c <span class="opt">=</span> <span class="kwa">new</span> <span class="kwb">Completer</span><span class="opt">&lt;</span>T<span class="opt">&gt;.</span><span class="kwd">sync</span><span class="opt">();</span>
    _taskport<span class="opt">.</span><span class="kwd">send</span><span class="opt">(</span>task<span class="opt">);</span>
    _completers<span class="opt">.</span><span class="kwd">add</span><span class="opt">(</span>c<span class="opt">);</span>
    <span class="kwa">return</span> c<span class="opt">.</span>future<span class="opt">;</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Gets the current load on the Isolate.</span>
<span class="com">   */</span>
  <span class="kwb">int</span> get weight <span class="opt">=&gt;</span> _completers<span class="opt">.</span>length<span class="opt">;</span>

  <span class="com">/**</span>
<span class="com">   * Closes the IsolateHandler and cleans up associated resources.</span>
<span class="com">   */</span>
  <span class="kwa">void</span> <span class="kwd">close</span><span class="opt">() {</span>
    _isolate<span class="opt">.</span><span class="kwd">kill</span><span class="opt">();</span>
    _port<span class="opt">.</span><span class="kwd">close</span><span class="opt">();</span>
  <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Manages multiple [IsolateHandler] objects.</span>
<span class="com"> * Allows tasks to be scheduled on the least loaded Isolate.</span>
<span class="com"> */</span>
<span class="kwa">class</span> <span class="kwb">IsolateExecutor</span> <span class="opt">{</span>
  <span class="kwa">final</span> <span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">IsolateHandler</span><span class="opt">&gt;</span> _handlers<span class="opt">;</span>

  <span class="kwb">IsolateExecutor</span><span class="opt">.</span><span class="kwd">_</span><span class="opt">(</span><span class="kwa">this</span><span class="opt">.</span>_handlers<span class="opt">);</span>

  <span class="com">/**</span>
<span class="com">   * Create an IsolateExecutor. By default this creates an isolate for each</span>
<span class="com">   * core of the current running system.</span>
<span class="com">   */</span>
  <span class="kwa">static</span> <span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">IsolateExecutor</span><span class="opt">&gt;</span> <span class="kwd">create</span><span class="opt">({</span><span class="kwb">int</span> n<span class="opt">})</span> async <span class="opt">{</span>
    n ??<span class="opt">=</span> <span class="kwb">Platform</span><span class="opt">.</span>numberOfProcessors<span class="opt">;</span>
    <span class="kwa">var</span> handlers <span class="opt">=</span> await <span class="kwb">Future</span><span class="opt">.</span><span class="kwd">wait</span><span class="opt">(</span><span class="kwa">new</span> <span class="kwb">Iterable</span><span class="opt">.</span><span class="kwd">generate</span><span class="opt">(</span>n<span class="opt">, (</span>_<span class="opt">) =&gt;</span> <span class="kwb">IsolateHandler</span><span class="opt">.</span><span class="kwd">create</span><span class="opt">()));</span>
    <span class="kwa">return new</span> <span class="kwb">IsolateExecutor</span><span class="opt">.</span><span class="kwd">_</span><span class="opt">(</span>handlers<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Schedules a task on ALL of the IsolateHandlers.</span>
<span class="com">   */</span>
  <span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">List</span><span class="opt">&lt;</span>T<span class="opt">&gt;&gt;</span> scheduleAll<span class="opt">&lt;</span>T<span class="opt">&gt;(</span><span class="kwb">Task</span> task<span class="opt">) {</span>
    <span class="kwa">var</span> futures <span class="opt">=</span> _handlers<span class="opt">.</span><span class="kwd">map</span><span class="opt">((</span>handler<span class="opt">) =&gt;</span> handler<span class="opt">.</span><span class="kwd">schedule</span><span class="opt">(</span>task<span class="opt">)).</span><span class="kwd">toList</span><span class="opt">();</span>
    <span class="kwa">return</span> <span class="kwb">Future</span><span class="opt">.</span><span class="kwd">wait</span><span class="opt">(</span>futures<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Schedules a task on the least loaded IsolateHandler.</span>
<span class="com">   */</span>
  <span class="kwb">Future</span><span class="opt">&lt;</span>T<span class="opt">&gt;</span> schedule<span class="opt">&lt;</span>T<span class="opt">&gt;(</span><span class="kwb">Task</span> task<span class="opt">) {</span>
    <span class="kwa">var</span> leastLoad <span class="opt">=</span> _handlers<span class="opt">.</span>first<span class="opt">;</span>
    <span class="kwa">var</span> leastLoadScore <span class="opt">=</span> leastLoad<span class="opt">.</span>weight<span class="opt">;</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> i<span class="opt">=</span><span class="num">1</span><span class="opt">;</span> i<span class="opt">&lt;</span>_handlers<span class="opt">.</span>length<span class="opt">;</span> i<span class="opt">++) {</span>
      <span class="kwa">var</span> handler <span class="opt">=</span> _handlers<span class="opt">[</span>i<span class="opt">];</span>
      <span class="kwa">var</span> score <span class="opt">=</span> handler<span class="opt">.</span>weight<span class="opt">;</span>
      <span class="kwa">if</span> <span class="opt">(</span>score <span class="opt">&lt;</span> leastLoadScore<span class="opt">) {</span>
        leastLoad <span class="opt">=</span> handler<span class="opt">;</span>
      <span class="opt">}</span>
    <span class="opt">}</span>
    <span class="kwa">return</span> leastLoad<span class="opt">.</span><span class="kwd">schedule</span><span class="opt">(</span>task<span class="opt">);</span>
  <span class="opt">}</span>

  <span class="com">/**</span>
<span class="com">   * Closes all IsolateHandlers.</span>
<span class="com">   */</span>
  <span class="kwa">void</span> <span class="kwd">close</span><span class="opt">() {</span>
    _handlers<span class="opt">.</span><span class="kwd">forEach</span><span class="opt">((</span>h<span class="opt">) =&gt;</span> h<span class="opt">.</span><span class="kwd">close</span><span class="opt">());</span>
  <span class="opt">}</span>
<span class="opt">}</span>

<span class="com">/**</span>
<span class="com"> * Dispatches fragment map creation to an isolate,</span>
<span class="com"> */</span>
<span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">Result</span><span class="opt">&gt;&gt;</span> <span class="kwd">dispatchFragmentTasks</span><span class="opt">(</span><span class="kwb">IsolateExecutor</span> executor<span class="opt">,</span> <span class="kwb">int</span> fragmentLength<span class="opt">) {</span>
  <span class="kwb">List</span><span class="opt">&lt;</span><span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">Result</span><span class="opt">&gt;&gt;</span> tasks <span class="opt">= [];</span>
  <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">int</span> index <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> index <span class="opt">&lt;</span> fragmentLength<span class="opt">;</span> index<span class="opt">++) {</span>
    tasks<span class="opt">.</span><span class="kwd">add</span><span class="opt">(</span>executor<span class="opt">.</span><span class="kwd">schedule</span><span class="opt">(</span><span class="kwa">new</span> <span class="kwb">CreateFragmentMapTask</span><span class="opt">(</span>index<span class="opt">,</span> fragmentLength<span class="opt">)));</span>
  <span class="opt">}</span>
  <span class="kwa">return</span> tasks<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwd">main</span><span class="opt">()</span> async <span class="opt">{</span>
  <span class="slc">// Start creating the executor while we wait on IO to finish</span>
  <span class="kwa">var</span> executorFuture <span class="opt">=</span> <span class="kwb">IsolateExecutor</span><span class="opt">.</span><span class="kwd">create</span><span class="opt">();</span>
  <span class="slc">// Read the data from stdin</span>
  <span class="kwa">var</span> sequence <span class="opt">=</span> await <span class="kwd">read</span><span class="opt">();</span>
  <span class="slc">// Wait on the executor to start if it hasn&apos;t finished yet</span>
  <span class="kwa">var</span> executor <span class="opt">=</span> await executorFuture<span class="opt">;</span>

  <span class="slc">// We start by intializing all the executor isolates with the sequence we read</span>
  <span class="slc">// Unfortunately, Dart has to copy all the data when doing this</span>
  <span class="slc">// To optimize this a bit, we can send it as a String :P (Saves about 20 seconds from my testing)</span>
  executor<span class="opt">.</span><span class="kwd">scheduleAll</span><span class="opt">(</span><span class="kwa">new</span> <span class="kwb">InitIsolateSequenceTask</span><span class="opt">(</span><span class="kwa">new</span> <span class="kwb">String</span><span class="opt">.</span><span class="kwd">fromCharCodes</span><span class="opt">(</span>sequence<span class="opt">)));</span>

  <span class="kwa">var</span> futureBuffer <span class="opt">= &lt;</span><span class="kwb">Future</span><span class="opt">&lt;</span><span class="kwb">String</span><span class="opt">&gt;&gt;[</span>
    <span class="slc">// Dispatch a task to get the frequencies with a fragment length of 1</span>
    <span class="kwd">dispatchFragmentTasks</span><span class="opt">(</span>executor<span class="opt">,</span> <span class="num">1</span><span class="opt">)[</span><span class="num">0</span><span class="opt">]</span>
      <span class="opt">.</span><span class="kwd">then</span><span class="opt">((</span>result<span class="opt">) =&gt;</span> <span class="kwd">writeFrequencies</span><span class="opt">(</span>sequence<span class="opt">.</span>length<span class="opt">.</span><span class="kwd">toDouble</span><span class="opt">(),</span> <span class="num">1</span><span class="opt">,</span> result<span class="opt">)),</span>
    <span class="slc">// Dispatch a task to get the frequencies with a fragment length of 2</span>
    <span class="kwb">Future</span><span class="opt">.</span><span class="kwd">wait</span><span class="opt">(</span><span class="kwd">dispatchFragmentTasks</span><span class="opt">(</span>executor<span class="opt">,</span> <span class="num">2</span><span class="opt">))</span>
      <span class="opt">.</span><span class="kwd">then</span><span class="opt">((</span>results<span class="opt">) =&gt;</span> <span class="kwd">writeFrequencies</span><span class="opt">((</span>sequence<span class="opt">.</span>length<span class="opt">-</span><span class="num">1</span><span class="opt">).</span><span class="kwd">toDouble</span><span class="opt">(),</span> <span class="num">2</span><span class="opt">,</span> <span class="kwd">sumTwoMaps</span><span class="opt">(</span>results<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> results<span class="opt">[</span><span class="num">1</span><span class="opt">]))),</span>
  <span class="opt">];</span>
  <span class="slc">// Dispatch tasks for each of the nucleotideFragments</span>
  <span class="kwa">const</span> <span class="opt">[</span><span class="str">&quot;GGT&quot;</span><span class="opt">,</span> <span class="str">&quot;GGTA&quot;</span><span class="opt">,</span> <span class="str">&quot;GGTATT&quot;</span><span class="opt">,</span> <span class="str">&quot;GGTATTTTAATT&quot;</span><span class="opt">,</span> <span class="str">&quot;GGTATTTTAATTTATAGT&quot;</span><span class="opt">].</span><span class="kwd">forEach</span><span class="opt">((</span>nucleotideFragment<span class="opt">) {</span>
    futureBuffer<span class="opt">.</span><span class="kwd">add</span><span class="opt">(</span><span class="kwd">writeCount</span><span class="opt">(</span><span class="kwd">dispatchFragmentTasks</span><span class="opt">(</span>executor<span class="opt">,</span> nucleotideFragment<span class="opt">.</span>length<span class="opt">),</span> nucleotideFragment<span class="opt">));</span>
  <span class="opt">});</span>

  <span class="slc">// Wait for everything to finish, then join the resulting output together</span>
  stdout<span class="opt">.</span><span class="kwd">write</span><span class="opt">((</span>await <span class="kwb">Future</span><span class="opt">.</span><span class="kwd">wait</span><span class="opt">(</span>futureBuffer<span class="opt">)).</span><span class="kwd">join</span><span class="opt">());</span>
  executor<span class="opt">.</span><span class="kwd">close</span><span class="opt">();</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
Dart VM version: 1.24.2 (Thu Jun 22 08:43:26 2017) on "linux_x64"


Thu, 26 Oct 2017 21:21:11 GMT

MAKE:
make: 'knucleotide.dart-2.dart_run' is up to date.

0.01s to complete and log all make actions

COMMAND LINE:
/opt/src/dartsdk-linux-x64-release/dart-sdk/bin/dart  knucleotide.dart-2.dart 0 &lt; knucleotide-input25000000.txt

PROGRAM OUTPUT:
A 30.295
T 30.151
C 19.800
G 19.754

AA 9.177
TA 9.132
AT 9.131
TT 9.091
CA 6.002
AC 6.001
AG 5.987
GA 5.984
CT 5.971
TC 5.971
GT 5.957
TG 5.956
CC 3.917
GC 3.911
CG 3.909
GG 3.902

1471758	GGT
446535	GGTA
47336	GGTATT
893	GGTATTTTAATT
893	GGTATTTTAATTTATAGT
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

