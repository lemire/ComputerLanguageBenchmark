<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>regex-redux Ada 2005 GNAT&nbsp;#5 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>regex-redux Ada 2005 GNAT&nbsp;#5 program</h2>
    <aside>
      <p><a href="./regexredux-description.html#regexredux">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="slc">--  The Computer Language Benchmarks Game</span>
<span class="slc">--  http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">--</span>
<span class="slc">--  Restarted from RegexDNA program, Georg Bauhaus in March 2017</span>
<span class="slc">--</span>
<span class="slc">--  This version uses the GNAT Spitbol Pattern matching libraries</span>
<span class="slc">--  rather than the more commonly used Unix-style regex libraries.</span>

<span class="kwa">with</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">.</span>Patterns<span class="opt">;</span>     <span class="kwa">use</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">.</span>Patterns<span class="opt">,</span>
                                    GNAT<span class="opt">.</span>Spitbol<span class="opt">;</span>
<span class="kwa">with</span> U<span class="opt">;</span>
<span class="kwa">package</span> DNA <span class="kwa">is</span>

   <span class="kwa">subtype</span> Variant_Index <span class="kwa">is</span> <span class="kwb">Positive</span> <span class="kwa">range</span> <span class="num">1</span> <span class="opt">..</span> <span class="num">9</span><span class="opt">;</span>
   Variant_Labels <span class="opt">:</span> <span class="kwa">constant array</span> <span class="opt">(</span>Variant_Index<span class="opt">)</span> <span class="kwa">of</span> VString <span class="opt">:= (</span>
      V <span class="opt">(</span><span class="str">&quot;agggtaaa|tttaccct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;a[act]ggtaaa|tttacc[agt]t&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;ag[act]gtaaa|tttac[agt]ct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;agg[act]taaa|ttta[agt]cct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;agggt[cgt]aa|tt[acg]accct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;agggta[cgt]a|t[acg]taccct&quot;</span><span class="opt">),</span>
      V <span class="opt">(</span><span class="str">&quot;agggtaa[cgt]|[acg]ttaccct&quot;</span><span class="opt">));</span>

   Variant_Patterns <span class="opt">:</span> <span class="kwa">constant array</span> <span class="opt">(</span>Variant_Index<span class="opt">)</span> <span class="kwa">of</span> Pattern <span class="opt">:=</span>
     <span class="opt">(</span> <span class="slc">--  corresponding alternations in SPITBOL notation</span>
       <span class="num">1</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;agggtaaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;tttaccct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">2</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">) &amp;</span> Any <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;gggtaaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;tttaccc&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">))</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">3</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;a&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;act&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ggtaaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;tttacc&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;agt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;t&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">4</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ag&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;act&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;gtaaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;tttac&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;agt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">5</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;agg&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;act&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;taaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ttta&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;agt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;cct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">6</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;aggg&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;aaa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ttt&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ccct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">7</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;agggt&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;aa&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;tt&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;accct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">8</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;agggta&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;a&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;t&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;t&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;taccct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">),</span>
       <span class="num">9</span> <span class="opt">=&gt; ((</span>BreakX <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;agggtaa&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;cgt&quot;</span><span class="opt">))</span> <span class="kwa">or</span>
             <span class="opt">(</span>BreakX <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">) &amp;</span> Any <span class="opt">(</span><span class="str">&quot;acg&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;ttaccct&quot;</span><span class="opt">)</span> <span class="kwa">or</span>
             Cancel<span class="opt">));</span>

   <span class="kwa">type</span> IubSub <span class="kwa">is</span>
      <span class="kwa">record</span>
         Element     <span class="opt">:</span> Pattern<span class="opt">;</span>
         Replacement <span class="opt">:</span> VString<span class="opt">;</span>
      <span class="kwa">end record</span><span class="opt">;</span>

   Iub <span class="opt">:</span> <span class="kwa">constant array</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> <span class="num">5</span><span class="opt">)</span> <span class="kwa">of</span> IubSub <span class="opt">:=</span>
     <span class="slc">--  tHa[Nt]</span>
     <span class="opt">((</span><span class="str">&quot;tHa&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;Nt&quot;</span><span class="opt">),</span> V <span class="opt">(</span><span class="str">&quot;&lt;4&gt;&quot;</span><span class="opt">)),</span>

      <span class="slc">--  aND|caN|Ha[DS]|WaS</span>
      <span class="opt">(</span><span class="str">&quot;aND&quot;</span> <span class="kwa">or</span> <span class="str">&quot;caN&quot;</span> <span class="kwa">or</span> <span class="opt">(</span><span class="str">&quot;Ha&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;DS&quot;</span><span class="opt">))</span> <span class="kwa">or</span> <span class="str">&quot;WaS&quot;</span><span class="opt">,</span> V <span class="opt">(</span><span class="str">&quot;&lt;3&gt;&quot;</span><span class="opt">)),</span>

      <span class="slc">--  a[NSt]|BY</span>
      <span class="opt">((</span><span class="str">&quot;a&quot;</span> <span class="opt">&amp;</span> Any <span class="opt">(</span><span class="str">&quot;NSt&quot;</span><span class="opt">))</span> <span class="kwa">or</span> <span class="str">&quot;BY&quot;</span><span class="opt">,</span> V <span class="opt">(</span><span class="str">&quot;&lt;2&gt;&quot;</span><span class="opt">)),</span>

      <span class="slc">--  A POSIX quantifier &quot;*&quot; attached to a character class means greedy</span>
      <span class="slc">--  matching.  In SPITBOL, a quantified character class with greed added</span>
      <span class="slc">--  is the realm of SPAN, and similarly of BREAK in case of negation.</span>

      <span class="slc">--  &lt;[^&gt;]*&gt;</span>
      <span class="opt">(</span><span class="str">&quot;&lt;&quot;</span> <span class="opt">&amp;</span> Break <span class="opt">(</span><span class="str">&quot;&gt;&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;&gt;&quot;</span><span class="opt">,</span> V <span class="opt">(</span><span class="str">&quot;|&quot;</span><span class="opt">)),</span>

      <span class="slc">--   \|[^|][^|]*\|</span>
      <span class="opt">(</span><span class="str">&quot;|&quot;</span> <span class="opt">&amp;</span> NotAny <span class="opt">(</span><span class="str">&quot;|&quot;</span><span class="opt">) &amp;</span> Break <span class="opt">(</span><span class="str">&quot;|&quot;</span><span class="opt">) &amp;</span> <span class="str">&quot;|&quot;</span><span class="opt">,</span>  V <span class="opt">(</span><span class="str">&quot;-&quot;</span><span class="opt">)));</span>

   Seq <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>
<span class="kwa">end</span> DNA<span class="opt">;</span>

<span class="kwa">with</span> Ada<span class="opt">.</span>Strings<span class="opt">.</span>Unbounded<span class="opt">;</span>
<span class="kwa">package</span> U <span class="kwa">renames</span> Ada<span class="opt">.</span>Strings<span class="opt">.</span>Unbounded<span class="opt">;</span>

<span class="kwa">with</span> Ada<span class="opt">.</span>Text_IO<span class="opt">;</span>          <span class="kwa">use</span> Ada<span class="opt">.</span>Text_IO<span class="opt">;</span>
<span class="kwa">with</span> Ada<span class="opt">.</span>Integer_Text_IO<span class="opt">;</span>  <span class="kwa">use</span> Ada<span class="opt">.</span>Integer_Text_IO<span class="opt">;</span>
<span class="kwa">with</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">;</span>         <span class="kwa">use</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">;</span>

<span class="kwa">with</span> DNA<span class="opt">.</span>Matching<span class="opt">;</span>
<span class="kwa">with</span> DNA<span class="opt">.</span>Replacing<span class="opt">;</span>        <span class="kwa">use</span> DNA<span class="opt">;</span>
<span class="kwa">with</span> Block_Input<span class="opt">;</span>
<span class="kwa">with</span> Preprocessing<span class="opt">;</span>

<span class="kwa">with</span> U<span class="opt">;</span>

<span class="kwa">procedure</span> Regexredux <span class="kwa">is</span>

   Initial_Length<span class="opt">,</span> Code_Length<span class="opt">,</span> Processed_Length <span class="opt">:</span> <span class="kwb">Natural</span><span class="opt">;</span>
   Input_Text                                    <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>

<span class="kwa">begin</span>  <span class="slc">-- Regexredux</span>

   Ada<span class="opt">.</span>Integer_Text_IO<span class="opt">.</span>Default_Width <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span> <span class="slc">--  format output number display</span>

   <span class="slc">--  Read FASTA Sequence</span>
   Block_Input<span class="opt">.</span>Open_Stdin<span class="opt">;</span>
   Input_Text <span class="opt">:=</span> Block_Input<span class="opt">.</span>Read<span class="opt">;</span>
   Block_Input<span class="opt">.</span>Close_Stdin<span class="opt">;</span>

   Initial_Length <span class="opt">:=</span> Input_Text<span class="kwd">&apos;Length</span><span class="opt">;</span>

   DNA<span class="opt">.</span>Seq <span class="opt">:=</span> <span class="kwa">new</span> <span class="kwb">String</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> Initial_Length<span class="opt">);</span>
   <span class="slc">--  remove unwanted elements</span>
   <span class="kwa">declare</span>
      Cleaner <span class="opt">:</span> Preprocessing<span class="opt">.</span>Removal <span class="opt">(</span>Input_Text<span class="opt">);</span>
   <span class="kwa">begin</span>
      Cleaner<span class="opt">.</span>Run <span class="opt">(</span>Clean <span class="opt">=&gt;</span> Seq<span class="opt">);</span>
      Cleaner<span class="opt">.</span>Done <span class="opt">(</span>Last <span class="opt">=&gt;</span> Code_Length<span class="opt">);</span>
      U<span class="opt">.</span>Free <span class="opt">(</span>Input_Text<span class="opt">);</span>
   <span class="kwa">end</span><span class="opt">;</span>

   DNA<span class="opt">.</span>Matching<span class="opt">.</span>Count_Matches <span class="opt">(</span>Seq<span class="opt">,</span> Limit <span class="opt">=&gt;</span> Code_Length<span class="opt">);</span>

   <span class="slc">--  print counts for patterns</span>
   <span class="kwa">for</span> Variant <span class="kwa">in</span> Variant_Index <span class="kwa">loop</span>
      Put <span class="opt">(</span>S <span class="opt">(</span>Variant_Labels <span class="opt">(</span>Variant<span class="opt">)) &amp;</span> <span class="str">&quot; &quot;</span><span class="opt">);</span>
      Put <span class="opt">(</span>Item <span class="opt">=&gt;</span> DNA<span class="opt">.</span>Matching<span class="opt">.</span>Get <span class="opt">(</span>Variant<span class="opt">));</span>
      New_Line<span class="opt">;</span>
   <span class="kwa">end loop</span><span class="opt">;</span>

   <span class="slc">--  perform replacements and get the new length</span>
   DNA<span class="opt">.</span>Replacing<span class="opt">.</span>Perform_Replacements
     <span class="opt">(</span>Limit      <span class="opt">=&gt;</span> Code_Length<span class="opt">,</span>
      New_Length <span class="opt">=&gt;</span> Processed_Length<span class="opt">);</span>

   New_Line<span class="opt">;</span>
   Put <span class="opt">(</span>Item <span class="opt">=&gt;</span> Initial_Length<span class="opt">);</span>
   New_Line<span class="opt">;</span>
   Put <span class="opt">(</span>Item <span class="opt">=&gt;</span> Code_Length<span class="opt">);</span>
   New_Line<span class="opt">;</span>
   Put <span class="opt">(</span>Item <span class="opt">=&gt;</span> Processed_Length<span class="opt">);</span>
   New_Line<span class="opt">;</span>

<span class="kwa">end</span> Regexredux<span class="opt">;</span>

<span class="kwa">with</span> U<span class="opt">;</span>
<span class="kwa">package</span> Preprocessing <span class="kwa">is</span>

   <span class="slc">--  removal of line feeds and FASTA sequence descriptions</span>

   Separator  <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">String</span> <span class="opt">:= (</span><span class="num">1</span> <span class="opt">=&gt;</span> ASCII<span class="opt">.</span>LF<span class="opt">);</span>

   <span class="kwa">task type</span> Removal <span class="opt">(</span>Input_Text <span class="opt">:</span> <span class="kwa">access constant</span> <span class="kwb">String</span><span class="opt">)</span> <span class="kwa">is</span>
      <span class="kwa">pragma</span> Storage_Size <span class="opt">(</span><span class="num">2</span><span class="opt">**</span><span class="num">16</span><span class="opt">);</span>
      <span class="kwa">entry</span> Run <span class="opt">(</span>Clean <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">);</span>
      <span class="kwa">entry</span> Done <span class="opt">(</span>Last <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">);</span>
      <span class="slc">--  number of characters after removal</span>
   <span class="kwa">end</span> Removal<span class="opt">;</span>

<span class="kwa">end</span> Preprocessing<span class="opt">;</span>


<span class="kwa">package</span> DNA<span class="opt">.</span>Matching <span class="kwa">is</span>

   <span class="kwa">procedure</span> Count_Matches <span class="opt">(</span>Seq <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span> Limit <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">);</span>

   <span class="kwa">function</span> Get <span class="opt">(</span>Variant <span class="opt">:</span> Variant_Index<span class="opt">)</span> <span class="kwa">return</span> <span class="kwb">Natural</span><span class="opt">;</span>

<span class="kwa">end</span> DNA<span class="opt">.</span>Matching<span class="opt">;</span>

<span class="kwa">package</span> DNA<span class="opt">.</span>Replacing <span class="kwa">is</span>
   Number_Of_Tasks <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Positive</span> <span class="opt">:=</span> <span class="num">4</span><span class="opt">;</span>

   <span class="kwa">procedure</span> Perform_Replacements
     <span class="opt">(</span>Limit      <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span>
      New_Length <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">);</span>
<span class="kwa">end</span> DNA<span class="opt">.</span>Replacing<span class="opt">;</span>


<span class="kwa">with</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">.</span>Patterns<span class="opt">;</span>    <span class="kwa">use</span> GNAT<span class="opt">.</span>Spitbol<span class="opt">.</span>Patterns<span class="opt">;</span>

<span class="kwa">package body</span> Preprocessing <span class="kwa">is</span>

   <span class="kwa">task body</span> Removal <span class="kwa">is</span>

      Sequence <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>
      Start<span class="opt">,</span>
        Stop   <span class="opt">:</span> <span class="kwa">aliased</span> <span class="kwb">Natural</span> <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
      Last     <span class="opt">:</span> <span class="kwb">Natural</span>         <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
      Tail     <span class="opt">:</span> <span class="kwb">Natural</span>         <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
      <span class="slc">--  Tail is also the value for Removal.Done.Last</span>

      <span class="kwa">function</span> Transfer <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span>
         <span class="slc">--  puts good substrings in the resulting sequence</span>
      <span class="kwa">begin</span>
         <span class="kwa">if</span> Start <span class="opt">&gt;</span> Last <span class="kwa">then</span>
            Sequence <span class="opt">(</span>Tail <span class="opt">+</span> <span class="num">1</span> <span class="opt">..</span>
                      Tail <span class="opt">+</span> <span class="num">1</span> <span class="opt">+ (</span>Start <span class="opt">-</span> Last<span class="opt">) -</span> <span class="num">1</span><span class="opt">) :=</span>
              Input_Text <span class="opt">(</span>Last <span class="opt">+</span> <span class="num">1</span> <span class="opt">..</span> Start<span class="opt">);</span>
            Tail <span class="opt">:=</span> Tail <span class="opt">+ (</span>Start <span class="opt">-</span> Last<span class="opt">);</span>
         <span class="kwa">end if</span><span class="opt">;</span>
         Last <span class="opt">:=</span> Stop<span class="opt">;</span>
         <span class="kwa">return</span> Stop <span class="opt">&gt;=</span> Input_Text<span class="kwd">&apos;Length</span><span class="opt">;</span>
      <span class="kwa">end</span> Transfer<span class="opt">;</span>

      Unwanted <span class="opt">:</span> <span class="kwa">constant</span> Pattern <span class="opt">:=</span>
        <span class="opt">(</span>Setcur <span class="opt">(</span>Start<span class="kwd">&apos;Access</span><span class="opt">)</span>
           <span class="opt">&amp; ((</span><span class="str">&apos;&gt;&apos;</span> <span class="opt">&amp;</span> Break <span class="opt">(</span>Separator<span class="opt">))</span> <span class="kwa">or</span> Separator<span class="opt">)</span>
           <span class="opt">&amp;</span> Setcur <span class="opt">(</span>Stop<span class="kwd">&apos;Access</span><span class="opt">)</span>
           <span class="opt">&amp; (+</span>Transfer<span class="kwd">&apos;Unrestricted_Access</span><span class="opt">));</span>

   <span class="kwa">begin</span>
      <span class="kwa">accept</span> Run <span class="opt">(</span>Clean <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">)</span> <span class="kwa">do</span>
         Sequence <span class="opt">:=</span> Clean<span class="opt">;</span>
      <span class="kwa">end</span> Run<span class="opt">;</span>

      Match <span class="opt">(</span>Input_Text<span class="opt">.</span><span class="kwa">all</span><span class="opt">,</span> Pat <span class="opt">=&gt;</span> Unwanted<span class="opt">);</span>

      <span class="kwa">accept</span> Done <span class="opt">(</span>Last <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">)</span> <span class="kwa">do</span>
         Last <span class="opt">:=</span> Tail<span class="opt">;</span>
      <span class="kwa">end</span> Done<span class="opt">;</span>
   <span class="kwa">end</span> Removal<span class="opt">;</span>

<span class="kwa">end</span> Preprocessing<span class="opt">;</span>

<span class="kwa">with</span> Ada<span class="opt">.</span>Unchecked_Conversion<span class="opt">,</span> Ada<span class="opt">.</span>Synchronous_Task_Control<span class="opt">;</span>
<span class="kwa">package body</span> DNA<span class="opt">.</span>Matching <span class="kwa">is</span>

   <span class="kwa">task type</span> Service <span class="opt">(</span>Sequence <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">)</span> <span class="kwa">is</span>
      <span class="slc">--  matches one pattern concurrently</span>

      <span class="kwa">entry</span> Match_Variant <span class="opt">(</span>Variant <span class="opt">:</span> Variant_Index<span class="opt">);</span>
      <span class="kwa">entry</span> Get <span class="opt">(</span>Number <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">);</span>
   <span class="kwa">end</span> Service<span class="opt">;</span>

   <span class="kwa">package</span> Sem <span class="kwa">renames</span> Ada<span class="opt">.</span>Synchronous_Task_Control<span class="opt">;</span>

   Ready         <span class="opt">:</span> Sem<span class="opt">.</span>Suspension_Object<span class="opt">;</span>
   Done          <span class="opt">:</span> <span class="kwb">Boolean</span>                          <span class="opt">:=</span> <span class="kwd">False</span> <span class="kwa">with</span> Volatile<span class="opt">;</span>
   No_Of_Matches <span class="opt">:</span> <span class="kwa">array</span> <span class="opt">(</span>Variant_Index<span class="opt">)</span> <span class="kwa">of</span> <span class="kwb">Integer</span> <span class="opt">:= (</span><span class="kwa">others</span> <span class="opt">=&gt; -</span><span class="num">1</span><span class="opt">);</span>

   <span class="kwa">function</span> Get <span class="opt">(</span>Variant <span class="opt">:</span> Variant_Index<span class="opt">)</span> <span class="kwa">return</span> <span class="kwb">Natural</span> <span class="kwa">is</span>
   <span class="kwa">begin</span>
      <span class="kwa">if not</span> Done <span class="kwa">then</span>
         Sem<span class="opt">.</span>Suspend_Until_True <span class="opt">(</span>Ready<span class="opt">);</span>
         Done <span class="opt">:=</span> <span class="kwd">True</span><span class="opt">;</span>
      <span class="kwa">end if</span><span class="opt">;</span>
      <span class="kwa">return</span> No_Of_Matches <span class="opt">(</span>Variant<span class="opt">);</span>
   <span class="kwa">end</span> Get<span class="opt">;</span>

   <span class="kwa">procedure</span> Count_Matches <span class="opt">(</span>Seq <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span> Limit <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">)</span> <span class="kwa">is</span>
      <span class="kwa">subtype</span> P <span class="kwa">is</span> U<span class="opt">.</span>String_Access <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> Limit<span class="opt">);</span>
      <span class="kwa">function</span> To_P <span class="kwa">is new</span> Ada<span class="opt">.</span>Unchecked_Conversion <span class="opt">(</span>U<span class="opt">.</span>String_Access<span class="opt">,</span> P<span class="opt">);</span>
      Worker <span class="opt">:</span> <span class="kwa">array</span> <span class="opt">(</span>Variant_Index<span class="opt">)</span> <span class="kwa">of</span> Service <span class="opt">(</span>Sequence <span class="opt">=&gt;</span> To_P <span class="opt">(</span>Seq<span class="opt">));</span>
   <span class="kwa">begin</span>
      <span class="slc">--  assign tasks</span>
      <span class="kwa">for</span> Variant <span class="kwa">in</span> Variant_Index <span class="kwa">loop</span>
         Worker <span class="opt">(</span>Variant<span class="opt">).</span>Match_Variant <span class="opt">(</span>Variant<span class="opt">);</span>
      <span class="kwa">end loop</span><span class="opt">;</span>
      <span class="kwa">for</span> Variant <span class="kwa">in</span> Variant_Index <span class="kwa">loop</span>
         Worker <span class="opt">(</span>Variant<span class="opt">).</span>Get <span class="opt">(</span>Number <span class="opt">=&gt;</span> No_Of_Matches <span class="opt">(</span>Variant<span class="opt">));</span>
      <span class="kwa">end loop</span><span class="opt">;</span>
      Sem<span class="opt">.</span>Set_True <span class="opt">(</span>Ready<span class="opt">);</span>
   <span class="kwa">end</span> Count_Matches<span class="opt">;</span>

   <span class="kwa">task body</span> Service <span class="kwa">is</span>
      Count <span class="opt">:</span> <span class="kwb">Natural</span><span class="opt">;</span>

      <span class="kwa">function</span> Inc_Count <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span>
         <span class="slc">--  another occurrence of a pattern</span>
      <span class="kwa">begin</span>
         Count <span class="opt">:=</span> Count <span class="opt">+</span> <span class="num">1</span><span class="opt">;</span>
         <span class="kwa">return</span> <span class="kwd">False</span><span class="opt">;</span>
      <span class="kwa">end</span> Inc_Count<span class="opt">;</span>

      Variant <span class="opt">:</span> Variant_Index<span class="opt">;</span>
   <span class="kwa">begin</span>  <span class="slc">--  Service</span>
      <span class="kwa">accept</span> Match_Variant <span class="opt">(</span>Variant <span class="opt">:</span> Variant_Index<span class="opt">)</span> <span class="kwa">do</span>
         Service<span class="opt">.</span>Variant <span class="opt">:=</span> Variant<span class="opt">;</span>
      <span class="kwa">end</span> Match_Variant<span class="opt">;</span>

      Count <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
      Match <span class="opt">(</span>Subject <span class="opt">=&gt;</span> Sequence<span class="opt">.</span><span class="kwa">all</span><span class="opt">,</span>
             Pat <span class="opt">=&gt; (</span>Variant_Patterns <span class="opt">(</span>Variant<span class="opt">)</span>
                       <span class="opt">&amp; (+</span>Inc_Count<span class="kwd">&apos;Unrestricted_Access</span><span class="opt">)));</span>

      <span class="kwa">accept</span> Get <span class="opt">(</span>Number <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">)</span> <span class="kwa">do</span>
         Number <span class="opt">:=</span> Count<span class="opt">;</span>
      <span class="kwa">end</span> Get<span class="opt">;</span>
   <span class="kwa">end</span> Service<span class="opt">;</span>

<span class="kwa">end</span> DNA<span class="opt">.</span>Matching<span class="opt">;</span>

<span class="kwa">with</span> Ada<span class="opt">.</span>Unchecked_Deallocation<span class="opt">;</span>
<span class="kwa">with</span> U<span class="opt">;</span>
<span class="kwa">package body</span> DNA<span class="opt">.</span>Replacing <span class="kwa">is</span>

   <span class="kwa">function</span> Find_UB <span class="opt">(</span>Est<span class="opt">,</span> Ub <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">)</span> <span class="kwa">return</span> <span class="kwb">Positive</span><span class="opt">;</span>
   <span class="slc">--  position in Seq safe for splitting</span>

   <span class="kwa">task type</span> Service
     <span class="opt">(</span>Sequence <span class="opt">:</span> <span class="kwa">access</span> <span class="kwb">String</span><span class="opt">;</span> From<span class="opt">,</span> To <span class="opt">:</span> <span class="kwb">Natural</span><span class="opt">;</span> Bordering <span class="opt">:</span> <span class="kwb">Boolean</span><span class="opt">)</span>
     <span class="slc">--  Perform substitutions for matches between From and To.  If Bordering,</span>
     <span class="slc">--  then use the last of the patterns in DNA.Iub, otherwise the ones</span>
     <span class="slc">--  preceding it, in sequence.</span>
   <span class="kwa">is</span>
      <span class="kwa">entry</span> Save <span class="opt">(</span>Pointer <span class="opt">:</span> <span class="kwa">out</span> U<span class="opt">.</span>String_Access<span class="opt">;</span> Last <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">);</span>
      <span class="slc">--  Pointer at new text, which runs up to Last.</span>
   <span class="kwa">end</span> Service<span class="opt">;</span>

   <span class="kwa">procedure</span> Perform_Replacements
     <span class="opt">(</span>Limit <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span> New_Length <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">)</span>
   <span class="kwa">is</span>
      <span class="kwa">type</span> Worker <span class="kwa">is access</span> Service<span class="opt">;</span>
      Here  <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span>
      There <span class="opt">:</span> <span class="kwb">Natural</span><span class="opt">;</span>
      Sz    <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Positive</span> <span class="opt">:= (</span>Limit <span class="opt">+</span> Number_Of_Tasks<span class="opt">) /</span> Number_Of_Tasks<span class="opt">;</span>
      Work  <span class="opt">:</span> <span class="kwa">array</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> Number_Of_Tasks<span class="opt">)</span> <span class="kwa">of</span> Worker<span class="opt">;</span>
   <span class="kwa">begin</span>
      There <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
      <span class="kwa">for</span> N <span class="kwa">in</span> <span class="num">1</span> <span class="opt">..</span> Number_Of_Tasks <span class="kwa">loop</span>
         Here     <span class="opt">:=</span> There <span class="opt">+</span> <span class="num">1</span><span class="opt">;</span>
         There    <span class="opt">:=</span> Find_UB <span class="opt">(</span>N<span class="opt">*</span>Sz<span class="opt">,</span> Limit<span class="opt">);</span>
         Work <span class="opt">(</span>N<span class="opt">) :=</span> <span class="kwa">new</span> Service
           <span class="opt">(</span>Sequence <span class="opt">=&gt;</span> Seq<span class="opt">,</span> From <span class="opt">=&gt;</span> Here<span class="opt">,</span> To <span class="opt">=&gt;</span> There<span class="opt">,</span> Bordering <span class="opt">=&gt;</span> <span class="kwd">False</span><span class="opt">);</span>
      <span class="kwa">end loop</span><span class="opt">;</span>
      <span class="slc">--  concatenate the buffers and perform the final replacements in that:</span>
      <span class="kwa">declare</span>
         Wipe    <span class="opt">:</span> Worker<span class="opt">;</span>
         Scratch <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>
         <span class="kwa">procedure</span> Free <span class="kwa">is new</span> Ada<span class="opt">.</span>Unchecked_Deallocation <span class="opt">(</span>Service<span class="opt">,</span> Worker<span class="opt">);</span>
      <span class="kwa">begin</span>
         Here  <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span>
         There <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
         <span class="kwa">for</span> Job <span class="kwa">of</span> Work <span class="kwa">loop</span>
            Here <span class="opt">:=</span> Here <span class="opt">+</span> There<span class="opt">;</span>
            Job<span class="opt">.</span>Save <span class="opt">(</span>Scratch<span class="opt">,</span> There<span class="opt">);</span>
            Seq <span class="opt">(</span>Here <span class="opt">..</span> Here<span class="opt">+</span>There<span class="opt">-</span><span class="num">1</span><span class="opt">) :=</span> Scratch <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> There<span class="opt">);</span>
            Free <span class="opt">(</span>Job<span class="opt">);</span>
         <span class="kwa">end loop</span><span class="opt">;</span>
         Wipe <span class="opt">:=</span> <span class="kwa">new</span> Service <span class="opt">(</span>Sequence <span class="opt">=&gt;</span> Seq<span class="opt">,</span> From <span class="opt">=&gt;</span> <span class="num">1</span><span class="opt">,</span> To <span class="opt">=&gt;</span> Here<span class="opt">+</span>There<span class="opt">-</span><span class="num">1</span><span class="opt">,</span>
                              Bordering <span class="opt">=&gt;</span> <span class="kwd">True</span><span class="opt">);</span>
         Wipe<span class="opt">.</span>Save <span class="opt">(</span>Scratch<span class="opt">,</span> There<span class="opt">);</span>
      <span class="kwa">end</span><span class="opt">;</span>
      New_Length <span class="opt">:=</span> There<span class="opt">;</span>
   <span class="kwa">end</span> Perform_Replacements<span class="opt">;</span>

   <span class="kwa">function</span> Safe_Split <span class="opt">(</span>Near <span class="opt">:</span> <span class="kwb">String</span><span class="opt">)</span> <span class="kwa">return</span> <span class="kwb">Natural</span> <span class="kwa">is</span>
      N          <span class="opt">:</span> <span class="kwa">aliased</span> <span class="kwb">Natural</span><span class="opt">;</span>
      Looking_At <span class="opt">:</span> <span class="kwa">constant</span> Pattern <span class="opt">:=</span>
        <span class="opt">((</span>Break <span class="opt">(</span><span class="str">&quot;A&quot;</span><span class="opt">) &amp;</span> Setcur <span class="opt">(</span>N<span class="kwd">&apos;Access</span><span class="opt">))</span>
           <span class="kwa">or</span>
         <span class="opt">(</span>Break <span class="opt">(</span><span class="str">&quot;a&quot;</span><span class="opt">) &amp;</span> Setcur <span class="opt">(</span>N<span class="kwd">&apos;Access</span><span class="opt">) &amp;</span> <span class="str">&quot;aaa&quot;</span><span class="opt">));</span>
   <span class="kwa">begin</span>
      <span class="kwa">if</span> Match <span class="opt">(</span>Near<span class="opt">,</span> Pat <span class="opt">=&gt;</span> Looking_At<span class="opt">)</span> <span class="kwa">then</span>
         <span class="kwa">return</span> Near<span class="kwd">&apos;First</span> <span class="opt">+</span> N<span class="opt">;</span>
      <span class="kwa">end if</span><span class="opt">;</span>
      <span class="kwa">raise</span> Constraint_Error <span class="kwa">with</span> <span class="str">&quot;cannot safely split up seq&quot;</span><span class="opt">;</span>
   <span class="kwa">end</span> Safe_Split<span class="opt">;</span>

   <span class="kwa">function</span> Find_UB <span class="opt">(</span>Est<span class="opt">,</span> Ub <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">)</span> <span class="kwa">return</span> <span class="kwb">Positive</span> <span class="kwa">is</span>
      Limit <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Natural</span>  <span class="opt">:=</span> <span class="kwb">Positive</span><span class="kwd">&apos;Min</span> <span class="opt">(</span>Est <span class="opt">+</span> <span class="num">1000</span><span class="opt">,</span> Ub<span class="opt">);</span>
   <span class="kwa">begin</span>
      <span class="kwa">if</span> Est <span class="opt">&lt;</span> Ub <span class="kwa">then</span>
         <span class="kwa">return</span> Safe_Split <span class="opt">(</span>Seq <span class="opt">(</span>Est <span class="opt">..</span> Limit<span class="opt">));</span>
      <span class="kwa">else</span>
         <span class="kwa">return</span> Ub<span class="opt">;</span>
      <span class="kwa">end if</span><span class="opt">;</span>
   <span class="kwa">end</span> Find_UB<span class="opt">;</span>

   <span class="kwa">task body</span> Service <span class="kwa">is</span>
      Sub <span class="opt">:</span> <span class="kwa">array</span> <span class="opt">(</span><span class="kwb">Boolean</span><span class="opt">)</span> <span class="kwa">of</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>  <span class="slc">--  flipping buffers</span>
      Rpl <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>

      <span class="slc">--  framing matches and replacements so far:</span>
      Tail  <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span>
      Start <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span>
      Hit   <span class="opt">:</span> <span class="kwa">aliased</span> <span class="kwb">Natural</span><span class="opt">;</span>
      Stop  <span class="opt">:</span> <span class="kwa">aliased</span> <span class="kwb">Natural</span><span class="opt">;</span>

      Source <span class="opt">:</span> <span class="kwb">Boolean</span><span class="opt">;</span>

      <span class="kwa">function</span> Last_Repl <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span>
         L <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Natural</span> <span class="opt">:=</span> Stop <span class="opt">-</span> Hit<span class="opt">;</span>
      <span class="kwa">begin</span>
         Sub <span class="opt">(</span><span class="kwa">not</span> Source<span class="opt">)(</span>Tail <span class="opt">..</span> Tail<span class="opt">+</span>L<span class="opt">-</span><span class="num">1</span><span class="opt">) :=</span> Sub <span class="opt">(</span>Source<span class="opt">) (</span>Hit<span class="opt">+</span><span class="num">1</span> <span class="opt">..</span> Hit<span class="opt">+</span>L<span class="opt">);</span>
         Tail <span class="opt">:=</span> Tail<span class="opt">+</span>L<span class="opt">;</span>
         <span class="kwa">return</span> <span class="kwd">True</span><span class="opt">;</span>
      <span class="kwa">end</span> Last_Repl<span class="opt">;</span>

      <span class="kwa">function</span> Next_Repl <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span>
         Dest <span class="opt">:</span> U<span class="opt">.</span>String_Access <span class="kwa">renames</span> Sub <span class="opt">(</span><span class="kwa">not</span> Source<span class="opt">);</span>
         L1   <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Natural</span> <span class="opt">:=</span> Hit <span class="opt">-</span> Start <span class="opt">+</span> <span class="num">1</span><span class="opt">;</span>
      <span class="kwa">begin</span>
         <span class="kwa">pragma</span> Assert <span class="opt">(</span>Tail<span class="kwd">&apos;Valid</span><span class="opt">);</span>

         Dest <span class="opt">(</span>Tail <span class="opt">..</span> Tail<span class="opt">+</span>L1<span class="opt">-</span><span class="num">1</span><span class="opt">)           :=</span> Sub <span class="opt">(</span>Source<span class="opt">) (</span>Start <span class="opt">..</span> Hit<span class="opt">);</span>
         Dest <span class="opt">(</span>Tail<span class="opt">+</span>L1
                 <span class="opt">..</span> Tail<span class="opt">+</span>L1<span class="opt">+</span>Rpl<span class="kwd">&apos;Length</span> <span class="opt">-</span> <span class="num">1</span><span class="opt">) :=</span> Rpl<span class="opt">.</span><span class="kwa">all</span><span class="opt">;</span>
         Tail                               <span class="opt">:=</span> Tail <span class="opt">+</span> L1 <span class="opt">+</span> Rpl<span class="kwd">&apos;Length</span><span class="opt">;</span>
         Start                              <span class="opt">:=</span> Stop <span class="opt">+</span> <span class="num">1</span><span class="opt">;</span>
         <span class="kwa">return</span> <span class="kwd">False</span><span class="opt">;</span>
      <span class="kwa">end</span> Next_Repl<span class="opt">;</span>

      <span class="kwa">procedure</span> Run_Matcher <span class="opt">(</span>Iub_Pattern <span class="opt">:</span> Pattern<span class="opt">;</span> Ub <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">)</span> <span class="kwa">is</span>

         <span class="kwa">function</span> Ge <span class="kwa">return</span> <span class="kwb">Boolean</span> <span class="kwa">is</span> <span class="opt">(</span>Hit <span class="opt">&gt;=</span> Stop<span class="opt">);</span>

         Suffix <span class="opt">:</span> <span class="kwa">constant</span> Pattern <span class="opt">:=</span>
           <span class="opt">(</span>Tab <span class="opt">(</span>Stop<span class="kwd">&apos;Access</span><span class="opt">)</span>
              <span class="opt">&amp;</span> Setcur <span class="opt">(</span>Hit<span class="kwd">&apos;Access</span><span class="opt">)</span>
              <span class="opt">&amp;</span> Rest
              <span class="opt">&amp;</span> Setcur <span class="opt">(</span>Stop<span class="kwd">&apos;Access</span><span class="opt">)</span>
              <span class="opt">&amp; (+</span>Last_Repl<span class="kwd">&apos;Unrestricted_Access</span><span class="opt">));</span>

         Code <span class="opt">:</span> <span class="kwa">constant</span> Pattern <span class="opt">:=</span>
           <span class="opt">(</span>Setcur <span class="opt">(</span>Hit<span class="kwd">&apos;Access</span><span class="opt">)</span>
              <span class="opt">&amp; (+</span>Ge<span class="kwd">&apos;Unrestricted_Access</span><span class="opt">)</span>
              <span class="opt">&amp;</span> Iub_Pattern
              <span class="opt">&amp;</span> Setcur <span class="opt">(</span>Stop<span class="kwd">&apos;Access</span><span class="opt">)</span>
              <span class="opt">&amp; (+</span>Next_Repl<span class="kwd">&apos;Unrestricted_Access</span><span class="opt">));</span>
      <span class="kwa">begin</span>
         Stop  <span class="opt">:=</span> <span class="num">0</span><span class="opt">;</span>
         Tail  <span class="opt">:=</span> <span class="num">1</span><span class="opt">;</span>
         Start <span class="opt">:=</span> Sub <span class="opt">(</span>Source<span class="opt">)</span><span class="kwd">&apos;First</span><span class="opt">;</span>
         Match <span class="opt">(</span>Sub <span class="opt">(</span>Source<span class="opt">) (</span><span class="num">1</span> <span class="opt">..</span> Ub<span class="opt">),</span> Pat <span class="opt">=&gt;</span> Code<span class="opt">);</span>
         Match <span class="opt">(</span>Sub <span class="opt">(</span>Source<span class="opt">) (</span><span class="num">1</span> <span class="opt">..</span> Ub<span class="opt">),</span> Pat <span class="opt">=&gt;</span> Suffix<span class="opt">);</span>
      <span class="kwa">end</span> Run_Matcher<span class="opt">;</span>

      Ub <span class="opt">:</span> <span class="kwb">Positive</span><span class="opt">;</span>
      Need <span class="opt">:</span> <span class="kwa">constant</span> <span class="kwb">Positive</span> <span class="opt">:=</span> <span class="num">1</span> <span class="opt">+</span> <span class="kwb">Natural</span> <span class="opt">(</span><span class="num">1.3</span> <span class="opt">*</span> <span class="kwb">Float</span> <span class="opt">(</span>To<span class="opt">-</span>From<span class="opt">+</span><span class="num">1</span><span class="opt">));</span>
   <span class="kwa">begin</span>                              <span class="slc">--  Replacement</span>
      Source <span class="opt">:=</span> <span class="kwd">True</span><span class="opt">;</span>
      Ub     <span class="opt">:=</span> To<span class="opt">-</span>From<span class="opt">+</span><span class="num">1</span><span class="opt">;</span>
      <span class="kwa">if</span> Bordering <span class="kwa">then</span>         <span class="slc">-- Sequence is the concatenation</span>
         Sub <span class="opt">(</span>Source<span class="opt">)     :=</span> Sequence<span class="opt">;</span>
         Sub <span class="opt">(</span><span class="kwa">not</span> Source<span class="opt">) :=</span> <span class="kwa">new</span> <span class="kwb">String</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> To<span class="opt">-</span>From<span class="opt">+</span><span class="num">1</span><span class="opt">);</span>
         Rpl              <span class="opt">:=</span> <span class="kwa">new</span> <span class="kwb">String</span><span class="str">&apos;(S (Iub (Iub&apos;Last).Replacement));</span>
<span class="str">         Run_Matcher (Iub (Iub&apos;Last).Element, Ub);</span>
<span class="str">         Ub               := Tail - 1;</span>
<span class="str">         Source           := not Source;</span>
<span class="str">      else</span>
<span class="str">         Sub (True)  := new String (1 .. Need);</span>
<span class="str">         Sub (False) := new String (1 .. Need);</span>
<span class="str">         Sub (Source) (1 .. (To-From+1)) := Sequence (From .. To);</span>
<span class="str">         for Job in Iub&apos;First .. Iub&apos;Last-1 loop</span>
<span class="str">            Rpl    := new String&apos;</span><span class="opt">(</span>S <span class="opt">(</span>Iub <span class="opt">(</span>Job<span class="opt">).</span>Replacement<span class="opt">));</span>
            Run_Matcher <span class="opt">(</span>Iub <span class="opt">(</span>Job<span class="opt">).</span>Element<span class="opt">,</span> Ub<span class="opt">);</span>
            Ub     <span class="opt">:=</span> Tail <span class="opt">-</span> <span class="num">1</span><span class="opt">;</span>
            Source <span class="opt">:=</span> <span class="kwa">not</span> Source<span class="opt">;</span>
         <span class="kwa">end loop</span><span class="opt">;</span>
      <span class="kwa">end if</span><span class="opt">;</span>
      U<span class="opt">.</span>Free <span class="opt">(</span>Sub <span class="opt">(</span><span class="kwa">not</span> Source<span class="opt">));</span>
      <span class="kwa">accept</span> Save <span class="opt">(</span>Pointer <span class="opt">:</span> <span class="kwa">out</span> U<span class="opt">.</span>String_Access<span class="opt">;</span> Last <span class="opt">:</span> <span class="kwa">out</span> <span class="kwb">Natural</span><span class="opt">)</span> <span class="kwa">do</span>
         Pointer <span class="opt">:=</span> Sub <span class="opt">(</span>Source<span class="opt">);</span>
         Last    <span class="opt">:=</span> Ub<span class="opt">;</span>
      <span class="kwa">end</span> Save<span class="opt">;</span>
   <span class="kwa">end</span> Service<span class="opt">;</span>

<span class="kwa">end</span> DNA<span class="opt">.</span>Replacing<span class="opt">;</span>

<span class="kwa">with</span> U<span class="opt">;</span>
<span class="kwa">package</span> Block_Input <span class="kwa">is</span>

   <span class="kwa">function</span> Read <span class="kwa">return</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>
   <span class="kwa">procedure</span> Open_Stdin<span class="opt">;</span>
   <span class="kwa">procedure</span> Close_Stdin<span class="opt">;</span>

<span class="kwa">end</span> Block_Input<span class="opt">;</span>

<span class="kwa">with</span> Ada<span class="opt">.</span>Streams<span class="opt">.</span>Stream_IO<span class="opt">;</span>
<span class="kwa">with</span> Interfaces<span class="opt">.</span>C_Streams<span class="opt">;</span>

<span class="kwa">package body</span> Block_Input <span class="kwa">is</span>

   <span class="kwa">use</span> Ada<span class="opt">.</span>Streams<span class="opt">;</span>

   cin <span class="opt">:</span> Stream_IO<span class="opt">.</span>File_Type<span class="opt">;</span>

   <span class="kwa">function</span> Read <span class="kwa">return</span> U<span class="opt">.</span>String_Access <span class="kwa">is</span>
      <span class="kwa">use</span> Interfaces<span class="opt">.</span>C_Streams<span class="opt">;</span>
      Items_To_Read <span class="opt">:</span> Stream_Element_Offset<span class="opt">;</span>
      Items_Read    <span class="opt">:</span> Stream_Element_Offset<span class="opt">;</span>
      Buffer        <span class="opt">:</span> U<span class="opt">.</span>String_Access<span class="opt">;</span>
   <span class="kwa">begin</span>
      <span class="kwa">if</span> fseek <span class="opt">(</span>stdin<span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> SEEK_END<span class="opt">) /= -</span><span class="num">1</span> <span class="kwa">then</span>
         Items_To_Read <span class="opt">:=</span> Stream_Element_Offset <span class="opt">(</span>ftell <span class="opt">(</span>stdin<span class="opt">));</span>
         rewind <span class="opt">(</span>stdin<span class="opt">);</span>
         Buffer <span class="opt">:=</span> <span class="kwa">new</span> <span class="kwb">String</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> <span class="kwb">Positive</span> <span class="opt">(</span>Items_To_Read<span class="opt">));</span>
         <span class="kwa">declare</span>
            View <span class="opt">:</span> Stream_Element_Array <span class="opt">(</span><span class="num">1</span> <span class="opt">..</span> Items_To_Read<span class="opt">);</span>
            <span class="kwa">pragma</span> Import <span class="opt">(</span>Ada<span class="opt">,</span> View<span class="opt">);</span>
            <span class="kwa">for</span> View<span class="kwd">&apos;Address</span> <span class="kwa">use</span> Buffer<span class="opt">.</span><span class="kwa">all</span><span class="kwd">&apos;Address</span><span class="opt">;</span>
         <span class="kwa">begin</span>
            Stream_IO<span class="opt">.</span>Read <span class="opt">(</span>File <span class="opt">=&gt;</span> cin<span class="opt">,</span>
                            Item <span class="opt">=&gt;</span> View<span class="opt">,</span>
                            Last <span class="opt">=&gt;</span> Items_Read<span class="opt">);</span>
         <span class="kwa">end</span><span class="opt">;</span>
      <span class="kwa">end if</span><span class="opt">;</span>
      <span class="kwa">return</span> Buffer<span class="opt">;</span>
   <span class="kwa">end</span> Read<span class="opt">;</span>

   <span class="kwa">procedure</span> Open_Stdin <span class="kwa">is</span>
   <span class="kwa">begin</span>
      Stream_IO<span class="opt">.</span>Open
        <span class="opt">(</span>File <span class="opt">=&gt;</span> cin<span class="opt">,</span>
         Mode <span class="opt">=&gt;</span> Stream_IO<span class="opt">.</span>In_File<span class="opt">,</span>
         Name <span class="opt">=&gt;</span> <span class="str">&quot;/dev/stdin&quot;</span><span class="opt">);</span>
   <span class="kwa">end</span> Open_Stdin<span class="opt">;</span>

   <span class="kwa">procedure</span> Close_Stdin <span class="kwa">is</span>
   <span class="kwa">begin</span>
      Stream_IO<span class="opt">.</span>Close <span class="opt">(</span>cin<span class="opt">);</span>
   <span class="kwa">end</span> Close_Stdin<span class="opt">;</span>

<span class="kwa">end</span> Block_Input<span class="opt">;</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
GNATMAKE 7.2.0
gcc (Ubuntu 7.2.0-8ubuntu3) 7.2.0



Thu, 26 Oct 2017 15:06:05 GMT

MAKE:
gnatchop -r -w regexredux.gnat-5.gnat
splitting regexredux.gnat-5.gnat into:
   dna.ads
   u.ads
   regexredux.adb
   preprocessing.ads
   dna-matching.ads
   dna-replacing.ads
   preprocessing.adb
   dna-matching.adb
   dna-replacing.adb
   block_input.ads
   block_input.adb
gnatmake -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp -f regexredux.adb -o regexredux.gnat-5.gnat_run 
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp regexredux.adb
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp block_input.adb
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp dna.ads
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp dna-matching.adb
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp dna-replacing.adb
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp preprocessing.adb
gcc-7 -c -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -gnatNp u.ads
gnatbind-7 -x regexredux.ali
gnatlink-7 regexredux.ali -O3 -fomit-frame-pointer -march=native -msse3 -mfpmath=sse -o regexredux.gnat-5.gnat_run

5.03s to complete and log all make actions

COMMAND LINE:
./regexredux.gnat-5.gnat_run 0 &lt; regexredux-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
27388361
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

