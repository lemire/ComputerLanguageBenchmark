<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>meteor-contest Java&nbsp;#2 program | Computer Language Benchmarks Game </title>
<style><!--
a{color:black;text-decoration:none}article{padding: 0 0 2.9em}article,div,footer,header{margin:auto;width:92%}body{font:100% Droid Sans,Ubuntu,Verdana,sans-serif;margin:0;-webkit-text-size-adjust:100%}h1,h2,h3,li a{font-family:Ubuntu Mono,Consolas,Menlo,monospace}div,footer,header{max-width:31em}footer{padding:2.6em 0 0}h1{font-size:1.4em;font-weight:bold;margin:0;padding:.4em}h1,h1 a{color:white}h2,h3{margin:1.5em 0 0}h2{font-size:1.4em;font-weight:normal}h3{font-size:1.2em}li{list-style-type:none;vertical-align:top}li a{display:block;font-size:1.2em;margin:.5em .5em 0;padding:.5em .5em .3em}ul{clear:left;margin:-0.3em 0 1.5em;padding-left:0;text-align:center}p{color:#333;line-height:1.4;margin:.3em 0 0}p a,a span{border-bottom:.1em solid #333;padding-bottom:.1em}#u64,#u64q{background-color:#c90016}#u32{background-color:#ffb515}#u32q{background-color:#ff6309}.com,.slc{color:#888}.kwa{color:#066}.kwb{color:#900}.kwc{color:#050}.kwa,.kwb,.kwc{font-weight:bold}.dstr,.str,.sym,.num{color:#930}pre{color:#222;font-size:1em;overflow-wrap:break-word;white-space:pre-wrap;word-wrap:break-word}@media only screen and (min-width:60em){article,footer,header{font-size:1.25em}}
--></style>
<link rel="shortcut icon" href="./favicon.ico">
<header id="top">
  <h1 id="u64q"><a href="./index.html">The&nbsp;Computer&nbsp;Language<br>Benchmarks&nbsp;Game</a></h1>
</header>
<article>
  <div>
    <h2>meteor-contest Java&nbsp;#2 program</h2>
    <aside>
      <p><a href="./meteor-description.html#meteor">description</a>
    </aside>
  </div>
  <section>
    </div>
      <h3>source code</h3>
    </div>
    <pre>
<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com">   http://benchmarksgame.alioth.debian.org/</span>
<span class="com">   transliterated from C++ (Ben St. John) and D (Michael Deardeuff) by Amir K aka Razii</span>
<span class="com">*/</span>


<span class="kwa">import</span> java<span class="opt">.</span>util<span class="opt">.*;</span>

<span class="kwa">public final class</span> meteor
<span class="opt">{</span>
    <span class="kwa">static final int</span> X <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
    <span class="kwa">static final int</span> Y <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_DIM <span class="opt">=</span> <span class="num">2</span><span class="opt">;</span>

    <span class="kwa">static final int</span> EVEN <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
    <span class="kwa">static final int</span> ODD <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_PARITY <span class="opt">=</span> <span class="num">2</span><span class="opt">;</span>

    <span class="kwa">static final int</span> GOOD <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
    <span class="kwa">static final int</span> BAD <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="kwa">static final int</span> ALWAYS_BAD <span class="opt">=</span> <span class="num">2</span><span class="opt">;</span>

    <span class="kwa">static final int</span> OPEN    <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
    <span class="kwa">static final int</span> CLOSED  <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_FIXED <span class="opt">=</span> <span class="num">2</span><span class="opt">;</span>

    <span class="kwa">static final int</span> MAX_ISLAND_OFFSET <span class="opt">=</span> <span class="num">1024</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_COL <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_ROW <span class="opt">=</span> <span class="num">10</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_CELL <span class="opt">=</span> N_COL <span class="opt">*</span> N_ROW<span class="opt">;</span>
    <span class="kwa">static final int</span> N_PIECE_TYPE <span class="opt">=</span> <span class="num">10</span><span class="opt">;</span>
    <span class="kwa">static final int</span> N_ORIENT <span class="opt">=</span> <span class="num">12</span><span class="opt">;</span>


<span class="slc">//-- Globals -------------------------</span>
    <span class="kwa">static</span> IslandInfo<span class="opt">[]</span> g_islandInfo <span class="opt">=</span> <span class="kwa">new</span> IslandInfo <span class="opt">[</span>MAX_ISLAND_OFFSET<span class="opt">];</span>
    <span class="kwa">static int</span> g_nIslandInfo <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
    <span class="kwa">static</span> OkPieces<span class="opt">[][]</span> g_okPieces <span class="opt">=</span> <span class="kwa">new</span> OkPieces <span class="opt">[</span>N_ROW<span class="opt">][</span>N_COL<span class="opt">];</span>

    <span class="kwa">static final int</span> g_firstRegion<span class="opt">[] = {</span>
        <span class="num">0x00</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span>
        <span class="num">0x08</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x0c</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x0e</span><span class="opt">,</span> <span class="num">0x0f</span><span class="opt">,</span>

        <span class="num">0x10</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span>
        <span class="num">0x18</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x03</span><span class="opt">,</span>   <span class="num">0x1c</span><span class="opt">,</span> <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x1e</span><span class="opt">,</span> <span class="num">0x1f</span>
    <span class="opt">};</span>

    <span class="kwa">static final int</span> g_flip<span class="opt">[] = {</span>
        <span class="num">0x00</span><span class="opt">,</span> <span class="num">0x10</span><span class="opt">,</span> <span class="num">0x08</span><span class="opt">,</span> <span class="num">0x18</span><span class="opt">,</span> <span class="num">0x04</span><span class="opt">,</span> <span class="num">0x14</span><span class="opt">,</span> <span class="num">0x0c</span><span class="opt">,</span> <span class="num">0x1c</span><span class="opt">,</span>
        <span class="num">0x02</span><span class="opt">,</span> <span class="num">0x12</span><span class="opt">,</span> <span class="num">0x0a</span><span class="opt">,</span> <span class="num">0x1a</span><span class="opt">,</span> <span class="num">0x06</span><span class="opt">,</span> <span class="num">0x16</span><span class="opt">,</span> <span class="num">0x0e</span><span class="opt">,</span> <span class="num">0x1e</span><span class="opt">,</span>

        <span class="num">0x01</span><span class="opt">,</span> <span class="num">0x11</span><span class="opt">,</span> <span class="num">0x09</span><span class="opt">,</span> <span class="num">0x19</span><span class="opt">,</span> <span class="num">0x05</span><span class="opt">,</span> <span class="num">0x15</span><span class="opt">,</span> <span class="num">0x0d</span><span class="opt">,</span> <span class="num">0x1d</span><span class="opt">,</span>
        <span class="num">0x03</span><span class="opt">,</span> <span class="num">0x13</span><span class="opt">,</span> <span class="num">0x0b</span><span class="opt">,</span> <span class="num">0x1b</span><span class="opt">,</span> <span class="num">0x07</span><span class="opt">,</span> <span class="num">0x17</span><span class="opt">,</span> <span class="num">0x0f</span><span class="opt">,</span> <span class="num">0x1f</span><span class="opt">,</span>
    <span class="opt">};</span>

    <span class="kwa">static final int</span><span class="opt">[]</span> s_firstOne <span class="opt">= {</span>
        <span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
        <span class="num">3</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>

        <span class="num">4</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
        <span class="num">3</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>   <span class="num">2</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">1</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span>
    <span class="opt">};</span>

    <span class="kwa">static int</span> <span class="kwd">getMask</span><span class="opt">(</span><span class="kwa">int</span> iPos<span class="opt">) {</span>
        <span class="kwa">return</span> <span class="opt">(</span><span class="num">1</span> <span class="opt">&lt;&lt; (</span>iPos<span class="opt">));</span>
    <span class="opt">}</span>

    <span class="kwa">static int</span> <span class="kwd">floor</span><span class="opt">(</span><span class="kwa">int</span> top<span class="opt">,</span> <span class="kwa">int</span> bot<span class="opt">) {</span>
        <span class="kwa">int</span> toZero <span class="opt">=</span> top <span class="opt">/</span> bot<span class="opt">;</span>
        <span class="slc">// negative numbers should be rounded down, not towards zero;</span>
        <span class="kwa">if</span> <span class="opt">((</span>toZero <span class="opt">*</span> bot <span class="opt">!=</span> top<span class="opt">) &amp;&amp; ((</span>top <span class="opt">&lt;</span> <span class="num">0</span><span class="opt">) != (</span>bot <span class="opt">&lt;=</span> <span class="num">0</span><span class="opt">)))</span>
            toZero<span class="opt">--;</span>

        <span class="kwa">return</span> toZero<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="kwa">static int</span> <span class="kwd">getFirstOne</span><span class="opt">(</span><span class="kwa">int</span> v<span class="opt">) {</span>
        <span class="kwa">int</span> startPos <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>v <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
            <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>

        <span class="kwa">int</span> iPos <span class="opt">=</span> startPos<span class="opt">;</span>
        <span class="kwa">int</span> mask <span class="opt">=</span> <span class="num">0xff</span> <span class="opt">&lt;&lt;</span> startPos<span class="opt">;</span>
        <span class="kwa">while</span> <span class="opt">((</span>mask <span class="opt">&amp;</span> v<span class="opt">) ==</span> <span class="num">0</span><span class="opt">) {</span>
            mask <span class="opt">&lt;&lt;=</span> <span class="num">8</span><span class="opt">;</span>
            iPos <span class="opt">+=</span> <span class="num">8</span><span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwa">int</span> result <span class="opt">= (</span>mask <span class="opt">&amp;</span> v<span class="opt">) &gt;&gt;</span> iPos<span class="opt">;</span>
        <span class="kwa">int</span> resultLow <span class="opt">=</span> result <span class="opt">&amp;</span> <span class="num">0x0f</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>resultLow <span class="opt">!=</span> <span class="num">0</span><span class="opt">)</span>
            iPos <span class="opt">+=</span> s_firstOne<span class="opt">[</span>resultLow<span class="opt">];</span>
        <span class="kwa">else</span>
            iPos <span class="opt">+=</span> <span class="num">4</span> <span class="opt">+</span> s_firstOne<span class="opt">[</span>result <span class="opt">&gt;&gt;</span> <span class="num">4</span><span class="opt">];</span>

        <span class="kwa">return</span> iPos<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="kwa">static int</span> <span class="kwd">countOnes</span><span class="opt">(</span><span class="kwa">int</span> v<span class="opt">) {</span>
        <span class="kwa">int</span> n <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
        <span class="kwa">while</span> <span class="opt">(</span>v <span class="opt">!=</span> <span class="num">0</span><span class="opt">) {</span>
            n<span class="opt">++;</span>
            v <span class="opt">=</span> v <span class="opt">&amp; (</span>v <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
        <span class="opt">}</span>

        <span class="kwa">return</span> n<span class="opt">;</span>
    <span class="opt">}</span>


    <span class="kwa">static int</span> <span class="kwd">flipTwoRows</span><span class="opt">(</span><span class="kwa">int</span> bits<span class="opt">) {</span>
        <span class="kwa">int</span> flipped <span class="opt">=</span> g_flip<span class="opt">[</span>bits <span class="opt">&gt;&gt;</span> N_COL<span class="opt">] &lt;&lt;</span> N_COL<span class="opt">;</span>
        <span class="kwa">return</span> <span class="opt">(</span>flipped <span class="opt">|</span> g_flip<span class="opt">[</span>bits <span class="opt">&amp;</span> Board<span class="opt">.</span>TOP_ROW<span class="opt">]);</span>
    <span class="opt">}</span>

    <span class="kwa">static void</span> <span class="kwd">markBad</span><span class="opt">(</span>IslandInfo info<span class="opt">,</span> <span class="kwa">int</span> mask<span class="opt">,</span> <span class="kwa">int</span> eo<span class="opt">,</span> <span class="kwa">boolean</span> always<span class="opt">) {</span>
        info<span class="opt">.</span>hasBad<span class="opt">[</span>eo<span class="opt">][</span>OPEN<span class="opt">] |=</span> mask<span class="opt">;</span>
        info<span class="opt">.</span>hasBad<span class="opt">[</span>eo<span class="opt">][</span>CLOSED<span class="opt">] |=</span> mask<span class="opt">;</span>

        <span class="kwa">if</span> <span class="opt">(</span>always<span class="opt">)</span>
            info<span class="opt">.</span>alwaysBad<span class="opt">[</span>eo<span class="opt">] |=</span> mask<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="kwa">static void</span> <span class="kwd">initGlobals</span><span class="opt">() {</span>
        <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> MAX_ISLAND_OFFSET<span class="opt">;</span> i<span class="opt">++)</span>
        <span class="opt">{</span>
            g_islandInfo<span class="opt">[</span>i<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">IslandInfo</span><span class="opt">();</span>
        <span class="opt">}</span>

        <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> i<span class="opt">++)</span>
        <span class="opt">{</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> j <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> j <span class="opt">&lt;</span> N_COL<span class="opt">;</span> j<span class="opt">++)</span>
                g_okPieces<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">OkPieces</span><span class="opt">();</span>
        <span class="opt">}</span>
    <span class="opt">}</span>


<span class="slc">//-- Classes -------------------------;</span>

    <span class="kwa">static class</span> OkPieces <span class="opt">{</span>
        <span class="kwa">byte</span><span class="opt">[]</span> nPieces <span class="opt">=</span> <span class="kwa">new byte</span><span class="opt">[</span>N_PIECE_TYPE<span class="opt">];</span>
        <span class="kwa">int</span><span class="opt">[][]</span> pieceVec <span class="opt">=</span> <span class="kwa">new int</span><span class="opt">[</span>N_PIECE_TYPE<span class="opt">][</span>N_ORIENT<span class="opt">];</span>
    <span class="opt">}</span>


    <span class="kwa">static class</span> IslandInfo <span class="opt">{</span>
        <span class="kwa">int</span><span class="opt">[][]</span> hasBad  <span class="opt">=</span>  <span class="kwa">new int</span><span class="opt">[</span>N_FIXED<span class="opt">][</span>N_PARITY<span class="opt">];</span>
        <span class="kwa">int</span><span class="opt">[][]</span> isKnown <span class="opt">=</span>  <span class="kwa">new int</span><span class="opt">[</span>N_FIXED<span class="opt">][</span>N_PARITY<span class="opt">];</span>
        <span class="kwa">int</span><span class="opt">[]</span> alwaysBad <span class="opt">=</span>  <span class="kwa">new int</span><span class="opt">[</span>N_PARITY<span class="opt">];</span>
    <span class="opt">}</span>


    <span class="kwa">static class</span> Soln <span class="opt">{</span>
        <span class="kwa">static final int</span> NO_PIECE <span class="opt">= -</span><span class="num">1</span><span class="opt">;</span>

        <span class="kwa">boolean</span> <span class="kwd">isEmpty</span><span class="opt">() {</span>
            <span class="kwa">return</span> <span class="opt">(</span>m_nPiece <span class="opt">==</span> <span class="num">0</span><span class="opt">);</span>
        <span class="opt">}</span>
        <span class="kwa">void</span> <span class="kwd">popPiece</span><span class="opt">() {</span>
            m_nPiece<span class="opt">--;</span>
            m_synched <span class="opt">=</span> <span class="kwb">false</span><span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwa">void</span> <span class="kwd">pushPiece</span><span class="opt">(</span><span class="kwa">int</span> vec<span class="opt">,</span> <span class="kwa">int</span> iPiece<span class="opt">,</span> <span class="kwa">int</span> row<span class="opt">) {</span>
            SPiece p <span class="opt">=</span> m_pieces<span class="opt">[</span>m_nPiece<span class="opt">++];</span>
            p<span class="opt">.</span>vec <span class="opt">=</span> vec<span class="opt">;</span>
            p<span class="opt">.</span>iPiece <span class="opt">= (</span><span class="kwa">short</span><span class="opt">)</span> iPiece<span class="opt">;</span>
            p<span class="opt">.</span>row <span class="opt">= (</span><span class="kwa">short</span><span class="opt">)</span> row<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwd">Soln</span><span class="opt">() {</span>
            m_synched <span class="opt">=</span> <span class="kwb">false</span><span class="opt">;</span>
            m_nPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwd">init</span><span class="opt">();</span>
        <span class="opt">}</span>

        <span class="kwa">class</span> SPiece <span class="opt">{</span>
            <span class="kwa">int</span> vec<span class="opt">;</span>
            <span class="kwa">short</span> iPiece<span class="opt">;</span>
            <span class="kwa">short</span> row<span class="opt">;</span>
            <span class="kwd">SPiece</span><span class="opt">() {}</span>
            <span class="kwd">SPiece</span><span class="opt">(</span><span class="kwa">int</span> avec<span class="opt">,</span> <span class="kwa">int</span> apiece<span class="opt">,</span> <span class="kwa">int</span> arow<span class="opt">) {</span>
                vec <span class="opt">=</span> avec<span class="opt">;</span>
                iPiece <span class="opt">= (</span><span class="kwa">short</span><span class="opt">)</span>apiece<span class="opt">;</span>
                row <span class="opt">= (</span><span class="kwa">short</span><span class="opt">)</span>arow<span class="opt">;</span>
            <span class="opt">}</span>
            <span class="kwd">SPiece</span><span class="opt">(</span>SPiece other<span class="opt">) {</span>
                vec <span class="opt">=</span> other<span class="opt">.</span>vec<span class="opt">;</span>
                iPiece <span class="opt">=</span> other<span class="opt">.</span>iPiece<span class="opt">;</span>
                row <span class="opt">=</span> other<span class="opt">.</span>row<span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        SPiece<span class="opt">[]</span> m_pieces <span class="opt">=</span> <span class="kwa">new</span> SPiece <span class="opt">[</span>N_PIECE_TYPE<span class="opt">];</span>
        <span class="kwa">int</span> m_nPiece<span class="opt">;</span>
        <span class="kwa">byte</span><span class="opt">[][]</span> m_cells <span class="opt">=</span> <span class="kwa">new byte</span> <span class="opt">[</span>N_ROW<span class="opt">][</span>N_COL<span class="opt">];</span>
        <span class="kwa">boolean</span> m_synched<span class="opt">;</span>

        <span class="kwa">void</span> <span class="kwd">init</span><span class="opt">() {</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> i<span class="opt">++)</span>
                m_pieces<span class="opt">[</span>i<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">SPiece</span><span class="opt">();</span>
        <span class="opt">}</span>
        <span class="kwd">Soln</span> <span class="opt">(</span><span class="kwa">int</span> fillVal<span class="opt">) {</span>
            <span class="kwd">init</span><span class="opt">();</span>
            m_nPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwd">fill</span><span class="opt">(</span>fillVal<span class="opt">);</span>
        <span class="opt">}</span>
        <span class="kwa">public</span> Soln <span class="kwd">clone2</span><span class="opt">() {</span>
            Soln s <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Soln</span><span class="opt">();</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> m_pieces<span class="opt">.</span>length<span class="opt">;</span> i<span class="opt">++)</span>
                s<span class="opt">.</span>m_pieces<span class="opt">[</span>i<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">SPiece</span><span class="opt">(</span>m_pieces<span class="opt">[</span>i<span class="opt">]);</span>

            s<span class="opt">.</span>m_nPiece <span class="opt">=</span> m_nPiece<span class="opt">;</span>
            <span class="slc">//System.arraycopy(m_cells, 0, s.m_cells, 0, N_CELL);</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> i<span class="opt">++)</span>
            <span class="opt">{</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> j <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> j <span class="opt">&lt;</span> N_COL<span class="opt">;</span> j <span class="opt">++)</span>
                <span class="opt">{</span>
                    s<span class="opt">.</span>m_cells<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">] =</span> m_cells<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">];</span>
                <span class="opt">}</span>
            <span class="opt">}</span>

            s<span class="opt">.</span>m_synched <span class="opt">=</span> m_synched<span class="opt">;</span>
            <span class="kwa">return</span> s<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">fill</span><span class="opt">(</span><span class="kwa">int</span> val<span class="opt">) {</span>
            m_synched <span class="opt">=</span> <span class="kwb">false</span><span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> i<span class="opt">++)</span>
            <span class="opt">{</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> j <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> j <span class="opt">&lt;</span> N_COL<span class="opt">;</span> j<span class="opt">++)</span>
                    m_cells<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">] = (</span><span class="kwa">byte</span><span class="opt">)</span> val<span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">public</span> String <span class="kwd">toString</span><span class="opt">()  {</span>
            StringBuffer result <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">StringBuffer</span><span class="opt">(</span>N_CELL <span class="opt">*</span> <span class="num">2</span><span class="opt">);</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
                    <span class="kwa">int</span> val <span class="opt">=</span> m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>
                    <span class="slc">//if (val == NO_PIECE) result.append(&apos;.&apos;);</span>
                    <span class="opt">{</span>
                        result<span class="opt">.</span><span class="kwd">append</span><span class="opt">(</span>val<span class="opt">);</span>
                    <span class="opt">}</span>
                    result<span class="opt">.</span><span class="kwd">append</span><span class="opt">(</span><span class="str">&apos; &apos;</span><span class="opt">);</span>
                <span class="opt">}</span>
                result<span class="opt">.</span><span class="kwd">append</span><span class="opt">(</span><span class="str">&apos;</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">);</span>

                <span class="slc">// indent every second line</span>
                <span class="kwa">if</span> <span class="opt">(</span>y <span class="opt">%</span> <span class="num">2</span> <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
                    result<span class="opt">.</span><span class="kwd">append</span><span class="opt">(</span><span class="str">&quot; &quot;</span><span class="opt">);</span>
            <span class="opt">}</span>
            <span class="kwa">return</span> result<span class="opt">.</span><span class="kwd">toString</span><span class="opt">();</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">setCells</span><span class="opt">() {</span>
            <span class="kwa">if</span> <span class="opt">(</span>m_synched<span class="opt">)</span>
                <span class="kwa">return</span><span class="opt">;</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> m_nPiece<span class="opt">;</span> iPiece<span class="opt">++) {</span>
                SPiece p <span class="opt">=</span> m_pieces<span class="opt">[</span>iPiece<span class="opt">];</span>
                <span class="kwa">int</span> vec <span class="opt">=</span> p<span class="opt">.</span>vec<span class="opt">;</span>
                <span class="kwa">byte</span> pID <span class="opt">= (</span><span class="kwa">byte</span><span class="opt">)</span> p<span class="opt">.</span>iPiece<span class="opt">;</span>
                <span class="kwa">int</span> rowOffset <span class="opt">=</span> p<span class="opt">.</span>row<span class="opt">;</span>

                <span class="kwa">int</span> nNewCells <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> rowOffset<span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
                    <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
                        <span class="kwa">if</span> <span class="opt">((</span>vec <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) !=</span> <span class="num">0</span><span class="opt">) {</span>
                            m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">] =</span> pID<span class="opt">;</span>
                            nNewCells<span class="opt">++;</span>
                        <span class="opt">}</span>
                        vec <span class="opt">&gt;&gt;=</span> <span class="num">1</span><span class="opt">;</span>
                    <span class="opt">}</span>
                    <span class="kwa">if</span> <span class="opt">(</span>nNewCells <span class="opt">==</span> Piece<span class="opt">.</span>N_ELEM<span class="opt">)</span>
                        <span class="kwa">break</span><span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
            m_synched <span class="opt">=</span> <span class="kwb">true</span><span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">boolean</span> <span class="kwd">lessThan</span><span class="opt">(</span>Soln r<span class="opt">) {</span>
            <span class="kwa">if</span> <span class="opt">(</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">!=</span> r<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece<span class="opt">) {</span>
                <span class="kwa">return</span> m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">&lt;</span> r<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwd">setCells</span><span class="opt">();</span>
            r<span class="opt">.</span><span class="kwd">setCells</span><span class="opt">();</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
                    <span class="kwa">int</span> lval <span class="opt">=</span> m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>
                    <span class="kwa">int</span> rval <span class="opt">=</span> r<span class="opt">.</span>m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">];</span>

                    <span class="kwa">if</span> <span class="opt">(</span>lval <span class="opt">!=</span> rval<span class="opt">)</span>
                        <span class="kwa">return</span> <span class="opt">(</span>lval <span class="opt">&lt;</span> rval<span class="opt">);</span>
                <span class="opt">}</span>
            <span class="opt">}</span>

            <span class="kwa">return</span> <span class="kwb">false</span><span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">spin</span><span class="opt">(</span>Soln spun<span class="opt">) {</span>
            <span class="kwd">setCells</span><span class="opt">();</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
                    <span class="kwa">byte</span> flipped <span class="opt">=</span> m_cells<span class="opt">[</span>N_ROW <span class="opt">-</span> y <span class="opt">-</span> <span class="num">1</span><span class="opt">][</span>N_COL <span class="opt">-</span> x <span class="opt">-</span> <span class="num">1</span><span class="opt">];</span>
                    spun<span class="opt">.</span>m_cells<span class="opt">[</span>y<span class="opt">][</span>x<span class="opt">] =</span> flipped<span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>


            spun<span class="opt">.</span>m_pieces<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>iPiece <span class="opt">=</span> m_pieces<span class="opt">[</span>N_PIECE_TYPE <span class="opt">-</span> <span class="num">1</span><span class="opt">].</span>iPiece<span class="opt">;</span>
            spun<span class="opt">.</span>m_synched <span class="opt">=</span> <span class="kwb">true</span><span class="opt">;</span>
        <span class="opt">}</span>
    <span class="opt">}</span>


<span class="slc">//-----------------------</span>
    <span class="kwa">static class</span> Board <span class="opt">{</span>
        <span class="kwa">static final int</span> L_EDGE_MASK <span class="opt">=</span> 
                                       <span class="opt">((</span><span class="num">1</span> <span class="opt">&lt;&lt;</span>  <span class="num">0</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span>  <span class="num">5</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">10</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">15</span><span class="opt">) |</span>
                                        <span class="opt">(</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">20</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">25</span><span class="opt">) | (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">));</span>
        <span class="kwa">static final int</span> R_EDGE_MASK <span class="opt">=</span> L_EDGE_MASK <span class="opt">&lt;&lt;</span> <span class="num">4</span><span class="opt">;</span>
        <span class="kwa">static final int</span> TOP_ROW <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> N_COL<span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>
        <span class="kwa">static final int</span> ROW_0_MASK <span class="opt">=</span>
            TOP_ROW <span class="opt">| (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">10</span><span class="opt">) | (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">20</span><span class="opt">) | (</span>TOP_ROW <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">);</span>
        <span class="kwa">static final int</span> ROW_1_MASK <span class="opt">=</span> ROW_0_MASK <span class="opt">&lt;&lt;</span> <span class="num">5</span><span class="opt">;</span>
        <span class="kwa">static final int</span> BOARD_MASK <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">30</span><span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>

        <span class="kwa">static int</span> <span class="kwd">getIndex</span><span class="opt">(</span><span class="kwa">int</span> x<span class="opt">,</span> <span class="kwa">int</span> y<span class="opt">) {</span>
            <span class="kwa">return</span> y <span class="opt">*</span> N_COL <span class="opt">+</span> x<span class="opt">;</span>
        <span class="opt">}</span>

        Soln m_curSoln<span class="opt">;</span>
        Soln m_minSoln<span class="opt">;</span>
        Soln m_maxSoln<span class="opt">;</span>
        <span class="kwa">int</span> m_nSoln<span class="opt">;</span>

        <span class="kwd">Board</span> <span class="opt">() {</span>
            m_curSoln <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Soln</span><span class="opt">(</span>Soln<span class="opt">.</span>NO_PIECE<span class="opt">);</span>
            m_minSoln <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Soln</span><span class="opt">(</span>N_PIECE_TYPE<span class="opt">);</span>
            m_maxSoln <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Soln</span><span class="opt">(</span>Soln<span class="opt">.</span>NO_PIECE<span class="opt">);</span>
            m_nSoln <span class="opt">= (</span><span class="num">0</span><span class="opt">);</span>
        <span class="opt">}</span>

        <span class="kwa">static boolean</span> <span class="kwd">badRegion</span><span class="opt">(</span><span class="kwa">int</span><span class="opt">[]</span> toFill<span class="opt">,</span> <span class="kwa">int</span> rNew<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="slc">// grow empty region, until it doesn&apos;t change any more;</span>
            <span class="kwa">int</span> region<span class="opt">;</span>
            <span class="kwa">do</span> <span class="opt">{</span>
                region <span class="opt">=</span> rNew<span class="opt">;</span>

                <span class="slc">// simple grow up/down</span>
                rNew <span class="opt">|= (</span>region <span class="opt">&gt;&gt;</span> N_COL<span class="opt">);</span>
                rNew <span class="opt">|= (</span>region <span class="opt">&lt;&lt;</span> N_COL<span class="opt">);</span>

                <span class="slc">// grow right/left</span>
                rNew <span class="opt">|= (</span>region <span class="opt">&amp;</span> ~L_EDGE_MASK<span class="opt">) &gt;&gt;</span> <span class="num">1</span><span class="opt">;</span>
                rNew <span class="opt">|= (</span>region <span class="opt">&amp;</span> ~R_EDGE_MASK<span class="opt">) &lt;&lt;</span> <span class="num">1</span><span class="opt">;</span>

                <span class="slc">// tricky growth</span>
                <span class="kwa">int</span> evenRegion <span class="opt">=</span> region <span class="opt">&amp; (</span>ROW_0_MASK <span class="opt">&amp;</span> ~L_EDGE_MASK<span class="opt">);</span>
                rNew <span class="opt">|=</span> evenRegion <span class="opt">&gt;&gt; (</span>N_COL <span class="opt">+</span> <span class="num">1</span><span class="opt">);</span>
                rNew <span class="opt">|=</span> evenRegion <span class="opt">&lt;&lt; (</span>N_COL <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
                <span class="kwa">int</span> oddRegion <span class="opt">=</span> region <span class="opt">&amp; (</span>ROW_1_MASK <span class="opt">&amp;</span> ~R_EDGE_MASK<span class="opt">);</span>
                rNew <span class="opt">|=</span> oddRegion <span class="opt">&gt;&gt; (</span>N_COL <span class="opt">-</span> <span class="num">1</span><span class="opt">);</span>
                rNew <span class="opt">|=</span> oddRegion <span class="opt">&lt;&lt; (</span>N_COL <span class="opt">+</span> <span class="num">1</span><span class="opt">);</span>

                <span class="slc">// clamp against existing pieces</span>
                rNew <span class="opt">&amp;=</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>
            <span class="opt">}</span>
            <span class="kwa">while</span> <span class="opt">((</span>rNew <span class="opt">!=</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]) &amp;&amp; (</span>rNew <span class="opt">!=</span> region<span class="opt">));</span>

            <span class="slc">// subtract empty region from board</span>
            toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]</span> ^<span class="opt">=</span> rNew<span class="opt">;</span>

            <span class="kwa">int</span> nCells <span class="opt">=</span> <span class="kwd">countOnes</span><span class="opt">(</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]);</span>
            <span class="kwa">return</span> <span class="opt">(</span>nCells <span class="opt">%</span> Piece<span class="opt">.</span>N_ELEM <span class="opt">!=</span> <span class="num">0</span><span class="opt">);</span>
        <span class="opt">}</span>

        <span class="kwa">static int</span> <span class="kwd">hasBadIslands</span><span class="opt">(</span><span class="kwa">int</span> boardVec<span class="opt">,</span> <span class="kwa">int</span> row<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="slc">// skip over any filled rows</span>
            <span class="kwa">while</span> <span class="opt">((</span>boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">) ==</span> TOP_ROW<span class="opt">) {</span>
                boardVec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
                row<span class="opt">++;</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> iInfo <span class="opt">=</span> boardVec <span class="opt">&amp; ((</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> <span class="num">2</span> <span class="opt">*</span> N_COL<span class="opt">) -</span> <span class="num">1</span><span class="opt">);</span>
            IslandInfo info <span class="opt">=</span> g_islandInfo<span class="opt">[</span>iInfo<span class="opt">];</span>

            <span class="kwa">int</span> lastRow <span class="opt">= (</span>boardVec <span class="opt">&gt;&gt; (</span><span class="num">2</span> <span class="opt">*</span> N_COL<span class="opt">)) &amp;</span> TOP_ROW<span class="opt">;</span>
            <span class="kwa">int</span> mask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>lastRow<span class="opt">);</span>
            <span class="kwa">int</span> isOdd <span class="opt">=</span> row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">;</span>

            <span class="kwa">if</span> <span class="opt">((</span>info<span class="opt">.</span>alwaysBad<span class="opt">[</span>isOdd<span class="opt">] &amp;</span> mask<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                <span class="kwa">return</span> BAD<span class="opt">;</span>

            <span class="kwa">if</span> <span class="opt">((</span>boardVec <span class="opt">&amp; (</span>TOP_ROW <span class="opt">&lt;&lt;</span> N_COL <span class="opt">*</span> <span class="num">3</span><span class="opt">)) !=</span> <span class="num">0</span><span class="opt">)</span>
                <span class="kwa">return</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> row<span class="opt">);</span>

            <span class="kwa">int</span> isClosed <span class="opt">= (</span>row <span class="opt">&gt;</span> <span class="num">6</span><span class="opt">)</span> ? <span class="num">1</span> <span class="opt">:</span> <span class="num">0</span><span class="opt">;</span>

            <span class="kwa">if</span> <span class="opt">((</span>info<span class="opt">.</span>isKnown<span class="opt">[</span>isOdd<span class="opt">][</span>isClosed<span class="opt">] &amp;</span> mask<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                <span class="kwa">return</span> <span class="opt">(</span>info<span class="opt">.</span>hasBad<span class="opt">[</span>isOdd<span class="opt">][</span>isClosed<span class="opt">] &amp;</span> mask<span class="opt">);</span>

            <span class="kwa">if</span> <span class="opt">(</span>boardVec <span class="opt">==</span> <span class="num">0</span><span class="opt">)</span>
                <span class="kwa">return</span> GOOD<span class="opt">;</span>

            <span class="kwa">int</span> hasBad <span class="opt">=</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> row<span class="opt">);</span>

            info<span class="opt">.</span>isKnown<span class="opt">[</span>isOdd<span class="opt">][</span>isClosed<span class="opt">] |=</span> mask<span class="opt">;</span>
            <span class="kwa">if</span> <span class="opt">(</span>hasBad <span class="opt">!=</span> <span class="num">0</span><span class="opt">)</span>
                info<span class="opt">.</span>hasBad<span class="opt">[</span>isOdd<span class="opt">][</span>isClosed<span class="opt">] |=</span> mask<span class="opt">;</span>

            <span class="kwa">return</span> hasBad<span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwa">static int</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span><span class="kwa">int</span> boardVec<span class="opt">,</span> <span class="kwa">int</span> row<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">int</span><span class="opt">[]</span> toFill <span class="opt">= {</span>~boardVec<span class="opt">};</span>
            <span class="kwa">if</span> <span class="opt">((</span>row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) !=</span> <span class="num">0</span><span class="opt">) {</span>
                row<span class="opt">--;</span>
                toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &lt;&lt;=</span> N_COL<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> boardMask <span class="opt">=</span> BOARD_MASK<span class="opt">;</span>
            <span class="kwa">if</span> <span class="opt">(</span>row <span class="opt">&gt;</span> <span class="num">4</span><span class="opt">) {</span>
                <span class="kwa">int</span> boardMaskShift <span class="opt">= (</span>row <span class="opt">-</span> <span class="num">4</span><span class="opt">) *</span> N_COL<span class="opt">;</span>
                boardMask <span class="opt">&gt;&gt;=</span> boardMaskShift<span class="opt">;</span>
            <span class="opt">}</span>
            toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &amp;=</span> boardMask<span class="opt">;</span>

            <span class="slc">// a little pre-work to speed things up</span>
            <span class="kwa">int</span> bottom <span class="opt">= (</span>TOP_ROW <span class="opt">&lt;&lt; (</span><span class="num">5</span> <span class="opt">*</span> N_COL<span class="opt">));</span>
            <span class="kwa">boolean</span> filled <span class="opt">= ((</span>bottom <span class="opt">&amp;</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]) ==</span> bottom<span class="opt">);</span>
            <span class="kwa">while</span> <span class="opt">((</span>bottom <span class="opt">&amp;</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]) ==</span> bottom<span class="opt">) {</span>
                toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]</span> ^<span class="opt">=</span> bottom<span class="opt">;</span>
                bottom <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> startRegion<span class="opt">;</span>
            <span class="kwa">if</span> <span class="opt">(</span>filled <span class="opt">|| (</span>row <span class="opt">&lt;</span> <span class="num">4</span><span class="opt">))</span>
                startRegion <span class="opt">=</span> bottom <span class="opt">&amp;</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>
            <span class="kwa">else</span> <span class="opt">{</span>
                startRegion <span class="opt">=</span> g_firstRegion<span class="opt">[</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &amp;</span> TOP_ROW<span class="opt">];</span>
                <span class="kwa">if</span> <span class="opt">(</span>startRegion <span class="opt">==</span> <span class="num">0</span><span class="opt">)  {</span>
                    startRegion <span class="opt">= (</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &gt;&gt;</span> N_COL<span class="opt">) &amp;</span> TOP_ROW<span class="opt">;</span>
                    startRegion <span class="opt">=</span> g_firstRegion<span class="opt">[</span>startRegion<span class="opt">];</span>
                    startRegion <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">;</span>
                <span class="opt">}</span>
                startRegion <span class="opt">|= (</span>startRegion <span class="opt">&lt;&lt;</span> N_COL<span class="opt">) &amp;</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>
            <span class="opt">}</span>

            <span class="kwa">while</span> <span class="opt">(</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] !=</span> <span class="num">0</span><span class="opt">)    {</span>
                <span class="kwa">if</span> <span class="opt">(</span><span class="kwd">badRegion</span><span class="opt">(</span>toFill<span class="opt">,</span> startRegion<span class="opt">))</span>
                    <span class="kwa">return</span> <span class="opt">((</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]!=</span><span class="num">0</span><span class="opt">)</span> ? ALWAYS_BAD <span class="opt">:</span> BAD<span class="opt">);</span>
                <span class="kwa">int</span> iPos <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]);</span>
                startRegion <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPos<span class="opt">);</span>
            <span class="opt">}</span>

            <span class="kwa">return</span> GOOD<span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwa">static void</span> <span class="kwd">calcAlwaysBad</span><span class="opt">() {</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iWord <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iWord <span class="opt">&lt;</span> MAX_ISLAND_OFFSET<span class="opt">;</span> iWord<span class="opt">++) {</span>
                IslandInfo isleInfo <span class="opt">=</span> g_islandInfo<span class="opt">[</span>iWord<span class="opt">];</span>
                IslandInfo flipped <span class="opt">=</span> g_islandInfo<span class="opt">[</span><span class="kwd">flipTwoRows</span><span class="opt">(</span>iWord<span class="opt">)];</span>

                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">,</span> mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> i <span class="opt">&lt;</span> <span class="num">32</span><span class="opt">;</span> i<span class="opt">++,</span> mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">) {</span>
                    <span class="kwa">int</span> boardVec <span class="opt">= (</span>i <span class="opt">&lt;&lt; (</span><span class="num">2</span> <span class="opt">*</span> N_COL<span class="opt">)) |</span> iWord<span class="opt">;</span>
                    <span class="kwa">if</span> <span class="opt">((</span>isleInfo<span class="opt">.</span>isKnown<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>OPEN<span class="opt">] &amp;</span> mask<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                        <span class="kwa">continue</span><span class="opt">;</span>

                    <span class="kwa">int</span> hasBad <span class="opt">=</span> <span class="kwd">calcBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
                    <span class="kwa">if</span> <span class="opt">(</span>hasBad <span class="opt">!=</span> GOOD<span class="opt">) {</span>
                        <span class="kwa">boolean</span> always <span class="opt">= (</span>hasBad<span class="opt">==</span>ALWAYS_BAD<span class="opt">);</span>
                        <span class="kwd">markBad</span><span class="opt">(</span>isleInfo<span class="opt">,</span> mask<span class="opt">,</span> EVEN<span class="opt">,</span> always<span class="opt">);</span>

                        <span class="kwa">int</span> flipMask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>g_flip<span class="opt">[</span>i<span class="opt">]);</span>
                        <span class="kwd">markBad</span><span class="opt">(</span>flipped<span class="opt">,</span> flipMask<span class="opt">,</span> ODD<span class="opt">,</span> always<span class="opt">);</span>
                    <span class="opt">}</span>
                <span class="opt">}</span>
                flipped<span class="opt">.</span>isKnown<span class="opt">[</span><span class="num">1</span><span class="opt">][</span>OPEN<span class="opt">] =  -</span><span class="num">1</span><span class="opt">;</span>
                isleInfo<span class="opt">.</span>isKnown<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>OPEN<span class="opt">] = -</span><span class="num">1</span><span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">static boolean</span> <span class="kwd">hasBadIslandsSingle</span><span class="opt">(</span><span class="kwa">int</span> boardVec<span class="opt">,</span> <span class="kwa">int</span> row<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">int</span><span class="opt">[]</span> toFill <span class="opt">= {</span>~boardVec<span class="opt">};</span>
            <span class="kwa">boolean</span> isOdd <span class="opt">= ((</span>row <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">) !=</span> <span class="num">0</span><span class="opt">);</span>
            <span class="kwa">if</span> <span class="opt">(</span>isOdd<span class="opt">) {</span>
                row<span class="opt">--;</span>
                toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &lt;&lt;=</span> N_COL<span class="opt">;</span> <span class="slc">// shift to even aligned</span>
                toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] |=</span> TOP_ROW<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> startRegion <span class="opt">=</span> TOP_ROW<span class="opt">;</span>
            <span class="kwa">int</span> lastRow <span class="opt">=</span> TOP_ROW <span class="opt">&lt;&lt; (</span><span class="num">5</span> <span class="opt">*</span> N_COL<span class="opt">);</span>
            <span class="kwa">int</span> boardMask <span class="opt">=</span> BOARD_MASK<span class="opt">;</span> <span class="slc">// all but the first two bits</span>
            <span class="kwa">if</span> <span class="opt">(</span>row <span class="opt">&gt;=</span> <span class="num">4</span><span class="opt">)</span>
                boardMask <span class="opt">&gt;&gt;= ((</span>row <span class="opt">-</span> <span class="num">4</span><span class="opt">) *</span> N_COL<span class="opt">);</span>
            <span class="kwa">else if</span> <span class="opt">(</span>isOdd <span class="opt">|| (</span>row <span class="opt">==</span> <span class="num">0</span><span class="opt">))</span>
                startRegion <span class="opt">=</span> lastRow<span class="opt">;</span>

            toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] &amp;=</span> boardMask<span class="opt">;</span>
            startRegion <span class="opt">&amp;=</span> toFill<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>

            <span class="kwa">while</span> <span class="opt">(</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">] !=</span> <span class="num">0</span><span class="opt">)    {</span>
                <span class="kwa">if</span> <span class="opt">(</span><span class="kwd">badRegion</span><span class="opt">(</span>toFill<span class="opt">,</span> startRegion<span class="opt">))</span>
                    <span class="kwa">return</span> <span class="kwb">true</span><span class="opt">;</span>
                <span class="kwa">int</span> iPos <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(</span>toFill<span class="opt">[</span><span class="num">0</span><span class="opt">]);</span>
                startRegion <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPos<span class="opt">);</span>
            <span class="opt">}</span>

            <span class="kwa">return</span> <span class="kwb">false</span><span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">genAllSolutions</span><span class="opt">(</span><span class="kwa">int</span> boardVec<span class="opt">,</span> <span class="kwa">int</span> placedPieces<span class="opt">,</span> <span class="kwa">int</span> row<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">while</span> <span class="opt">((</span>boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">) ==</span> TOP_ROW<span class="opt">) {</span>
                boardVec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
                row<span class="opt">++;</span>
            <span class="opt">}</span>
            <span class="kwa">int</span> iNextFill <span class="opt">=</span> s_firstOne<span class="opt">[</span>~boardVec <span class="opt">&amp;</span> TOP_ROW<span class="opt">];</span>
            OkPieces allowed <span class="opt">=</span> g_okPieces<span class="opt">[</span>row<span class="opt">][</span>iNextFill<span class="opt">];</span>

            <span class="kwa">int</span> iPiece <span class="opt">=</span> <span class="kwd">getFirstOne</span><span class="opt">(</span>~placedPieces<span class="opt">);</span>
            <span class="kwa">int</span> pieceMask <span class="opt">=</span> <span class="kwd">getMask</span><span class="opt">(</span>iPiece<span class="opt">);</span>
            <span class="kwa">for</span> <span class="opt">(;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++,</span> pieceMask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">)</span>
            <span class="opt">{</span>
                <span class="kwa">if</span> <span class="opt">((</span>pieceMask <span class="opt">&amp;</span> placedPieces<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                    <span class="kwa">continue</span><span class="opt">;</span>

                placedPieces <span class="opt">|=</span> pieceMask<span class="opt">;</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> allowed<span class="opt">.</span>nPieces<span class="opt">[</span>iPiece<span class="opt">];</span> iOrient<span class="opt">++) {</span>
                    <span class="kwa">int</span> pieceVec <span class="opt">=</span> allowed<span class="opt">.</span>pieceVec<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">];</span>

                    <span class="kwa">if</span> <span class="opt">((</span>pieceVec <span class="opt">&amp;</span> boardVec<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                        <span class="kwa">continue</span><span class="opt">;</span>

                    boardVec <span class="opt">|=</span> pieceVec<span class="opt">;</span>

                    <span class="kwa">if</span> <span class="opt">((</span><span class="kwd">hasBadIslands</span><span class="opt">(</span>boardVec<span class="opt">,</span> row<span class="opt">)) !=</span> <span class="num">0</span><span class="opt">) {</span>
                        boardVec ^<span class="opt">=</span> pieceVec<span class="opt">;</span>
                        <span class="kwa">continue</span><span class="opt">;</span>
                    <span class="opt">}</span>

                    m_curSoln<span class="opt">.</span><span class="kwd">pushPiece</span><span class="opt">(</span>pieceVec<span class="opt">,</span> iPiece<span class="opt">,</span> row<span class="opt">);</span>

                    <span class="slc">// recur or record solution</span>
                    <span class="kwa">if</span> <span class="opt">(</span>placedPieces <span class="opt">!=</span> Piece<span class="opt">.</span>ALL_PIECE_MASK<span class="opt">)</span>
                        <span class="kwd">genAllSolutions</span><span class="opt">(</span>boardVec<span class="opt">,</span> placedPieces<span class="opt">,</span> row<span class="opt">);</span>
                    <span class="kwa">else</span>
                        <span class="kwd">recordSolution</span><span class="opt">(</span>m_curSoln<span class="opt">);</span>

                    boardVec ^<span class="opt">=</span> pieceVec<span class="opt">;</span>
                    m_curSoln<span class="opt">.</span><span class="kwd">popPiece</span><span class="opt">();</span>
                <span class="opt">}</span>

                placedPieces ^<span class="opt">=</span> pieceMask<span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">recordSolution</span><span class="opt">(</span>Soln s<span class="opt">) {</span>
            m_nSoln <span class="opt">+=</span> <span class="num">2</span><span class="opt">;</span>

            <span class="kwa">if</span> <span class="opt">(</span>m_minSoln<span class="opt">.</span><span class="kwd">isEmpty</span><span class="opt">()) {</span>
                m_minSoln <span class="opt">=</span> m_maxSoln <span class="opt">=</span> s<span class="opt">.</span><span class="kwd">clone2</span><span class="opt">();</span>
                <span class="kwa">return</span><span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwa">if</span> <span class="opt">(</span>s<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>m_minSoln<span class="opt">))</span>
                m_minSoln <span class="opt">=</span> s<span class="opt">.</span><span class="kwd">clone2</span><span class="opt">();</span>
            <span class="kwa">else if</span> <span class="opt">(</span>m_maxSoln<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>s<span class="opt">))</span>
                m_maxSoln <span class="opt">=</span> s<span class="opt">.</span><span class="kwd">clone2</span><span class="opt">();</span>

            Soln spun <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Soln</span><span class="opt">();</span>
            s<span class="opt">.</span><span class="kwd">spin</span><span class="opt">(</span>spun<span class="opt">);</span>
            <span class="kwa">if</span> <span class="opt">(</span>spun<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>m_minSoln<span class="opt">))</span>
                m_minSoln <span class="opt">=</span> spun<span class="opt">;</span>
            <span class="kwa">else if</span> <span class="opt">(</span>m_maxSoln<span class="opt">.</span><span class="kwd">lessThan</span><span class="opt">(</span>spun<span class="opt">))</span>
                m_maxSoln <span class="opt">=</span> spun<span class="opt">;</span>
        <span class="opt">}</span>
    <span class="opt">}</span>

<span class="slc">//----------------------</span>
    <span class="kwa">static class</span> Piece <span class="opt">{</span>
        <span class="kwa">class</span> Instance <span class="opt">{</span>
            <span class="kwa">long</span> m_allowed<span class="opt">;</span>
            <span class="kwa">int</span> m_vec<span class="opt">;</span>
            <span class="kwa">int</span> m_offset<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">static final int</span> N_ELEM <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>
        <span class="kwa">static final int</span> ALL_PIECE_MASK <span class="opt">= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> N_PIECE_TYPE<span class="opt">) -</span> <span class="num">1</span><span class="opt">;</span>
        <span class="kwa">static final int</span> SKIP_PIECE <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>

        <span class="kwa">static final int</span> BaseVecs<span class="opt">[] = {</span>
            <span class="num">0x10f</span><span class="opt">,</span> <span class="num">0x0cb</span><span class="opt">,</span> <span class="num">0x1087</span><span class="opt">,</span> <span class="num">0x427</span><span class="opt">,</span> <span class="num">0x465</span><span class="opt">,</span>
            <span class="num">0x0c7</span><span class="opt">,</span> <span class="num">0x8423</span><span class="opt">,</span> <span class="num">0x0a7</span><span class="opt">,</span> <span class="num">0x187</span><span class="opt">,</span> <span class="num">0x08f</span>
        <span class="opt">};</span>

        <span class="kwa">static</span> Piece<span class="opt">[][]</span> s_basePiece <span class="opt">=</span> <span class="kwa">new</span> Piece <span class="opt">[</span>N_PIECE_TYPE<span class="opt">][</span>N_ORIENT<span class="opt">];</span>

        Instance<span class="opt">[]</span> m_instance <span class="opt">=</span> <span class="kwa">new</span> Instance <span class="opt">[</span>N_PARITY<span class="opt">];</span>

        <span class="kwa">void</span> <span class="kwd">init</span><span class="opt">() {</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_PARITY<span class="opt">;</span> i<span class="opt">++)</span>
                m_instance<span class="opt">[</span>i<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">Instance</span><span class="opt">();</span>
        <span class="opt">}</span>
        <span class="kwd">Piece</span><span class="opt">() {</span>
            <span class="kwd">init</span><span class="opt">();</span>
        <span class="opt">}</span>

        <span class="kwa">static</span> <span class="opt">{</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> i <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> i<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> j <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> j <span class="opt">&lt;</span> N_ORIENT<span class="opt">;</span> j<span class="opt">++)</span>
                    s_basePiece<span class="opt">[</span>i<span class="opt">][</span>j<span class="opt">] =</span> <span class="kwa">new</span> <span class="kwd">Piece</span><span class="opt">();</span>
            <span class="opt">}</span>
        <span class="opt">}</span>
        <span class="kwa">static void</span> <span class="kwd">setCoordList</span><span class="opt">(</span><span class="kwa">int</span> vec<span class="opt">,</span> <span class="kwa">int</span><span class="opt">[][]</span> pts<span class="opt">) {</span>
            <span class="kwa">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwa">int</span> mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> y<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> x <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> x <span class="opt">&lt;</span> N_COL<span class="opt">;</span> x<span class="opt">++) {</span>
                    <span class="kwa">if</span> <span class="opt">((</span>mask <span class="opt">&amp;</span> vec<span class="opt">) !=</span> <span class="num">0</span><span class="opt">) {</span>
                        pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] =</span> x<span class="opt">;</span>
                        pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] =</span> y<span class="opt">;</span>

                        iPt<span class="opt">++;</span>
                    <span class="opt">}</span>
                    mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">static int</span> <span class="kwd">toBitVector</span><span class="opt">(</span><span class="kwa">int</span><span class="opt">[][]</span> pts<span class="opt">) {</span>
            <span class="kwa">int</span> y<span class="opt">,</span> x<span class="opt">;</span>
            <span class="kwa">int</span> result <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
                x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
                y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

                <span class="kwa">int</span> pos <span class="opt">=</span> Board<span class="opt">.</span><span class="kwd">getIndex</span><span class="opt">(</span>x<span class="opt">,</span> y<span class="opt">);</span>
                result <span class="opt">|= (</span><span class="num">1</span> <span class="opt">&lt;&lt;</span> pos<span class="opt">);</span>
            <span class="opt">}</span>

            <span class="kwa">return</span> result<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">static void</span> <span class="kwd">shiftUpLines</span><span class="opt">(</span><span class="kwa">int</span><span class="opt">[][]</span> pts<span class="opt">,</span> <span class="kwa">int</span> shift<span class="opt">) {</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
                <span class="kwa">if</span> <span class="opt">((</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] &amp;</span> shift <span class="opt">&amp;</span> <span class="num">0x1</span><span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                    <span class="opt">(</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">])++;</span>
                pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] -=</span> shift<span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">static int</span> <span class="kwd">shiftToX0</span><span class="opt">(</span><span class="kwa">int</span><span class="opt">[][]</span> pts<span class="opt">,</span> Instance instance<span class="opt">,</span> <span class="kwa">int</span> offsetRow<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">int</span> x<span class="opt">,</span> y<span class="opt">,</span> iPt<span class="opt">;</span>
            <span class="kwa">int</span> xMin <span class="opt">=</span> pts<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>X<span class="opt">];</span>
            <span class="kwa">int</span> xMax <span class="opt">=</span> xMin<span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
                x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
                y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

                <span class="kwa">if</span> <span class="opt">(</span>x <span class="opt">&lt;</span> xMin<span class="opt">)</span>
                    xMin <span class="opt">=</span> x<span class="opt">;</span>
                <span class="kwa">else if</span> <span class="opt">(</span>x <span class="opt">&gt;</span> xMax<span class="opt">)</span>
                    xMax <span class="opt">=</span> x<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> offset <span class="opt">=</span> N_ELEM<span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>

                pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] -=</span> xMin<span class="opt">;</span>

                <span class="kwa">if</span> <span class="opt">((</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] ==</span> offsetRow<span class="opt">) &amp;&amp; (</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] &lt;</span> offset<span class="opt">))</span>
                    offset <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
            <span class="opt">}</span>

            instance<span class="opt">.</span>m_offset <span class="opt">=</span> offset<span class="opt">;</span>
            instance<span class="opt">.</span>m_vec <span class="opt">=</span> <span class="kwd">toBitVector</span><span class="opt">(</span>pts<span class="opt">);</span>
            <span class="kwa">return</span> xMax <span class="opt">-</span> xMin<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">void</span> <span class="kwd">setOkPos</span><span class="opt">(</span><span class="kwa">int</span> isOdd<span class="opt">,</span> <span class="kwa">int</span> w<span class="opt">,</span> <span class="kwa">int</span> h<span class="opt">) {</span>
            Instance p <span class="opt">=</span> m_instance<span class="opt">[</span>isOdd<span class="opt">];</span>
            p<span class="opt">.</span>m_allowed <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwa">long</span> posMask <span class="opt">=</span> <span class="num">1L</span> <span class="opt">&lt;&lt; (</span>isOdd <span class="opt">*</span> N_COL<span class="opt">);</span>

            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> y <span class="opt">=</span> isOdd<span class="opt">;</span> y <span class="opt">&lt;</span> N_ROW <span class="opt">-</span> h<span class="opt">;</span> y<span class="opt">+=</span><span class="num">2</span><span class="opt">,</span> posMask <span class="opt">&lt;&lt;=</span> N_COL<span class="opt">) {</span>
                <span class="kwa">if</span> <span class="opt">((</span>p<span class="opt">.</span>m_offset<span class="opt">) !=</span> <span class="num">0</span><span class="opt">)</span>
                    posMask <span class="opt">&lt;&lt;=</span> p<span class="opt">.</span>m_offset<span class="opt">;</span>

                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> xPos <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> xPos <span class="opt">&lt;</span> N_COL <span class="opt">-</span> p<span class="opt">.</span>m_offset<span class="opt">;</span> xPos<span class="opt">++,</span> posMask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">) {</span>

                    <span class="kwa">if</span> <span class="opt">(</span>xPos <span class="opt">&gt;=</span> N_COL <span class="opt">-</span> w<span class="opt">)</span>
                        <span class="kwa">continue</span><span class="opt">;</span>

                    <span class="kwa">int</span> pieceVec <span class="opt">=</span> p<span class="opt">.</span>m_vec <span class="opt">&lt;&lt;</span> xPos<span class="opt">;</span>

                    <span class="kwa">if</span> <span class="opt">(</span>Board<span class="opt">.</span><span class="kwd">hasBadIslandsSingle</span><span class="opt">(</span>pieceVec<span class="opt">,</span> y<span class="opt">))</span>
                        <span class="kwa">continue</span><span class="opt">;</span>

                    p<span class="opt">.</span>m_allowed <span class="opt">|=</span> posMask<span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">static void</span> <span class="kwd">genOrientation</span><span class="opt">(</span><span class="kwa">int</span> vec<span class="opt">,</span> <span class="kwa">int</span> iOrient<span class="opt">,</span> Piece target<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">int</span><span class="opt">[][]</span> pts <span class="opt">=</span> <span class="kwa">new int</span><span class="opt">[</span>N_ELEM<span class="opt">][</span>N_DIM<span class="opt">];</span>
            <span class="kwd">setCoordList</span><span class="opt">(</span>vec<span class="opt">,</span> pts<span class="opt">);</span>

            <span class="kwa">int</span> y<span class="opt">,</span> x<span class="opt">,</span> iPt<span class="opt">;</span>
            <span class="kwa">int</span> rot <span class="opt">=</span> iOrient <span class="opt">%</span> <span class="num">6</span><span class="opt">;</span>
            <span class="kwa">int</span> flip <span class="opt">=</span> iOrient <span class="opt">&gt;=</span> <span class="num">6</span> ? <span class="num">1</span> <span class="opt">:</span> <span class="num">0</span><span class="opt">;</span>
            <span class="kwa">if</span> <span class="opt">(</span>flip <span class="opt">!=</span> <span class="num">0</span><span class="opt">) {</span>
                <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++)</span>
                    pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] = -</span>pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>
            <span class="opt">}</span>

            <span class="kwa">while</span> <span class="opt">((</span>rot<span class="opt">--) !=</span> <span class="num">0</span><span class="opt">) {</span>
                <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
                    x <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">];</span>
                    y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

                    <span class="kwa">int</span> xNew <span class="opt">=</span> <span class="kwd">floor</span><span class="opt">((</span><span class="num">2</span> <span class="opt">*</span> x <span class="opt">-</span> <span class="num">3</span> <span class="opt">*</span> y <span class="opt">+</span> <span class="num">1</span><span class="opt">),</span> <span class="num">4</span><span class="opt">);</span>
                    <span class="kwa">int</span> yNew <span class="opt">=</span> <span class="kwd">floor</span><span class="opt">((</span><span class="num">2</span> <span class="opt">*</span> x <span class="opt">+</span> y <span class="opt">+</span> <span class="num">1</span><span class="opt">),</span> <span class="num">2</span><span class="opt">);</span>
                    pts<span class="opt">[</span>iPt<span class="opt">][</span>X<span class="opt">] =</span> xNew<span class="opt">;</span>
                    pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">] =</span> yNew<span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>

            <span class="kwa">int</span> yMin <span class="opt">=</span> pts<span class="opt">[</span><span class="num">0</span><span class="opt">][</span>Y<span class="opt">];</span>
            <span class="kwa">int</span> yMax <span class="opt">=</span> yMin<span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span>iPt <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span> iPt <span class="opt">&lt;</span> N_ELEM<span class="opt">;</span> iPt<span class="opt">++) {</span>
                y <span class="opt">=</span> pts<span class="opt">[</span>iPt<span class="opt">][</span>Y<span class="opt">];</span>

                <span class="kwa">if</span> <span class="opt">(</span>y <span class="opt">&lt;</span> yMin<span class="opt">)</span>
                    yMin <span class="opt">=</span> y<span class="opt">;</span>
                <span class="kwa">else if</span> <span class="opt">(</span>y <span class="opt">&gt;</span> yMax<span class="opt">)</span>
                    yMax <span class="opt">=</span> y<span class="opt">;</span>
            <span class="opt">}</span>
            <span class="kwa">int</span> h <span class="opt">=</span> yMax <span class="opt">-</span> yMin<span class="opt">;</span>
            Instance even <span class="opt">=</span> target<span class="opt">.</span>m_instance<span class="opt">[</span>EVEN<span class="opt">];</span>
            Instance odd <span class="opt">=</span> target<span class="opt">.</span>m_instance<span class="opt">[</span>ODD<span class="opt">];</span>

            <span class="kwd">shiftUpLines</span><span class="opt">(</span>pts<span class="opt">,</span> yMin<span class="opt">);</span>
            <span class="kwa">int</span> w <span class="opt">=</span> <span class="kwd">shiftToX0</span><span class="opt">(</span>pts<span class="opt">,</span> even<span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>
            target<span class="opt">.</span><span class="kwd">setOkPos</span><span class="opt">(</span>EVEN<span class="opt">,</span> w<span class="opt">,</span> h<span class="opt">);</span>
            even<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> even<span class="opt">.</span>m_offset<span class="opt">;</span>

            <span class="kwd">shiftUpLines</span><span class="opt">(</span>pts<span class="opt">, -</span><span class="num">1</span><span class="opt">);</span>
            w <span class="opt">=</span> <span class="kwd">shiftToX0</span><span class="opt">(</span>pts<span class="opt">,</span> odd<span class="opt">,</span> <span class="num">1</span><span class="opt">);</span>
            odd<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> N_COL<span class="opt">;</span>
            target<span class="opt">.</span><span class="kwd">setOkPos</span><span class="opt">(</span>ODD<span class="opt">,</span> w<span class="opt">,</span> h<span class="opt">);</span>
            odd<span class="opt">.</span>m_vec <span class="opt">&gt;&gt;=</span> odd<span class="opt">.</span>m_offset<span class="opt">;</span>
        <span class="opt">}</span>

        <span class="kwa">static void</span> <span class="kwd">genAllOrientations</span><span class="opt">() {</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++) {</span>
                <span class="kwa">int</span> refPiece <span class="opt">=</span> BaseVecs<span class="opt">[</span>iPiece<span class="opt">];</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> N_ORIENT<span class="opt">;</span> iOrient<span class="opt">++) {</span>
                    Piece p <span class="opt">=</span> s_basePiece<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">];</span>
                    <span class="kwd">genOrientation</span><span class="opt">(</span>refPiece<span class="opt">,</span> iOrient<span class="opt">,</span> p<span class="opt">);</span>
                    <span class="kwa">if</span> <span class="opt">((</span>iPiece <span class="opt">==</span> SKIP_PIECE<span class="opt">)  &amp;&amp; (((</span>iOrient <span class="opt">/</span> <span class="num">3</span><span class="opt">) &amp;</span> <span class="num">1</span><span class="opt">) !=</span> <span class="num">0</span><span class="opt">))</span>
                        p<span class="opt">.</span>m_instance<span class="opt">[</span><span class="num">0</span><span class="opt">].</span>m_allowed <span class="opt">=</span> p<span class="opt">.</span>m_instance<span class="opt">[</span><span class="num">1</span><span class="opt">].</span>m_allowed <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iPiece <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iPiece <span class="opt">&lt;</span> N_PIECE_TYPE<span class="opt">;</span> iPiece<span class="opt">++) {</span>
                <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iOrient <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iOrient <span class="opt">&lt;</span> N_ORIENT<span class="opt">;</span> iOrient<span class="opt">++) {</span>
                    <span class="kwa">long</span> mask <span class="opt">=</span> <span class="num">1</span><span class="opt">;</span>
                    <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iRow <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iRow <span class="opt">&lt;</span> N_ROW<span class="opt">;</span> iRow<span class="opt">++) {</span>
                        Instance p <span class="opt">=</span> <span class="kwd">getPiece</span><span class="opt">(</span>iPiece<span class="opt">,</span> iOrient<span class="opt">, (</span>iRow <span class="opt">&amp;</span> <span class="num">1</span><span class="opt">));</span>
                        <span class="kwa">for</span> <span class="opt">(</span><span class="kwa">int</span> iCol <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span> iCol <span class="opt">&lt;</span> N_COL<span class="opt">;</span> iCol<span class="opt">++) {</span>
                            OkPieces allowed <span class="opt">=</span> g_okPieces<span class="opt">[</span>iRow<span class="opt">][</span>iCol<span class="opt">];</span>
                            <span class="kwa">if</span> <span class="opt">((</span>p<span class="opt">.</span>m_allowed <span class="opt">&amp;</span> mask<span class="opt">) !=</span> <span class="num">0</span><span class="opt">) {</span>
                                allowed<span class="opt">.</span>pieceVec<span class="opt">[</span>iPiece<span class="opt">][</span>allowed<span class="opt">.</span>nPieces<span class="opt">[</span>iPiece<span class="opt">]] =</span> p<span class="opt">.</span>m_vec <span class="opt">&lt;&lt;</span> iCol<span class="opt">;</span>
                                <span class="opt">(</span>allowed<span class="opt">.</span>nPieces<span class="opt">[</span>iPiece<span class="opt">])++;</span>
                            <span class="opt">}</span>

                            mask <span class="opt">&lt;&lt;=</span> <span class="num">1</span><span class="opt">;</span>
                        <span class="opt">}</span>
                    <span class="opt">}</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
        <span class="opt">}</span>

        <span class="kwa">static</span> Instance <span class="kwd">getPiece</span><span class="opt">(</span><span class="kwa">int</span> iPiece<span class="opt">,</span> <span class="kwa">int</span> iOrient<span class="opt">,</span> <span class="kwa">int</span> iParity<span class="opt">) {</span>
            <span class="kwa">return</span> s_basePiece<span class="opt">[</span>iPiece<span class="opt">][</span>iOrient<span class="opt">].</span>m_instance<span class="opt">[</span>iParity<span class="opt">];</span>
        <span class="opt">}</span>
    <span class="opt">}</span>


<span class="slc">//-- Main ---------------------------</span>
    <span class="kwa">public static void</span> <span class="kwd">main</span><span class="opt">(</span>String<span class="opt">[]</span> args<span class="opt">) {</span>
        <span class="kwa">if</span> <span class="opt">(</span>args<span class="opt">.</span>length <span class="opt">&gt;</span> <span class="num">2</span><span class="opt">)</span>
            System<span class="opt">.</span><span class="kwd">exit</span><span class="opt">(-</span><span class="num">1</span><span class="opt">);</span> <span class="slc">// spec says this is an error;</span>

        <span class="kwd">initGlobals</span><span class="opt">();</span>
        Board b <span class="opt">=</span> <span class="kwa">new</span> <span class="kwd">Board</span><span class="opt">();</span>
        Piece<span class="opt">.</span><span class="kwd">genAllOrientations</span><span class="opt">();</span>
        Board<span class="opt">.</span><span class="kwd">calcAlwaysBad</span><span class="opt">();</span>
        b<span class="opt">.</span><span class="kwd">genAllSolutions</span><span class="opt">(</span><span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">,</span> <span class="num">0</span><span class="opt">);</span>

        System<span class="opt">.</span>out<span class="opt">.</span><span class="kwd">println</span><span class="opt">(</span>b<span class="opt">.</span>m_nSoln <span class="opt">+</span> <span class="str">&quot; solutions found</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">);</span>
        System<span class="opt">.</span>out<span class="opt">.</span><span class="kwd">println</span><span class="opt">(</span>b<span class="opt">.</span>m_minSoln<span class="opt">);</span>
        System<span class="opt">.</span>out<span class="opt">.</span><span class="kwd">println</span><span class="opt">(</span>b<span class="opt">.</span>m_maxSoln<span class="opt">);</span>
    <span class="opt">}</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <h3 id="log">notes, command-line, and program output</h3>
    <pre>
NOTES:
64-bit Ubuntu quad core
java 10 2018-03-20
Java(TM) SE Runtime Environment 18.3 (build 10+46)
Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10+46, mixed mode)


Wed, 21 Mar 2018 18:18:28 GMT

MAKE:
mv meteor.java-2.java meteor.java
/opt/src/jdk-10/bin/javac -d .  meteor.java

1.31s to complete and log all make actions

COMMAND LINE:
/opt/src/jdk-10/bin/java   meteor 2098

PROGRAM OUTPUT:
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="./license.html"><span>license</span></a>
    </ul>
  </nav>
</footer>

